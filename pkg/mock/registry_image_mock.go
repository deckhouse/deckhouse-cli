// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/deckhouse-cli/pkg.RegistryImage -o registry_image_mock.go -n RegistryImageMock -p mock

import (
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/deckhouse-cli/pkg"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/types"
)

// RegistryImageMock implements mm_pkg.RegistryImage
type RegistryImageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConfigFile          func() (cp1 *v1.ConfigFile, err error)
	funcConfigFileOrigin    string
	inspectFuncConfigFile   func()
	afterConfigFileCounter  uint64
	beforeConfigFileCounter uint64
	ConfigFileMock          mRegistryImageMockConfigFile

	funcConfigName          func() (h1 v1.Hash, err error)
	funcConfigNameOrigin    string
	inspectFuncConfigName   func()
	afterConfigNameCounter  uint64
	beforeConfigNameCounter uint64
	ConfigNameMock          mRegistryImageMockConfigName

	funcDigest          func() (h1 v1.Hash, err error)
	funcDigestOrigin    string
	inspectFuncDigest   func()
	afterDigestCounter  uint64
	beforeDigestCounter uint64
	DigestMock          mRegistryImageMockDigest

	funcExtract          func() (r1 io.ReadCloser)
	funcExtractOrigin    string
	inspectFuncExtract   func()
	afterExtractCounter  uint64
	beforeExtractCounter uint64
	ExtractMock          mRegistryImageMockExtract

	funcGetMetadata          func() (i1 mm_pkg.ImageMeta, err error)
	funcGetMetadataOrigin    string
	inspectFuncGetMetadata   func()
	afterGetMetadataCounter  uint64
	beforeGetMetadataCounter uint64
	GetMetadataMock          mRegistryImageMockGetMetadata

	funcLayerByDiffID          func(h1 v1.Hash) (l1 v1.Layer, err error)
	funcLayerByDiffIDOrigin    string
	inspectFuncLayerByDiffID   func(h1 v1.Hash)
	afterLayerByDiffIDCounter  uint64
	beforeLayerByDiffIDCounter uint64
	LayerByDiffIDMock          mRegistryImageMockLayerByDiffID

	funcLayerByDigest          func(h1 v1.Hash) (l1 v1.Layer, err error)
	funcLayerByDigestOrigin    string
	inspectFuncLayerByDigest   func(h1 v1.Hash)
	afterLayerByDigestCounter  uint64
	beforeLayerByDigestCounter uint64
	LayerByDigestMock          mRegistryImageMockLayerByDigest

	funcLayers          func() (la1 []v1.Layer, err error)
	funcLayersOrigin    string
	inspectFuncLayers   func()
	afterLayersCounter  uint64
	beforeLayersCounter uint64
	LayersMock          mRegistryImageMockLayers

	funcManifest          func() (mp1 *v1.Manifest, err error)
	funcManifestOrigin    string
	inspectFuncManifest   func()
	afterManifestCounter  uint64
	beforeManifestCounter uint64
	ManifestMock          mRegistryImageMockManifest

	funcMediaType          func() (m1 types.MediaType, err error)
	funcMediaTypeOrigin    string
	inspectFuncMediaType   func()
	afterMediaTypeCounter  uint64
	beforeMediaTypeCounter uint64
	MediaTypeMock          mRegistryImageMockMediaType

	funcRawConfigFile          func() (ba1 []byte, err error)
	funcRawConfigFileOrigin    string
	inspectFuncRawConfigFile   func()
	afterRawConfigFileCounter  uint64
	beforeRawConfigFileCounter uint64
	RawConfigFileMock          mRegistryImageMockRawConfigFile

	funcRawManifest          func() (ba1 []byte, err error)
	funcRawManifestOrigin    string
	inspectFuncRawManifest   func()
	afterRawManifestCounter  uint64
	beforeRawManifestCounter uint64
	RawManifestMock          mRegistryImageMockRawManifest

	funcSetMetadata          func(metadata mm_pkg.ImageMeta)
	funcSetMetadataOrigin    string
	inspectFuncSetMetadata   func(metadata mm_pkg.ImageMeta)
	afterSetMetadataCounter  uint64
	beforeSetMetadataCounter uint64
	SetMetadataMock          mRegistryImageMockSetMetadata

	funcSize          func() (i1 int64, err error)
	funcSizeOrigin    string
	inspectFuncSize   func()
	afterSizeCounter  uint64
	beforeSizeCounter uint64
	SizeMock          mRegistryImageMockSize
}

// NewRegistryImageMock returns a mock for mm_pkg.RegistryImage
func NewRegistryImageMock(t minimock.Tester) *RegistryImageMock {
	m := &RegistryImageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConfigFileMock = mRegistryImageMockConfigFile{mock: m}

	m.ConfigNameMock = mRegistryImageMockConfigName{mock: m}

	m.DigestMock = mRegistryImageMockDigest{mock: m}

	m.ExtractMock = mRegistryImageMockExtract{mock: m}

	m.GetMetadataMock = mRegistryImageMockGetMetadata{mock: m}

	m.LayerByDiffIDMock = mRegistryImageMockLayerByDiffID{mock: m}
	m.LayerByDiffIDMock.callArgs = []*RegistryImageMockLayerByDiffIDParams{}

	m.LayerByDigestMock = mRegistryImageMockLayerByDigest{mock: m}
	m.LayerByDigestMock.callArgs = []*RegistryImageMockLayerByDigestParams{}

	m.LayersMock = mRegistryImageMockLayers{mock: m}

	m.ManifestMock = mRegistryImageMockManifest{mock: m}

	m.MediaTypeMock = mRegistryImageMockMediaType{mock: m}

	m.RawConfigFileMock = mRegistryImageMockRawConfigFile{mock: m}

	m.RawManifestMock = mRegistryImageMockRawManifest{mock: m}

	m.SetMetadataMock = mRegistryImageMockSetMetadata{mock: m}
	m.SetMetadataMock.callArgs = []*RegistryImageMockSetMetadataParams{}

	m.SizeMock = mRegistryImageMockSize{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryImageMockConfigFile struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockConfigFileExpectation
	expectations       []*RegistryImageMockConfigFileExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockConfigFileExpectation specifies expectation struct of the RegistryImage.ConfigFile
type RegistryImageMockConfigFileExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockConfigFileResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockConfigFileResults contains results of the RegistryImage.ConfigFile
type RegistryImageMockConfigFileResults struct {
	cp1 *v1.ConfigFile
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConfigFile *mRegistryImageMockConfigFile) Optional() *mRegistryImageMockConfigFile {
	mmConfigFile.optional = true
	return mmConfigFile
}

// Expect sets up expected params for RegistryImage.ConfigFile
func (mmConfigFile *mRegistryImageMockConfigFile) Expect() *mRegistryImageMockConfigFile {
	if mmConfigFile.mock.funcConfigFile != nil {
		mmConfigFile.mock.t.Fatalf("RegistryImageMock.ConfigFile mock is already set by Set")
	}

	if mmConfigFile.defaultExpectation == nil {
		mmConfigFile.defaultExpectation = &RegistryImageMockConfigFileExpectation{}
	}

	return mmConfigFile
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.ConfigFile
func (mmConfigFile *mRegistryImageMockConfigFile) Inspect(f func()) *mRegistryImageMockConfigFile {
	if mmConfigFile.mock.inspectFuncConfigFile != nil {
		mmConfigFile.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.ConfigFile")
	}

	mmConfigFile.mock.inspectFuncConfigFile = f

	return mmConfigFile
}

// Return sets up results that will be returned by RegistryImage.ConfigFile
func (mmConfigFile *mRegistryImageMockConfigFile) Return(cp1 *v1.ConfigFile, err error) *RegistryImageMock {
	if mmConfigFile.mock.funcConfigFile != nil {
		mmConfigFile.mock.t.Fatalf("RegistryImageMock.ConfigFile mock is already set by Set")
	}

	if mmConfigFile.defaultExpectation == nil {
		mmConfigFile.defaultExpectation = &RegistryImageMockConfigFileExpectation{mock: mmConfigFile.mock}
	}
	mmConfigFile.defaultExpectation.results = &RegistryImageMockConfigFileResults{cp1, err}
	mmConfigFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConfigFile.mock
}

// Set uses given function f to mock the RegistryImage.ConfigFile method
func (mmConfigFile *mRegistryImageMockConfigFile) Set(f func() (cp1 *v1.ConfigFile, err error)) *RegistryImageMock {
	if mmConfigFile.defaultExpectation != nil {
		mmConfigFile.mock.t.Fatalf("Default expectation is already set for the RegistryImage.ConfigFile method")
	}

	if len(mmConfigFile.expectations) > 0 {
		mmConfigFile.mock.t.Fatalf("Some expectations are already set for the RegistryImage.ConfigFile method")
	}

	mmConfigFile.mock.funcConfigFile = f
	mmConfigFile.mock.funcConfigFileOrigin = minimock.CallerInfo(1)
	return mmConfigFile.mock
}

// Times sets number of times RegistryImage.ConfigFile should be invoked
func (mmConfigFile *mRegistryImageMockConfigFile) Times(n uint64) *mRegistryImageMockConfigFile {
	if n == 0 {
		mmConfigFile.mock.t.Fatalf("Times of RegistryImageMock.ConfigFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConfigFile.expectedInvocations, n)
	mmConfigFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConfigFile
}

func (mmConfigFile *mRegistryImageMockConfigFile) invocationsDone() bool {
	if len(mmConfigFile.expectations) == 0 && mmConfigFile.defaultExpectation == nil && mmConfigFile.mock.funcConfigFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConfigFile.mock.afterConfigFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConfigFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConfigFile implements mm_pkg.RegistryImage
func (mmConfigFile *RegistryImageMock) ConfigFile() (cp1 *v1.ConfigFile, err error) {
	mm_atomic.AddUint64(&mmConfigFile.beforeConfigFileCounter, 1)
	defer mm_atomic.AddUint64(&mmConfigFile.afterConfigFileCounter, 1)

	mmConfigFile.t.Helper()

	if mmConfigFile.inspectFuncConfigFile != nil {
		mmConfigFile.inspectFuncConfigFile()
	}

	if mmConfigFile.ConfigFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConfigFile.ConfigFileMock.defaultExpectation.Counter, 1)

		mm_results := mmConfigFile.ConfigFileMock.defaultExpectation.results
		if mm_results == nil {
			mmConfigFile.t.Fatal("No results are set for the RegistryImageMock.ConfigFile")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConfigFile.funcConfigFile != nil {
		return mmConfigFile.funcConfigFile()
	}
	mmConfigFile.t.Fatalf("Unexpected call to RegistryImageMock.ConfigFile.")
	return
}

// ConfigFileAfterCounter returns a count of finished RegistryImageMock.ConfigFile invocations
func (mmConfigFile *RegistryImageMock) ConfigFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfigFile.afterConfigFileCounter)
}

// ConfigFileBeforeCounter returns a count of RegistryImageMock.ConfigFile invocations
func (mmConfigFile *RegistryImageMock) ConfigFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfigFile.beforeConfigFileCounter)
}

// MinimockConfigFileDone returns true if the count of the ConfigFile invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockConfigFileDone() bool {
	if m.ConfigFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConfigFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConfigFileMock.invocationsDone()
}

// MinimockConfigFileInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockConfigFileInspect() {
	for _, e := range m.ConfigFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.ConfigFile")
		}
	}

	afterConfigFileCounter := mm_atomic.LoadUint64(&m.afterConfigFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConfigFileMock.defaultExpectation != nil && afterConfigFileCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.ConfigFile at\n%s", m.ConfigFileMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfigFile != nil && afterConfigFileCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.ConfigFile at\n%s", m.funcConfigFileOrigin)
	}

	if !m.ConfigFileMock.invocationsDone() && afterConfigFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.ConfigFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConfigFileMock.expectedInvocations), m.ConfigFileMock.expectedInvocationsOrigin, afterConfigFileCounter)
	}
}

type mRegistryImageMockConfigName struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockConfigNameExpectation
	expectations       []*RegistryImageMockConfigNameExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockConfigNameExpectation specifies expectation struct of the RegistryImage.ConfigName
type RegistryImageMockConfigNameExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockConfigNameResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockConfigNameResults contains results of the RegistryImage.ConfigName
type RegistryImageMockConfigNameResults struct {
	h1  v1.Hash
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConfigName *mRegistryImageMockConfigName) Optional() *mRegistryImageMockConfigName {
	mmConfigName.optional = true
	return mmConfigName
}

// Expect sets up expected params for RegistryImage.ConfigName
func (mmConfigName *mRegistryImageMockConfigName) Expect() *mRegistryImageMockConfigName {
	if mmConfigName.mock.funcConfigName != nil {
		mmConfigName.mock.t.Fatalf("RegistryImageMock.ConfigName mock is already set by Set")
	}

	if mmConfigName.defaultExpectation == nil {
		mmConfigName.defaultExpectation = &RegistryImageMockConfigNameExpectation{}
	}

	return mmConfigName
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.ConfigName
func (mmConfigName *mRegistryImageMockConfigName) Inspect(f func()) *mRegistryImageMockConfigName {
	if mmConfigName.mock.inspectFuncConfigName != nil {
		mmConfigName.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.ConfigName")
	}

	mmConfigName.mock.inspectFuncConfigName = f

	return mmConfigName
}

// Return sets up results that will be returned by RegistryImage.ConfigName
func (mmConfigName *mRegistryImageMockConfigName) Return(h1 v1.Hash, err error) *RegistryImageMock {
	if mmConfigName.mock.funcConfigName != nil {
		mmConfigName.mock.t.Fatalf("RegistryImageMock.ConfigName mock is already set by Set")
	}

	if mmConfigName.defaultExpectation == nil {
		mmConfigName.defaultExpectation = &RegistryImageMockConfigNameExpectation{mock: mmConfigName.mock}
	}
	mmConfigName.defaultExpectation.results = &RegistryImageMockConfigNameResults{h1, err}
	mmConfigName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConfigName.mock
}

// Set uses given function f to mock the RegistryImage.ConfigName method
func (mmConfigName *mRegistryImageMockConfigName) Set(f func() (h1 v1.Hash, err error)) *RegistryImageMock {
	if mmConfigName.defaultExpectation != nil {
		mmConfigName.mock.t.Fatalf("Default expectation is already set for the RegistryImage.ConfigName method")
	}

	if len(mmConfigName.expectations) > 0 {
		mmConfigName.mock.t.Fatalf("Some expectations are already set for the RegistryImage.ConfigName method")
	}

	mmConfigName.mock.funcConfigName = f
	mmConfigName.mock.funcConfigNameOrigin = minimock.CallerInfo(1)
	return mmConfigName.mock
}

// Times sets number of times RegistryImage.ConfigName should be invoked
func (mmConfigName *mRegistryImageMockConfigName) Times(n uint64) *mRegistryImageMockConfigName {
	if n == 0 {
		mmConfigName.mock.t.Fatalf("Times of RegistryImageMock.ConfigName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConfigName.expectedInvocations, n)
	mmConfigName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConfigName
}

func (mmConfigName *mRegistryImageMockConfigName) invocationsDone() bool {
	if len(mmConfigName.expectations) == 0 && mmConfigName.defaultExpectation == nil && mmConfigName.mock.funcConfigName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConfigName.mock.afterConfigNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConfigName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConfigName implements mm_pkg.RegistryImage
func (mmConfigName *RegistryImageMock) ConfigName() (h1 v1.Hash, err error) {
	mm_atomic.AddUint64(&mmConfigName.beforeConfigNameCounter, 1)
	defer mm_atomic.AddUint64(&mmConfigName.afterConfigNameCounter, 1)

	mmConfigName.t.Helper()

	if mmConfigName.inspectFuncConfigName != nil {
		mmConfigName.inspectFuncConfigName()
	}

	if mmConfigName.ConfigNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConfigName.ConfigNameMock.defaultExpectation.Counter, 1)

		mm_results := mmConfigName.ConfigNameMock.defaultExpectation.results
		if mm_results == nil {
			mmConfigName.t.Fatal("No results are set for the RegistryImageMock.ConfigName")
		}
		return (*mm_results).h1, (*mm_results).err
	}
	if mmConfigName.funcConfigName != nil {
		return mmConfigName.funcConfigName()
	}
	mmConfigName.t.Fatalf("Unexpected call to RegistryImageMock.ConfigName.")
	return
}

// ConfigNameAfterCounter returns a count of finished RegistryImageMock.ConfigName invocations
func (mmConfigName *RegistryImageMock) ConfigNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfigName.afterConfigNameCounter)
}

// ConfigNameBeforeCounter returns a count of RegistryImageMock.ConfigName invocations
func (mmConfigName *RegistryImageMock) ConfigNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfigName.beforeConfigNameCounter)
}

// MinimockConfigNameDone returns true if the count of the ConfigName invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockConfigNameDone() bool {
	if m.ConfigNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConfigNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConfigNameMock.invocationsDone()
}

// MinimockConfigNameInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockConfigNameInspect() {
	for _, e := range m.ConfigNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.ConfigName")
		}
	}

	afterConfigNameCounter := mm_atomic.LoadUint64(&m.afterConfigNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConfigNameMock.defaultExpectation != nil && afterConfigNameCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.ConfigName at\n%s", m.ConfigNameMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfigName != nil && afterConfigNameCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.ConfigName at\n%s", m.funcConfigNameOrigin)
	}

	if !m.ConfigNameMock.invocationsDone() && afterConfigNameCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.ConfigName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConfigNameMock.expectedInvocations), m.ConfigNameMock.expectedInvocationsOrigin, afterConfigNameCounter)
	}
}

type mRegistryImageMockDigest struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockDigestExpectation
	expectations       []*RegistryImageMockDigestExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockDigestExpectation specifies expectation struct of the RegistryImage.Digest
type RegistryImageMockDigestExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockDigestResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockDigestResults contains results of the RegistryImage.Digest
type RegistryImageMockDigestResults struct {
	h1  v1.Hash
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDigest *mRegistryImageMockDigest) Optional() *mRegistryImageMockDigest {
	mmDigest.optional = true
	return mmDigest
}

// Expect sets up expected params for RegistryImage.Digest
func (mmDigest *mRegistryImageMockDigest) Expect() *mRegistryImageMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("RegistryImageMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &RegistryImageMockDigestExpectation{}
	}

	return mmDigest
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.Digest
func (mmDigest *mRegistryImageMockDigest) Inspect(f func()) *mRegistryImageMockDigest {
	if mmDigest.mock.inspectFuncDigest != nil {
		mmDigest.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.Digest")
	}

	mmDigest.mock.inspectFuncDigest = f

	return mmDigest
}

// Return sets up results that will be returned by RegistryImage.Digest
func (mmDigest *mRegistryImageMockDigest) Return(h1 v1.Hash, err error) *RegistryImageMock {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("RegistryImageMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &RegistryImageMockDigestExpectation{mock: mmDigest.mock}
	}
	mmDigest.defaultExpectation.results = &RegistryImageMockDigestResults{h1, err}
	mmDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// Set uses given function f to mock the RegistryImage.Digest method
func (mmDigest *mRegistryImageMockDigest) Set(f func() (h1 v1.Hash, err error)) *RegistryImageMock {
	if mmDigest.defaultExpectation != nil {
		mmDigest.mock.t.Fatalf("Default expectation is already set for the RegistryImage.Digest method")
	}

	if len(mmDigest.expectations) > 0 {
		mmDigest.mock.t.Fatalf("Some expectations are already set for the RegistryImage.Digest method")
	}

	mmDigest.mock.funcDigest = f
	mmDigest.mock.funcDigestOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// Times sets number of times RegistryImage.Digest should be invoked
func (mmDigest *mRegistryImageMockDigest) Times(n uint64) *mRegistryImageMockDigest {
	if n == 0 {
		mmDigest.mock.t.Fatalf("Times of RegistryImageMock.Digest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDigest.expectedInvocations, n)
	mmDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDigest
}

func (mmDigest *mRegistryImageMockDigest) invocationsDone() bool {
	if len(mmDigest.expectations) == 0 && mmDigest.defaultExpectation == nil && mmDigest.mock.funcDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDigest.mock.afterDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Digest implements mm_pkg.RegistryImage
func (mmDigest *RegistryImageMock) Digest() (h1 v1.Hash, err error) {
	mm_atomic.AddUint64(&mmDigest.beforeDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmDigest.afterDigestCounter, 1)

	mmDigest.t.Helper()

	if mmDigest.inspectFuncDigest != nil {
		mmDigest.inspectFuncDigest()
	}

	if mmDigest.DigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigest.DigestMock.defaultExpectation.Counter, 1)

		mm_results := mmDigest.DigestMock.defaultExpectation.results
		if mm_results == nil {
			mmDigest.t.Fatal("No results are set for the RegistryImageMock.Digest")
		}
		return (*mm_results).h1, (*mm_results).err
	}
	if mmDigest.funcDigest != nil {
		return mmDigest.funcDigest()
	}
	mmDigest.t.Fatalf("Unexpected call to RegistryImageMock.Digest.")
	return
}

// DigestAfterCounter returns a count of finished RegistryImageMock.Digest invocations
func (mmDigest *RegistryImageMock) DigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.afterDigestCounter)
}

// DigestBeforeCounter returns a count of RegistryImageMock.Digest invocations
func (mmDigest *RegistryImageMock) DigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.beforeDigestCounter)
}

// MinimockDigestDone returns true if the count of the Digest invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockDigestDone() bool {
	if m.DigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DigestMock.invocationsDone()
}

// MinimockDigestInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockDigestInspect() {
	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.Digest")
		}
	}

	afterDigestCounter := mm_atomic.LoadUint64(&m.afterDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DigestMock.defaultExpectation != nil && afterDigestCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Digest at\n%s", m.DigestMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigest != nil && afterDigestCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Digest at\n%s", m.funcDigestOrigin)
	}

	if !m.DigestMock.invocationsDone() && afterDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.Digest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DigestMock.expectedInvocations), m.DigestMock.expectedInvocationsOrigin, afterDigestCounter)
	}
}

type mRegistryImageMockExtract struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockExtractExpectation
	expectations       []*RegistryImageMockExtractExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockExtractExpectation specifies expectation struct of the RegistryImage.Extract
type RegistryImageMockExtractExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockExtractResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockExtractResults contains results of the RegistryImage.Extract
type RegistryImageMockExtractResults struct {
	r1 io.ReadCloser
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExtract *mRegistryImageMockExtract) Optional() *mRegistryImageMockExtract {
	mmExtract.optional = true
	return mmExtract
}

// Expect sets up expected params for RegistryImage.Extract
func (mmExtract *mRegistryImageMockExtract) Expect() *mRegistryImageMockExtract {
	if mmExtract.mock.funcExtract != nil {
		mmExtract.mock.t.Fatalf("RegistryImageMock.Extract mock is already set by Set")
	}

	if mmExtract.defaultExpectation == nil {
		mmExtract.defaultExpectation = &RegistryImageMockExtractExpectation{}
	}

	return mmExtract
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.Extract
func (mmExtract *mRegistryImageMockExtract) Inspect(f func()) *mRegistryImageMockExtract {
	if mmExtract.mock.inspectFuncExtract != nil {
		mmExtract.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.Extract")
	}

	mmExtract.mock.inspectFuncExtract = f

	return mmExtract
}

// Return sets up results that will be returned by RegistryImage.Extract
func (mmExtract *mRegistryImageMockExtract) Return(r1 io.ReadCloser) *RegistryImageMock {
	if mmExtract.mock.funcExtract != nil {
		mmExtract.mock.t.Fatalf("RegistryImageMock.Extract mock is already set by Set")
	}

	if mmExtract.defaultExpectation == nil {
		mmExtract.defaultExpectation = &RegistryImageMockExtractExpectation{mock: mmExtract.mock}
	}
	mmExtract.defaultExpectation.results = &RegistryImageMockExtractResults{r1}
	mmExtract.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExtract.mock
}

// Set uses given function f to mock the RegistryImage.Extract method
func (mmExtract *mRegistryImageMockExtract) Set(f func() (r1 io.ReadCloser)) *RegistryImageMock {
	if mmExtract.defaultExpectation != nil {
		mmExtract.mock.t.Fatalf("Default expectation is already set for the RegistryImage.Extract method")
	}

	if len(mmExtract.expectations) > 0 {
		mmExtract.mock.t.Fatalf("Some expectations are already set for the RegistryImage.Extract method")
	}

	mmExtract.mock.funcExtract = f
	mmExtract.mock.funcExtractOrigin = minimock.CallerInfo(1)
	return mmExtract.mock
}

// Times sets number of times RegistryImage.Extract should be invoked
func (mmExtract *mRegistryImageMockExtract) Times(n uint64) *mRegistryImageMockExtract {
	if n == 0 {
		mmExtract.mock.t.Fatalf("Times of RegistryImageMock.Extract mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExtract.expectedInvocations, n)
	mmExtract.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExtract
}

func (mmExtract *mRegistryImageMockExtract) invocationsDone() bool {
	if len(mmExtract.expectations) == 0 && mmExtract.defaultExpectation == nil && mmExtract.mock.funcExtract == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExtract.mock.afterExtractCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExtract.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Extract implements mm_pkg.RegistryImage
func (mmExtract *RegistryImageMock) Extract() (r1 io.ReadCloser) {
	mm_atomic.AddUint64(&mmExtract.beforeExtractCounter, 1)
	defer mm_atomic.AddUint64(&mmExtract.afterExtractCounter, 1)

	mmExtract.t.Helper()

	if mmExtract.inspectFuncExtract != nil {
		mmExtract.inspectFuncExtract()
	}

	if mmExtract.ExtractMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExtract.ExtractMock.defaultExpectation.Counter, 1)

		mm_results := mmExtract.ExtractMock.defaultExpectation.results
		if mm_results == nil {
			mmExtract.t.Fatal("No results are set for the RegistryImageMock.Extract")
		}
		return (*mm_results).r1
	}
	if mmExtract.funcExtract != nil {
		return mmExtract.funcExtract()
	}
	mmExtract.t.Fatalf("Unexpected call to RegistryImageMock.Extract.")
	return
}

// ExtractAfterCounter returns a count of finished RegistryImageMock.Extract invocations
func (mmExtract *RegistryImageMock) ExtractAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtract.afterExtractCounter)
}

// ExtractBeforeCounter returns a count of RegistryImageMock.Extract invocations
func (mmExtract *RegistryImageMock) ExtractBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtract.beforeExtractCounter)
}

// MinimockExtractDone returns true if the count of the Extract invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockExtractDone() bool {
	if m.ExtractMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExtractMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExtractMock.invocationsDone()
}

// MinimockExtractInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockExtractInspect() {
	for _, e := range m.ExtractMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.Extract")
		}
	}

	afterExtractCounter := mm_atomic.LoadUint64(&m.afterExtractCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExtractMock.defaultExpectation != nil && afterExtractCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Extract at\n%s", m.ExtractMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExtract != nil && afterExtractCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Extract at\n%s", m.funcExtractOrigin)
	}

	if !m.ExtractMock.invocationsDone() && afterExtractCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.Extract at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExtractMock.expectedInvocations), m.ExtractMock.expectedInvocationsOrigin, afterExtractCounter)
	}
}

type mRegistryImageMockGetMetadata struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockGetMetadataExpectation
	expectations       []*RegistryImageMockGetMetadataExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockGetMetadataExpectation specifies expectation struct of the RegistryImage.GetMetadata
type RegistryImageMockGetMetadataExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockGetMetadataResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockGetMetadataResults contains results of the RegistryImage.GetMetadata
type RegistryImageMockGetMetadataResults struct {
	i1  mm_pkg.ImageMeta
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetMetadata *mRegistryImageMockGetMetadata) Optional() *mRegistryImageMockGetMetadata {
	mmGetMetadata.optional = true
	return mmGetMetadata
}

// Expect sets up expected params for RegistryImage.GetMetadata
func (mmGetMetadata *mRegistryImageMockGetMetadata) Expect() *mRegistryImageMockGetMetadata {
	if mmGetMetadata.mock.funcGetMetadata != nil {
		mmGetMetadata.mock.t.Fatalf("RegistryImageMock.GetMetadata mock is already set by Set")
	}

	if mmGetMetadata.defaultExpectation == nil {
		mmGetMetadata.defaultExpectation = &RegistryImageMockGetMetadataExpectation{}
	}

	return mmGetMetadata
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.GetMetadata
func (mmGetMetadata *mRegistryImageMockGetMetadata) Inspect(f func()) *mRegistryImageMockGetMetadata {
	if mmGetMetadata.mock.inspectFuncGetMetadata != nil {
		mmGetMetadata.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.GetMetadata")
	}

	mmGetMetadata.mock.inspectFuncGetMetadata = f

	return mmGetMetadata
}

// Return sets up results that will be returned by RegistryImage.GetMetadata
func (mmGetMetadata *mRegistryImageMockGetMetadata) Return(i1 mm_pkg.ImageMeta, err error) *RegistryImageMock {
	if mmGetMetadata.mock.funcGetMetadata != nil {
		mmGetMetadata.mock.t.Fatalf("RegistryImageMock.GetMetadata mock is already set by Set")
	}

	if mmGetMetadata.defaultExpectation == nil {
		mmGetMetadata.defaultExpectation = &RegistryImageMockGetMetadataExpectation{mock: mmGetMetadata.mock}
	}
	mmGetMetadata.defaultExpectation.results = &RegistryImageMockGetMetadataResults{i1, err}
	mmGetMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetMetadata.mock
}

// Set uses given function f to mock the RegistryImage.GetMetadata method
func (mmGetMetadata *mRegistryImageMockGetMetadata) Set(f func() (i1 mm_pkg.ImageMeta, err error)) *RegistryImageMock {
	if mmGetMetadata.defaultExpectation != nil {
		mmGetMetadata.mock.t.Fatalf("Default expectation is already set for the RegistryImage.GetMetadata method")
	}

	if len(mmGetMetadata.expectations) > 0 {
		mmGetMetadata.mock.t.Fatalf("Some expectations are already set for the RegistryImage.GetMetadata method")
	}

	mmGetMetadata.mock.funcGetMetadata = f
	mmGetMetadata.mock.funcGetMetadataOrigin = minimock.CallerInfo(1)
	return mmGetMetadata.mock
}

// Times sets number of times RegistryImage.GetMetadata should be invoked
func (mmGetMetadata *mRegistryImageMockGetMetadata) Times(n uint64) *mRegistryImageMockGetMetadata {
	if n == 0 {
		mmGetMetadata.mock.t.Fatalf("Times of RegistryImageMock.GetMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetMetadata.expectedInvocations, n)
	mmGetMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetMetadata
}

func (mmGetMetadata *mRegistryImageMockGetMetadata) invocationsDone() bool {
	if len(mmGetMetadata.expectations) == 0 && mmGetMetadata.defaultExpectation == nil && mmGetMetadata.mock.funcGetMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetMetadata.mock.afterGetMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetMetadata implements mm_pkg.RegistryImage
func (mmGetMetadata *RegistryImageMock) GetMetadata() (i1 mm_pkg.ImageMeta, err error) {
	mm_atomic.AddUint64(&mmGetMetadata.beforeGetMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMetadata.afterGetMetadataCounter, 1)

	mmGetMetadata.t.Helper()

	if mmGetMetadata.inspectFuncGetMetadata != nil {
		mmGetMetadata.inspectFuncGetMetadata()
	}

	if mmGetMetadata.GetMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMetadata.GetMetadataMock.defaultExpectation.Counter, 1)

		mm_results := mmGetMetadata.GetMetadataMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMetadata.t.Fatal("No results are set for the RegistryImageMock.GetMetadata")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetMetadata.funcGetMetadata != nil {
		return mmGetMetadata.funcGetMetadata()
	}
	mmGetMetadata.t.Fatalf("Unexpected call to RegistryImageMock.GetMetadata.")
	return
}

// GetMetadataAfterCounter returns a count of finished RegistryImageMock.GetMetadata invocations
func (mmGetMetadata *RegistryImageMock) GetMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMetadata.afterGetMetadataCounter)
}

// GetMetadataBeforeCounter returns a count of RegistryImageMock.GetMetadata invocations
func (mmGetMetadata *RegistryImageMock) GetMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMetadata.beforeGetMetadataCounter)
}

// MinimockGetMetadataDone returns true if the count of the GetMetadata invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockGetMetadataDone() bool {
	if m.GetMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMetadataMock.invocationsDone()
}

// MinimockGetMetadataInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockGetMetadataInspect() {
	for _, e := range m.GetMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.GetMetadata")
		}
	}

	afterGetMetadataCounter := mm_atomic.LoadUint64(&m.afterGetMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMetadataMock.defaultExpectation != nil && afterGetMetadataCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.GetMetadata at\n%s", m.GetMetadataMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMetadata != nil && afterGetMetadataCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.GetMetadata at\n%s", m.funcGetMetadataOrigin)
	}

	if !m.GetMetadataMock.invocationsDone() && afterGetMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.GetMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMetadataMock.expectedInvocations), m.GetMetadataMock.expectedInvocationsOrigin, afterGetMetadataCounter)
	}
}

type mRegistryImageMockLayerByDiffID struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockLayerByDiffIDExpectation
	expectations       []*RegistryImageMockLayerByDiffIDExpectation

	callArgs []*RegistryImageMockLayerByDiffIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockLayerByDiffIDExpectation specifies expectation struct of the RegistryImage.LayerByDiffID
type RegistryImageMockLayerByDiffIDExpectation struct {
	mock               *RegistryImageMock
	params             *RegistryImageMockLayerByDiffIDParams
	paramPtrs          *RegistryImageMockLayerByDiffIDParamPtrs
	expectationOrigins RegistryImageMockLayerByDiffIDExpectationOrigins
	results            *RegistryImageMockLayerByDiffIDResults
	returnOrigin       string
	Counter            uint64
}

// RegistryImageMockLayerByDiffIDParams contains parameters of the RegistryImage.LayerByDiffID
type RegistryImageMockLayerByDiffIDParams struct {
	h1 v1.Hash
}

// RegistryImageMockLayerByDiffIDParamPtrs contains pointers to parameters of the RegistryImage.LayerByDiffID
type RegistryImageMockLayerByDiffIDParamPtrs struct {
	h1 *v1.Hash
}

// RegistryImageMockLayerByDiffIDResults contains results of the RegistryImage.LayerByDiffID
type RegistryImageMockLayerByDiffIDResults struct {
	l1  v1.Layer
	err error
}

// RegistryImageMockLayerByDiffIDOrigins contains origins of expectations of the RegistryImage.LayerByDiffID
type RegistryImageMockLayerByDiffIDExpectationOrigins struct {
	origin   string
	originH1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) Optional() *mRegistryImageMockLayerByDiffID {
	mmLayerByDiffID.optional = true
	return mmLayerByDiffID
}

// Expect sets up expected params for RegistryImage.LayerByDiffID
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) Expect(h1 v1.Hash) *mRegistryImageMockLayerByDiffID {
	if mmLayerByDiffID.mock.funcLayerByDiffID != nil {
		mmLayerByDiffID.mock.t.Fatalf("RegistryImageMock.LayerByDiffID mock is already set by Set")
	}

	if mmLayerByDiffID.defaultExpectation == nil {
		mmLayerByDiffID.defaultExpectation = &RegistryImageMockLayerByDiffIDExpectation{}
	}

	if mmLayerByDiffID.defaultExpectation.paramPtrs != nil {
		mmLayerByDiffID.mock.t.Fatalf("RegistryImageMock.LayerByDiffID mock is already set by ExpectParams functions")
	}

	mmLayerByDiffID.defaultExpectation.params = &RegistryImageMockLayerByDiffIDParams{h1}
	mmLayerByDiffID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLayerByDiffID.expectations {
		if minimock.Equal(e.params, mmLayerByDiffID.defaultExpectation.params) {
			mmLayerByDiffID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLayerByDiffID.defaultExpectation.params)
		}
	}

	return mmLayerByDiffID
}

// ExpectH1Param1 sets up expected param h1 for RegistryImage.LayerByDiffID
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) ExpectH1Param1(h1 v1.Hash) *mRegistryImageMockLayerByDiffID {
	if mmLayerByDiffID.mock.funcLayerByDiffID != nil {
		mmLayerByDiffID.mock.t.Fatalf("RegistryImageMock.LayerByDiffID mock is already set by Set")
	}

	if mmLayerByDiffID.defaultExpectation == nil {
		mmLayerByDiffID.defaultExpectation = &RegistryImageMockLayerByDiffIDExpectation{}
	}

	if mmLayerByDiffID.defaultExpectation.params != nil {
		mmLayerByDiffID.mock.t.Fatalf("RegistryImageMock.LayerByDiffID mock is already set by Expect")
	}

	if mmLayerByDiffID.defaultExpectation.paramPtrs == nil {
		mmLayerByDiffID.defaultExpectation.paramPtrs = &RegistryImageMockLayerByDiffIDParamPtrs{}
	}
	mmLayerByDiffID.defaultExpectation.paramPtrs.h1 = &h1
	mmLayerByDiffID.defaultExpectation.expectationOrigins.originH1 = minimock.CallerInfo(1)

	return mmLayerByDiffID
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.LayerByDiffID
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) Inspect(f func(h1 v1.Hash)) *mRegistryImageMockLayerByDiffID {
	if mmLayerByDiffID.mock.inspectFuncLayerByDiffID != nil {
		mmLayerByDiffID.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.LayerByDiffID")
	}

	mmLayerByDiffID.mock.inspectFuncLayerByDiffID = f

	return mmLayerByDiffID
}

// Return sets up results that will be returned by RegistryImage.LayerByDiffID
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) Return(l1 v1.Layer, err error) *RegistryImageMock {
	if mmLayerByDiffID.mock.funcLayerByDiffID != nil {
		mmLayerByDiffID.mock.t.Fatalf("RegistryImageMock.LayerByDiffID mock is already set by Set")
	}

	if mmLayerByDiffID.defaultExpectation == nil {
		mmLayerByDiffID.defaultExpectation = &RegistryImageMockLayerByDiffIDExpectation{mock: mmLayerByDiffID.mock}
	}
	mmLayerByDiffID.defaultExpectation.results = &RegistryImageMockLayerByDiffIDResults{l1, err}
	mmLayerByDiffID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLayerByDiffID.mock
}

// Set uses given function f to mock the RegistryImage.LayerByDiffID method
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) Set(f func(h1 v1.Hash) (l1 v1.Layer, err error)) *RegistryImageMock {
	if mmLayerByDiffID.defaultExpectation != nil {
		mmLayerByDiffID.mock.t.Fatalf("Default expectation is already set for the RegistryImage.LayerByDiffID method")
	}

	if len(mmLayerByDiffID.expectations) > 0 {
		mmLayerByDiffID.mock.t.Fatalf("Some expectations are already set for the RegistryImage.LayerByDiffID method")
	}

	mmLayerByDiffID.mock.funcLayerByDiffID = f
	mmLayerByDiffID.mock.funcLayerByDiffIDOrigin = minimock.CallerInfo(1)
	return mmLayerByDiffID.mock
}

// When sets expectation for the RegistryImage.LayerByDiffID which will trigger the result defined by the following
// Then helper
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) When(h1 v1.Hash) *RegistryImageMockLayerByDiffIDExpectation {
	if mmLayerByDiffID.mock.funcLayerByDiffID != nil {
		mmLayerByDiffID.mock.t.Fatalf("RegistryImageMock.LayerByDiffID mock is already set by Set")
	}

	expectation := &RegistryImageMockLayerByDiffIDExpectation{
		mock:               mmLayerByDiffID.mock,
		params:             &RegistryImageMockLayerByDiffIDParams{h1},
		expectationOrigins: RegistryImageMockLayerByDiffIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLayerByDiffID.expectations = append(mmLayerByDiffID.expectations, expectation)
	return expectation
}

// Then sets up RegistryImage.LayerByDiffID return parameters for the expectation previously defined by the When method
func (e *RegistryImageMockLayerByDiffIDExpectation) Then(l1 v1.Layer, err error) *RegistryImageMock {
	e.results = &RegistryImageMockLayerByDiffIDResults{l1, err}
	return e.mock
}

// Times sets number of times RegistryImage.LayerByDiffID should be invoked
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) Times(n uint64) *mRegistryImageMockLayerByDiffID {
	if n == 0 {
		mmLayerByDiffID.mock.t.Fatalf("Times of RegistryImageMock.LayerByDiffID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLayerByDiffID.expectedInvocations, n)
	mmLayerByDiffID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLayerByDiffID
}

func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) invocationsDone() bool {
	if len(mmLayerByDiffID.expectations) == 0 && mmLayerByDiffID.defaultExpectation == nil && mmLayerByDiffID.mock.funcLayerByDiffID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLayerByDiffID.mock.afterLayerByDiffIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLayerByDiffID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LayerByDiffID implements mm_pkg.RegistryImage
func (mmLayerByDiffID *RegistryImageMock) LayerByDiffID(h1 v1.Hash) (l1 v1.Layer, err error) {
	mm_atomic.AddUint64(&mmLayerByDiffID.beforeLayerByDiffIDCounter, 1)
	defer mm_atomic.AddUint64(&mmLayerByDiffID.afterLayerByDiffIDCounter, 1)

	mmLayerByDiffID.t.Helper()

	if mmLayerByDiffID.inspectFuncLayerByDiffID != nil {
		mmLayerByDiffID.inspectFuncLayerByDiffID(h1)
	}

	mm_params := RegistryImageMockLayerByDiffIDParams{h1}

	// Record call args
	mmLayerByDiffID.LayerByDiffIDMock.mutex.Lock()
	mmLayerByDiffID.LayerByDiffIDMock.callArgs = append(mmLayerByDiffID.LayerByDiffIDMock.callArgs, &mm_params)
	mmLayerByDiffID.LayerByDiffIDMock.mutex.Unlock()

	for _, e := range mmLayerByDiffID.LayerByDiffIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmLayerByDiffID.LayerByDiffIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLayerByDiffID.LayerByDiffIDMock.defaultExpectation.Counter, 1)
		mm_want := mmLayerByDiffID.LayerByDiffIDMock.defaultExpectation.params
		mm_want_ptrs := mmLayerByDiffID.LayerByDiffIDMock.defaultExpectation.paramPtrs

		mm_got := RegistryImageMockLayerByDiffIDParams{h1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.h1 != nil && !minimock.Equal(*mm_want_ptrs.h1, mm_got.h1) {
				mmLayerByDiffID.t.Errorf("RegistryImageMock.LayerByDiffID got unexpected parameter h1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLayerByDiffID.LayerByDiffIDMock.defaultExpectation.expectationOrigins.originH1, *mm_want_ptrs.h1, mm_got.h1, minimock.Diff(*mm_want_ptrs.h1, mm_got.h1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLayerByDiffID.t.Errorf("RegistryImageMock.LayerByDiffID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLayerByDiffID.LayerByDiffIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLayerByDiffID.LayerByDiffIDMock.defaultExpectation.results
		if mm_results == nil {
			mmLayerByDiffID.t.Fatal("No results are set for the RegistryImageMock.LayerByDiffID")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmLayerByDiffID.funcLayerByDiffID != nil {
		return mmLayerByDiffID.funcLayerByDiffID(h1)
	}
	mmLayerByDiffID.t.Fatalf("Unexpected call to RegistryImageMock.LayerByDiffID. %v", h1)
	return
}

// LayerByDiffIDAfterCounter returns a count of finished RegistryImageMock.LayerByDiffID invocations
func (mmLayerByDiffID *RegistryImageMock) LayerByDiffIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayerByDiffID.afterLayerByDiffIDCounter)
}

// LayerByDiffIDBeforeCounter returns a count of RegistryImageMock.LayerByDiffID invocations
func (mmLayerByDiffID *RegistryImageMock) LayerByDiffIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayerByDiffID.beforeLayerByDiffIDCounter)
}

// Calls returns a list of arguments used in each call to RegistryImageMock.LayerByDiffID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLayerByDiffID *mRegistryImageMockLayerByDiffID) Calls() []*RegistryImageMockLayerByDiffIDParams {
	mmLayerByDiffID.mutex.RLock()

	argCopy := make([]*RegistryImageMockLayerByDiffIDParams, len(mmLayerByDiffID.callArgs))
	copy(argCopy, mmLayerByDiffID.callArgs)

	mmLayerByDiffID.mutex.RUnlock()

	return argCopy
}

// MinimockLayerByDiffIDDone returns true if the count of the LayerByDiffID invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockLayerByDiffIDDone() bool {
	if m.LayerByDiffIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LayerByDiffIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LayerByDiffIDMock.invocationsDone()
}

// MinimockLayerByDiffIDInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockLayerByDiffIDInspect() {
	for _, e := range m.LayerByDiffIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryImageMock.LayerByDiffID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLayerByDiffIDCounter := mm_atomic.LoadUint64(&m.afterLayerByDiffIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LayerByDiffIDMock.defaultExpectation != nil && afterLayerByDiffIDCounter < 1 {
		if m.LayerByDiffIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryImageMock.LayerByDiffID at\n%s", m.LayerByDiffIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryImageMock.LayerByDiffID at\n%s with params: %#v", m.LayerByDiffIDMock.defaultExpectation.expectationOrigins.origin, *m.LayerByDiffIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLayerByDiffID != nil && afterLayerByDiffIDCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.LayerByDiffID at\n%s", m.funcLayerByDiffIDOrigin)
	}

	if !m.LayerByDiffIDMock.invocationsDone() && afterLayerByDiffIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.LayerByDiffID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LayerByDiffIDMock.expectedInvocations), m.LayerByDiffIDMock.expectedInvocationsOrigin, afterLayerByDiffIDCounter)
	}
}

type mRegistryImageMockLayerByDigest struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockLayerByDigestExpectation
	expectations       []*RegistryImageMockLayerByDigestExpectation

	callArgs []*RegistryImageMockLayerByDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockLayerByDigestExpectation specifies expectation struct of the RegistryImage.LayerByDigest
type RegistryImageMockLayerByDigestExpectation struct {
	mock               *RegistryImageMock
	params             *RegistryImageMockLayerByDigestParams
	paramPtrs          *RegistryImageMockLayerByDigestParamPtrs
	expectationOrigins RegistryImageMockLayerByDigestExpectationOrigins
	results            *RegistryImageMockLayerByDigestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryImageMockLayerByDigestParams contains parameters of the RegistryImage.LayerByDigest
type RegistryImageMockLayerByDigestParams struct {
	h1 v1.Hash
}

// RegistryImageMockLayerByDigestParamPtrs contains pointers to parameters of the RegistryImage.LayerByDigest
type RegistryImageMockLayerByDigestParamPtrs struct {
	h1 *v1.Hash
}

// RegistryImageMockLayerByDigestResults contains results of the RegistryImage.LayerByDigest
type RegistryImageMockLayerByDigestResults struct {
	l1  v1.Layer
	err error
}

// RegistryImageMockLayerByDigestOrigins contains origins of expectations of the RegistryImage.LayerByDigest
type RegistryImageMockLayerByDigestExpectationOrigins struct {
	origin   string
	originH1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) Optional() *mRegistryImageMockLayerByDigest {
	mmLayerByDigest.optional = true
	return mmLayerByDigest
}

// Expect sets up expected params for RegistryImage.LayerByDigest
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) Expect(h1 v1.Hash) *mRegistryImageMockLayerByDigest {
	if mmLayerByDigest.mock.funcLayerByDigest != nil {
		mmLayerByDigest.mock.t.Fatalf("RegistryImageMock.LayerByDigest mock is already set by Set")
	}

	if mmLayerByDigest.defaultExpectation == nil {
		mmLayerByDigest.defaultExpectation = &RegistryImageMockLayerByDigestExpectation{}
	}

	if mmLayerByDigest.defaultExpectation.paramPtrs != nil {
		mmLayerByDigest.mock.t.Fatalf("RegistryImageMock.LayerByDigest mock is already set by ExpectParams functions")
	}

	mmLayerByDigest.defaultExpectation.params = &RegistryImageMockLayerByDigestParams{h1}
	mmLayerByDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLayerByDigest.expectations {
		if minimock.Equal(e.params, mmLayerByDigest.defaultExpectation.params) {
			mmLayerByDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLayerByDigest.defaultExpectation.params)
		}
	}

	return mmLayerByDigest
}

// ExpectH1Param1 sets up expected param h1 for RegistryImage.LayerByDigest
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) ExpectH1Param1(h1 v1.Hash) *mRegistryImageMockLayerByDigest {
	if mmLayerByDigest.mock.funcLayerByDigest != nil {
		mmLayerByDigest.mock.t.Fatalf("RegistryImageMock.LayerByDigest mock is already set by Set")
	}

	if mmLayerByDigest.defaultExpectation == nil {
		mmLayerByDigest.defaultExpectation = &RegistryImageMockLayerByDigestExpectation{}
	}

	if mmLayerByDigest.defaultExpectation.params != nil {
		mmLayerByDigest.mock.t.Fatalf("RegistryImageMock.LayerByDigest mock is already set by Expect")
	}

	if mmLayerByDigest.defaultExpectation.paramPtrs == nil {
		mmLayerByDigest.defaultExpectation.paramPtrs = &RegistryImageMockLayerByDigestParamPtrs{}
	}
	mmLayerByDigest.defaultExpectation.paramPtrs.h1 = &h1
	mmLayerByDigest.defaultExpectation.expectationOrigins.originH1 = minimock.CallerInfo(1)

	return mmLayerByDigest
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.LayerByDigest
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) Inspect(f func(h1 v1.Hash)) *mRegistryImageMockLayerByDigest {
	if mmLayerByDigest.mock.inspectFuncLayerByDigest != nil {
		mmLayerByDigest.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.LayerByDigest")
	}

	mmLayerByDigest.mock.inspectFuncLayerByDigest = f

	return mmLayerByDigest
}

// Return sets up results that will be returned by RegistryImage.LayerByDigest
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) Return(l1 v1.Layer, err error) *RegistryImageMock {
	if mmLayerByDigest.mock.funcLayerByDigest != nil {
		mmLayerByDigest.mock.t.Fatalf("RegistryImageMock.LayerByDigest mock is already set by Set")
	}

	if mmLayerByDigest.defaultExpectation == nil {
		mmLayerByDigest.defaultExpectation = &RegistryImageMockLayerByDigestExpectation{mock: mmLayerByDigest.mock}
	}
	mmLayerByDigest.defaultExpectation.results = &RegistryImageMockLayerByDigestResults{l1, err}
	mmLayerByDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLayerByDigest.mock
}

// Set uses given function f to mock the RegistryImage.LayerByDigest method
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) Set(f func(h1 v1.Hash) (l1 v1.Layer, err error)) *RegistryImageMock {
	if mmLayerByDigest.defaultExpectation != nil {
		mmLayerByDigest.mock.t.Fatalf("Default expectation is already set for the RegistryImage.LayerByDigest method")
	}

	if len(mmLayerByDigest.expectations) > 0 {
		mmLayerByDigest.mock.t.Fatalf("Some expectations are already set for the RegistryImage.LayerByDigest method")
	}

	mmLayerByDigest.mock.funcLayerByDigest = f
	mmLayerByDigest.mock.funcLayerByDigestOrigin = minimock.CallerInfo(1)
	return mmLayerByDigest.mock
}

// When sets expectation for the RegistryImage.LayerByDigest which will trigger the result defined by the following
// Then helper
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) When(h1 v1.Hash) *RegistryImageMockLayerByDigestExpectation {
	if mmLayerByDigest.mock.funcLayerByDigest != nil {
		mmLayerByDigest.mock.t.Fatalf("RegistryImageMock.LayerByDigest mock is already set by Set")
	}

	expectation := &RegistryImageMockLayerByDigestExpectation{
		mock:               mmLayerByDigest.mock,
		params:             &RegistryImageMockLayerByDigestParams{h1},
		expectationOrigins: RegistryImageMockLayerByDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLayerByDigest.expectations = append(mmLayerByDigest.expectations, expectation)
	return expectation
}

// Then sets up RegistryImage.LayerByDigest return parameters for the expectation previously defined by the When method
func (e *RegistryImageMockLayerByDigestExpectation) Then(l1 v1.Layer, err error) *RegistryImageMock {
	e.results = &RegistryImageMockLayerByDigestResults{l1, err}
	return e.mock
}

// Times sets number of times RegistryImage.LayerByDigest should be invoked
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) Times(n uint64) *mRegistryImageMockLayerByDigest {
	if n == 0 {
		mmLayerByDigest.mock.t.Fatalf("Times of RegistryImageMock.LayerByDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLayerByDigest.expectedInvocations, n)
	mmLayerByDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLayerByDigest
}

func (mmLayerByDigest *mRegistryImageMockLayerByDigest) invocationsDone() bool {
	if len(mmLayerByDigest.expectations) == 0 && mmLayerByDigest.defaultExpectation == nil && mmLayerByDigest.mock.funcLayerByDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLayerByDigest.mock.afterLayerByDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLayerByDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LayerByDigest implements mm_pkg.RegistryImage
func (mmLayerByDigest *RegistryImageMock) LayerByDigest(h1 v1.Hash) (l1 v1.Layer, err error) {
	mm_atomic.AddUint64(&mmLayerByDigest.beforeLayerByDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmLayerByDigest.afterLayerByDigestCounter, 1)

	mmLayerByDigest.t.Helper()

	if mmLayerByDigest.inspectFuncLayerByDigest != nil {
		mmLayerByDigest.inspectFuncLayerByDigest(h1)
	}

	mm_params := RegistryImageMockLayerByDigestParams{h1}

	// Record call args
	mmLayerByDigest.LayerByDigestMock.mutex.Lock()
	mmLayerByDigest.LayerByDigestMock.callArgs = append(mmLayerByDigest.LayerByDigestMock.callArgs, &mm_params)
	mmLayerByDigest.LayerByDigestMock.mutex.Unlock()

	for _, e := range mmLayerByDigest.LayerByDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmLayerByDigest.LayerByDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLayerByDigest.LayerByDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmLayerByDigest.LayerByDigestMock.defaultExpectation.params
		mm_want_ptrs := mmLayerByDigest.LayerByDigestMock.defaultExpectation.paramPtrs

		mm_got := RegistryImageMockLayerByDigestParams{h1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.h1 != nil && !minimock.Equal(*mm_want_ptrs.h1, mm_got.h1) {
				mmLayerByDigest.t.Errorf("RegistryImageMock.LayerByDigest got unexpected parameter h1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLayerByDigest.LayerByDigestMock.defaultExpectation.expectationOrigins.originH1, *mm_want_ptrs.h1, mm_got.h1, minimock.Diff(*mm_want_ptrs.h1, mm_got.h1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLayerByDigest.t.Errorf("RegistryImageMock.LayerByDigest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLayerByDigest.LayerByDigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLayerByDigest.LayerByDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmLayerByDigest.t.Fatal("No results are set for the RegistryImageMock.LayerByDigest")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmLayerByDigest.funcLayerByDigest != nil {
		return mmLayerByDigest.funcLayerByDigest(h1)
	}
	mmLayerByDigest.t.Fatalf("Unexpected call to RegistryImageMock.LayerByDigest. %v", h1)
	return
}

// LayerByDigestAfterCounter returns a count of finished RegistryImageMock.LayerByDigest invocations
func (mmLayerByDigest *RegistryImageMock) LayerByDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayerByDigest.afterLayerByDigestCounter)
}

// LayerByDigestBeforeCounter returns a count of RegistryImageMock.LayerByDigest invocations
func (mmLayerByDigest *RegistryImageMock) LayerByDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayerByDigest.beforeLayerByDigestCounter)
}

// Calls returns a list of arguments used in each call to RegistryImageMock.LayerByDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLayerByDigest *mRegistryImageMockLayerByDigest) Calls() []*RegistryImageMockLayerByDigestParams {
	mmLayerByDigest.mutex.RLock()

	argCopy := make([]*RegistryImageMockLayerByDigestParams, len(mmLayerByDigest.callArgs))
	copy(argCopy, mmLayerByDigest.callArgs)

	mmLayerByDigest.mutex.RUnlock()

	return argCopy
}

// MinimockLayerByDigestDone returns true if the count of the LayerByDigest invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockLayerByDigestDone() bool {
	if m.LayerByDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LayerByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LayerByDigestMock.invocationsDone()
}

// MinimockLayerByDigestInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockLayerByDigestInspect() {
	for _, e := range m.LayerByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryImageMock.LayerByDigest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLayerByDigestCounter := mm_atomic.LoadUint64(&m.afterLayerByDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LayerByDigestMock.defaultExpectation != nil && afterLayerByDigestCounter < 1 {
		if m.LayerByDigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryImageMock.LayerByDigest at\n%s", m.LayerByDigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryImageMock.LayerByDigest at\n%s with params: %#v", m.LayerByDigestMock.defaultExpectation.expectationOrigins.origin, *m.LayerByDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLayerByDigest != nil && afterLayerByDigestCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.LayerByDigest at\n%s", m.funcLayerByDigestOrigin)
	}

	if !m.LayerByDigestMock.invocationsDone() && afterLayerByDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.LayerByDigest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LayerByDigestMock.expectedInvocations), m.LayerByDigestMock.expectedInvocationsOrigin, afterLayerByDigestCounter)
	}
}

type mRegistryImageMockLayers struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockLayersExpectation
	expectations       []*RegistryImageMockLayersExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockLayersExpectation specifies expectation struct of the RegistryImage.Layers
type RegistryImageMockLayersExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockLayersResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockLayersResults contains results of the RegistryImage.Layers
type RegistryImageMockLayersResults struct {
	la1 []v1.Layer
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLayers *mRegistryImageMockLayers) Optional() *mRegistryImageMockLayers {
	mmLayers.optional = true
	return mmLayers
}

// Expect sets up expected params for RegistryImage.Layers
func (mmLayers *mRegistryImageMockLayers) Expect() *mRegistryImageMockLayers {
	if mmLayers.mock.funcLayers != nil {
		mmLayers.mock.t.Fatalf("RegistryImageMock.Layers mock is already set by Set")
	}

	if mmLayers.defaultExpectation == nil {
		mmLayers.defaultExpectation = &RegistryImageMockLayersExpectation{}
	}

	return mmLayers
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.Layers
func (mmLayers *mRegistryImageMockLayers) Inspect(f func()) *mRegistryImageMockLayers {
	if mmLayers.mock.inspectFuncLayers != nil {
		mmLayers.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.Layers")
	}

	mmLayers.mock.inspectFuncLayers = f

	return mmLayers
}

// Return sets up results that will be returned by RegistryImage.Layers
func (mmLayers *mRegistryImageMockLayers) Return(la1 []v1.Layer, err error) *RegistryImageMock {
	if mmLayers.mock.funcLayers != nil {
		mmLayers.mock.t.Fatalf("RegistryImageMock.Layers mock is already set by Set")
	}

	if mmLayers.defaultExpectation == nil {
		mmLayers.defaultExpectation = &RegistryImageMockLayersExpectation{mock: mmLayers.mock}
	}
	mmLayers.defaultExpectation.results = &RegistryImageMockLayersResults{la1, err}
	mmLayers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLayers.mock
}

// Set uses given function f to mock the RegistryImage.Layers method
func (mmLayers *mRegistryImageMockLayers) Set(f func() (la1 []v1.Layer, err error)) *RegistryImageMock {
	if mmLayers.defaultExpectation != nil {
		mmLayers.mock.t.Fatalf("Default expectation is already set for the RegistryImage.Layers method")
	}

	if len(mmLayers.expectations) > 0 {
		mmLayers.mock.t.Fatalf("Some expectations are already set for the RegistryImage.Layers method")
	}

	mmLayers.mock.funcLayers = f
	mmLayers.mock.funcLayersOrigin = minimock.CallerInfo(1)
	return mmLayers.mock
}

// Times sets number of times RegistryImage.Layers should be invoked
func (mmLayers *mRegistryImageMockLayers) Times(n uint64) *mRegistryImageMockLayers {
	if n == 0 {
		mmLayers.mock.t.Fatalf("Times of RegistryImageMock.Layers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLayers.expectedInvocations, n)
	mmLayers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLayers
}

func (mmLayers *mRegistryImageMockLayers) invocationsDone() bool {
	if len(mmLayers.expectations) == 0 && mmLayers.defaultExpectation == nil && mmLayers.mock.funcLayers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLayers.mock.afterLayersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLayers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Layers implements mm_pkg.RegistryImage
func (mmLayers *RegistryImageMock) Layers() (la1 []v1.Layer, err error) {
	mm_atomic.AddUint64(&mmLayers.beforeLayersCounter, 1)
	defer mm_atomic.AddUint64(&mmLayers.afterLayersCounter, 1)

	mmLayers.t.Helper()

	if mmLayers.inspectFuncLayers != nil {
		mmLayers.inspectFuncLayers()
	}

	if mmLayers.LayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLayers.LayersMock.defaultExpectation.Counter, 1)

		mm_results := mmLayers.LayersMock.defaultExpectation.results
		if mm_results == nil {
			mmLayers.t.Fatal("No results are set for the RegistryImageMock.Layers")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmLayers.funcLayers != nil {
		return mmLayers.funcLayers()
	}
	mmLayers.t.Fatalf("Unexpected call to RegistryImageMock.Layers.")
	return
}

// LayersAfterCounter returns a count of finished RegistryImageMock.Layers invocations
func (mmLayers *RegistryImageMock) LayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayers.afterLayersCounter)
}

// LayersBeforeCounter returns a count of RegistryImageMock.Layers invocations
func (mmLayers *RegistryImageMock) LayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLayers.beforeLayersCounter)
}

// MinimockLayersDone returns true if the count of the Layers invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockLayersDone() bool {
	if m.LayersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LayersMock.invocationsDone()
}

// MinimockLayersInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockLayersInspect() {
	for _, e := range m.LayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.Layers")
		}
	}

	afterLayersCounter := mm_atomic.LoadUint64(&m.afterLayersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LayersMock.defaultExpectation != nil && afterLayersCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Layers at\n%s", m.LayersMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLayers != nil && afterLayersCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Layers at\n%s", m.funcLayersOrigin)
	}

	if !m.LayersMock.invocationsDone() && afterLayersCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.Layers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LayersMock.expectedInvocations), m.LayersMock.expectedInvocationsOrigin, afterLayersCounter)
	}
}

type mRegistryImageMockManifest struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockManifestExpectation
	expectations       []*RegistryImageMockManifestExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockManifestExpectation specifies expectation struct of the RegistryImage.Manifest
type RegistryImageMockManifestExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockManifestResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockManifestResults contains results of the RegistryImage.Manifest
type RegistryImageMockManifestResults struct {
	mp1 *v1.Manifest
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmManifest *mRegistryImageMockManifest) Optional() *mRegistryImageMockManifest {
	mmManifest.optional = true
	return mmManifest
}

// Expect sets up expected params for RegistryImage.Manifest
func (mmManifest *mRegistryImageMockManifest) Expect() *mRegistryImageMockManifest {
	if mmManifest.mock.funcManifest != nil {
		mmManifest.mock.t.Fatalf("RegistryImageMock.Manifest mock is already set by Set")
	}

	if mmManifest.defaultExpectation == nil {
		mmManifest.defaultExpectation = &RegistryImageMockManifestExpectation{}
	}

	return mmManifest
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.Manifest
func (mmManifest *mRegistryImageMockManifest) Inspect(f func()) *mRegistryImageMockManifest {
	if mmManifest.mock.inspectFuncManifest != nil {
		mmManifest.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.Manifest")
	}

	mmManifest.mock.inspectFuncManifest = f

	return mmManifest
}

// Return sets up results that will be returned by RegistryImage.Manifest
func (mmManifest *mRegistryImageMockManifest) Return(mp1 *v1.Manifest, err error) *RegistryImageMock {
	if mmManifest.mock.funcManifest != nil {
		mmManifest.mock.t.Fatalf("RegistryImageMock.Manifest mock is already set by Set")
	}

	if mmManifest.defaultExpectation == nil {
		mmManifest.defaultExpectation = &RegistryImageMockManifestExpectation{mock: mmManifest.mock}
	}
	mmManifest.defaultExpectation.results = &RegistryImageMockManifestResults{mp1, err}
	mmManifest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmManifest.mock
}

// Set uses given function f to mock the RegistryImage.Manifest method
func (mmManifest *mRegistryImageMockManifest) Set(f func() (mp1 *v1.Manifest, err error)) *RegistryImageMock {
	if mmManifest.defaultExpectation != nil {
		mmManifest.mock.t.Fatalf("Default expectation is already set for the RegistryImage.Manifest method")
	}

	if len(mmManifest.expectations) > 0 {
		mmManifest.mock.t.Fatalf("Some expectations are already set for the RegistryImage.Manifest method")
	}

	mmManifest.mock.funcManifest = f
	mmManifest.mock.funcManifestOrigin = minimock.CallerInfo(1)
	return mmManifest.mock
}

// Times sets number of times RegistryImage.Manifest should be invoked
func (mmManifest *mRegistryImageMockManifest) Times(n uint64) *mRegistryImageMockManifest {
	if n == 0 {
		mmManifest.mock.t.Fatalf("Times of RegistryImageMock.Manifest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmManifest.expectedInvocations, n)
	mmManifest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmManifest
}

func (mmManifest *mRegistryImageMockManifest) invocationsDone() bool {
	if len(mmManifest.expectations) == 0 && mmManifest.defaultExpectation == nil && mmManifest.mock.funcManifest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmManifest.mock.afterManifestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmManifest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Manifest implements mm_pkg.RegistryImage
func (mmManifest *RegistryImageMock) Manifest() (mp1 *v1.Manifest, err error) {
	mm_atomic.AddUint64(&mmManifest.beforeManifestCounter, 1)
	defer mm_atomic.AddUint64(&mmManifest.afterManifestCounter, 1)

	mmManifest.t.Helper()

	if mmManifest.inspectFuncManifest != nil {
		mmManifest.inspectFuncManifest()
	}

	if mmManifest.ManifestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmManifest.ManifestMock.defaultExpectation.Counter, 1)

		mm_results := mmManifest.ManifestMock.defaultExpectation.results
		if mm_results == nil {
			mmManifest.t.Fatal("No results are set for the RegistryImageMock.Manifest")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmManifest.funcManifest != nil {
		return mmManifest.funcManifest()
	}
	mmManifest.t.Fatalf("Unexpected call to RegistryImageMock.Manifest.")
	return
}

// ManifestAfterCounter returns a count of finished RegistryImageMock.Manifest invocations
func (mmManifest *RegistryImageMock) ManifestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmManifest.afterManifestCounter)
}

// ManifestBeforeCounter returns a count of RegistryImageMock.Manifest invocations
func (mmManifest *RegistryImageMock) ManifestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmManifest.beforeManifestCounter)
}

// MinimockManifestDone returns true if the count of the Manifest invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockManifestDone() bool {
	if m.ManifestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ManifestMock.invocationsDone()
}

// MinimockManifestInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockManifestInspect() {
	for _, e := range m.ManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.Manifest")
		}
	}

	afterManifestCounter := mm_atomic.LoadUint64(&m.afterManifestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ManifestMock.defaultExpectation != nil && afterManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Manifest at\n%s", m.ManifestMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcManifest != nil && afterManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Manifest at\n%s", m.funcManifestOrigin)
	}

	if !m.ManifestMock.invocationsDone() && afterManifestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.Manifest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ManifestMock.expectedInvocations), m.ManifestMock.expectedInvocationsOrigin, afterManifestCounter)
	}
}

type mRegistryImageMockMediaType struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockMediaTypeExpectation
	expectations       []*RegistryImageMockMediaTypeExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockMediaTypeExpectation specifies expectation struct of the RegistryImage.MediaType
type RegistryImageMockMediaTypeExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockMediaTypeResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockMediaTypeResults contains results of the RegistryImage.MediaType
type RegistryImageMockMediaTypeResults struct {
	m1  types.MediaType
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMediaType *mRegistryImageMockMediaType) Optional() *mRegistryImageMockMediaType {
	mmMediaType.optional = true
	return mmMediaType
}

// Expect sets up expected params for RegistryImage.MediaType
func (mmMediaType *mRegistryImageMockMediaType) Expect() *mRegistryImageMockMediaType {
	if mmMediaType.mock.funcMediaType != nil {
		mmMediaType.mock.t.Fatalf("RegistryImageMock.MediaType mock is already set by Set")
	}

	if mmMediaType.defaultExpectation == nil {
		mmMediaType.defaultExpectation = &RegistryImageMockMediaTypeExpectation{}
	}

	return mmMediaType
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.MediaType
func (mmMediaType *mRegistryImageMockMediaType) Inspect(f func()) *mRegistryImageMockMediaType {
	if mmMediaType.mock.inspectFuncMediaType != nil {
		mmMediaType.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.MediaType")
	}

	mmMediaType.mock.inspectFuncMediaType = f

	return mmMediaType
}

// Return sets up results that will be returned by RegistryImage.MediaType
func (mmMediaType *mRegistryImageMockMediaType) Return(m1 types.MediaType, err error) *RegistryImageMock {
	if mmMediaType.mock.funcMediaType != nil {
		mmMediaType.mock.t.Fatalf("RegistryImageMock.MediaType mock is already set by Set")
	}

	if mmMediaType.defaultExpectation == nil {
		mmMediaType.defaultExpectation = &RegistryImageMockMediaTypeExpectation{mock: mmMediaType.mock}
	}
	mmMediaType.defaultExpectation.results = &RegistryImageMockMediaTypeResults{m1, err}
	mmMediaType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMediaType.mock
}

// Set uses given function f to mock the RegistryImage.MediaType method
func (mmMediaType *mRegistryImageMockMediaType) Set(f func() (m1 types.MediaType, err error)) *RegistryImageMock {
	if mmMediaType.defaultExpectation != nil {
		mmMediaType.mock.t.Fatalf("Default expectation is already set for the RegistryImage.MediaType method")
	}

	if len(mmMediaType.expectations) > 0 {
		mmMediaType.mock.t.Fatalf("Some expectations are already set for the RegistryImage.MediaType method")
	}

	mmMediaType.mock.funcMediaType = f
	mmMediaType.mock.funcMediaTypeOrigin = minimock.CallerInfo(1)
	return mmMediaType.mock
}

// Times sets number of times RegistryImage.MediaType should be invoked
func (mmMediaType *mRegistryImageMockMediaType) Times(n uint64) *mRegistryImageMockMediaType {
	if n == 0 {
		mmMediaType.mock.t.Fatalf("Times of RegistryImageMock.MediaType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMediaType.expectedInvocations, n)
	mmMediaType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMediaType
}

func (mmMediaType *mRegistryImageMockMediaType) invocationsDone() bool {
	if len(mmMediaType.expectations) == 0 && mmMediaType.defaultExpectation == nil && mmMediaType.mock.funcMediaType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMediaType.mock.afterMediaTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMediaType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MediaType implements mm_pkg.RegistryImage
func (mmMediaType *RegistryImageMock) MediaType() (m1 types.MediaType, err error) {
	mm_atomic.AddUint64(&mmMediaType.beforeMediaTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmMediaType.afterMediaTypeCounter, 1)

	mmMediaType.t.Helper()

	if mmMediaType.inspectFuncMediaType != nil {
		mmMediaType.inspectFuncMediaType()
	}

	if mmMediaType.MediaTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMediaType.MediaTypeMock.defaultExpectation.Counter, 1)

		mm_results := mmMediaType.MediaTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmMediaType.t.Fatal("No results are set for the RegistryImageMock.MediaType")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmMediaType.funcMediaType != nil {
		return mmMediaType.funcMediaType()
	}
	mmMediaType.t.Fatalf("Unexpected call to RegistryImageMock.MediaType.")
	return
}

// MediaTypeAfterCounter returns a count of finished RegistryImageMock.MediaType invocations
func (mmMediaType *RegistryImageMock) MediaTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMediaType.afterMediaTypeCounter)
}

// MediaTypeBeforeCounter returns a count of RegistryImageMock.MediaType invocations
func (mmMediaType *RegistryImageMock) MediaTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMediaType.beforeMediaTypeCounter)
}

// MinimockMediaTypeDone returns true if the count of the MediaType invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockMediaTypeDone() bool {
	if m.MediaTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MediaTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MediaTypeMock.invocationsDone()
}

// MinimockMediaTypeInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockMediaTypeInspect() {
	for _, e := range m.MediaTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.MediaType")
		}
	}

	afterMediaTypeCounter := mm_atomic.LoadUint64(&m.afterMediaTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MediaTypeMock.defaultExpectation != nil && afterMediaTypeCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.MediaType at\n%s", m.MediaTypeMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMediaType != nil && afterMediaTypeCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.MediaType at\n%s", m.funcMediaTypeOrigin)
	}

	if !m.MediaTypeMock.invocationsDone() && afterMediaTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.MediaType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MediaTypeMock.expectedInvocations), m.MediaTypeMock.expectedInvocationsOrigin, afterMediaTypeCounter)
	}
}

type mRegistryImageMockRawConfigFile struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockRawConfigFileExpectation
	expectations       []*RegistryImageMockRawConfigFileExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockRawConfigFileExpectation specifies expectation struct of the RegistryImage.RawConfigFile
type RegistryImageMockRawConfigFileExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockRawConfigFileResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockRawConfigFileResults contains results of the RegistryImage.RawConfigFile
type RegistryImageMockRawConfigFileResults struct {
	ba1 []byte
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRawConfigFile *mRegistryImageMockRawConfigFile) Optional() *mRegistryImageMockRawConfigFile {
	mmRawConfigFile.optional = true
	return mmRawConfigFile
}

// Expect sets up expected params for RegistryImage.RawConfigFile
func (mmRawConfigFile *mRegistryImageMockRawConfigFile) Expect() *mRegistryImageMockRawConfigFile {
	if mmRawConfigFile.mock.funcRawConfigFile != nil {
		mmRawConfigFile.mock.t.Fatalf("RegistryImageMock.RawConfigFile mock is already set by Set")
	}

	if mmRawConfigFile.defaultExpectation == nil {
		mmRawConfigFile.defaultExpectation = &RegistryImageMockRawConfigFileExpectation{}
	}

	return mmRawConfigFile
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.RawConfigFile
func (mmRawConfigFile *mRegistryImageMockRawConfigFile) Inspect(f func()) *mRegistryImageMockRawConfigFile {
	if mmRawConfigFile.mock.inspectFuncRawConfigFile != nil {
		mmRawConfigFile.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.RawConfigFile")
	}

	mmRawConfigFile.mock.inspectFuncRawConfigFile = f

	return mmRawConfigFile
}

// Return sets up results that will be returned by RegistryImage.RawConfigFile
func (mmRawConfigFile *mRegistryImageMockRawConfigFile) Return(ba1 []byte, err error) *RegistryImageMock {
	if mmRawConfigFile.mock.funcRawConfigFile != nil {
		mmRawConfigFile.mock.t.Fatalf("RegistryImageMock.RawConfigFile mock is already set by Set")
	}

	if mmRawConfigFile.defaultExpectation == nil {
		mmRawConfigFile.defaultExpectation = &RegistryImageMockRawConfigFileExpectation{mock: mmRawConfigFile.mock}
	}
	mmRawConfigFile.defaultExpectation.results = &RegistryImageMockRawConfigFileResults{ba1, err}
	mmRawConfigFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRawConfigFile.mock
}

// Set uses given function f to mock the RegistryImage.RawConfigFile method
func (mmRawConfigFile *mRegistryImageMockRawConfigFile) Set(f func() (ba1 []byte, err error)) *RegistryImageMock {
	if mmRawConfigFile.defaultExpectation != nil {
		mmRawConfigFile.mock.t.Fatalf("Default expectation is already set for the RegistryImage.RawConfigFile method")
	}

	if len(mmRawConfigFile.expectations) > 0 {
		mmRawConfigFile.mock.t.Fatalf("Some expectations are already set for the RegistryImage.RawConfigFile method")
	}

	mmRawConfigFile.mock.funcRawConfigFile = f
	mmRawConfigFile.mock.funcRawConfigFileOrigin = minimock.CallerInfo(1)
	return mmRawConfigFile.mock
}

// Times sets number of times RegistryImage.RawConfigFile should be invoked
func (mmRawConfigFile *mRegistryImageMockRawConfigFile) Times(n uint64) *mRegistryImageMockRawConfigFile {
	if n == 0 {
		mmRawConfigFile.mock.t.Fatalf("Times of RegistryImageMock.RawConfigFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRawConfigFile.expectedInvocations, n)
	mmRawConfigFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRawConfigFile
}

func (mmRawConfigFile *mRegistryImageMockRawConfigFile) invocationsDone() bool {
	if len(mmRawConfigFile.expectations) == 0 && mmRawConfigFile.defaultExpectation == nil && mmRawConfigFile.mock.funcRawConfigFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRawConfigFile.mock.afterRawConfigFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRawConfigFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RawConfigFile implements mm_pkg.RegistryImage
func (mmRawConfigFile *RegistryImageMock) RawConfigFile() (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmRawConfigFile.beforeRawConfigFileCounter, 1)
	defer mm_atomic.AddUint64(&mmRawConfigFile.afterRawConfigFileCounter, 1)

	mmRawConfigFile.t.Helper()

	if mmRawConfigFile.inspectFuncRawConfigFile != nil {
		mmRawConfigFile.inspectFuncRawConfigFile()
	}

	if mmRawConfigFile.RawConfigFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRawConfigFile.RawConfigFileMock.defaultExpectation.Counter, 1)

		mm_results := mmRawConfigFile.RawConfigFileMock.defaultExpectation.results
		if mm_results == nil {
			mmRawConfigFile.t.Fatal("No results are set for the RegistryImageMock.RawConfigFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmRawConfigFile.funcRawConfigFile != nil {
		return mmRawConfigFile.funcRawConfigFile()
	}
	mmRawConfigFile.t.Fatalf("Unexpected call to RegistryImageMock.RawConfigFile.")
	return
}

// RawConfigFileAfterCounter returns a count of finished RegistryImageMock.RawConfigFile invocations
func (mmRawConfigFile *RegistryImageMock) RawConfigFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRawConfigFile.afterRawConfigFileCounter)
}

// RawConfigFileBeforeCounter returns a count of RegistryImageMock.RawConfigFile invocations
func (mmRawConfigFile *RegistryImageMock) RawConfigFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRawConfigFile.beforeRawConfigFileCounter)
}

// MinimockRawConfigFileDone returns true if the count of the RawConfigFile invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockRawConfigFileDone() bool {
	if m.RawConfigFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RawConfigFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RawConfigFileMock.invocationsDone()
}

// MinimockRawConfigFileInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockRawConfigFileInspect() {
	for _, e := range m.RawConfigFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.RawConfigFile")
		}
	}

	afterRawConfigFileCounter := mm_atomic.LoadUint64(&m.afterRawConfigFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RawConfigFileMock.defaultExpectation != nil && afterRawConfigFileCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.RawConfigFile at\n%s", m.RawConfigFileMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRawConfigFile != nil && afterRawConfigFileCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.RawConfigFile at\n%s", m.funcRawConfigFileOrigin)
	}

	if !m.RawConfigFileMock.invocationsDone() && afterRawConfigFileCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.RawConfigFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RawConfigFileMock.expectedInvocations), m.RawConfigFileMock.expectedInvocationsOrigin, afterRawConfigFileCounter)
	}
}

type mRegistryImageMockRawManifest struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockRawManifestExpectation
	expectations       []*RegistryImageMockRawManifestExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockRawManifestExpectation specifies expectation struct of the RegistryImage.RawManifest
type RegistryImageMockRawManifestExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockRawManifestResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockRawManifestResults contains results of the RegistryImage.RawManifest
type RegistryImageMockRawManifestResults struct {
	ba1 []byte
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRawManifest *mRegistryImageMockRawManifest) Optional() *mRegistryImageMockRawManifest {
	mmRawManifest.optional = true
	return mmRawManifest
}

// Expect sets up expected params for RegistryImage.RawManifest
func (mmRawManifest *mRegistryImageMockRawManifest) Expect() *mRegistryImageMockRawManifest {
	if mmRawManifest.mock.funcRawManifest != nil {
		mmRawManifest.mock.t.Fatalf("RegistryImageMock.RawManifest mock is already set by Set")
	}

	if mmRawManifest.defaultExpectation == nil {
		mmRawManifest.defaultExpectation = &RegistryImageMockRawManifestExpectation{}
	}

	return mmRawManifest
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.RawManifest
func (mmRawManifest *mRegistryImageMockRawManifest) Inspect(f func()) *mRegistryImageMockRawManifest {
	if mmRawManifest.mock.inspectFuncRawManifest != nil {
		mmRawManifest.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.RawManifest")
	}

	mmRawManifest.mock.inspectFuncRawManifest = f

	return mmRawManifest
}

// Return sets up results that will be returned by RegistryImage.RawManifest
func (mmRawManifest *mRegistryImageMockRawManifest) Return(ba1 []byte, err error) *RegistryImageMock {
	if mmRawManifest.mock.funcRawManifest != nil {
		mmRawManifest.mock.t.Fatalf("RegistryImageMock.RawManifest mock is already set by Set")
	}

	if mmRawManifest.defaultExpectation == nil {
		mmRawManifest.defaultExpectation = &RegistryImageMockRawManifestExpectation{mock: mmRawManifest.mock}
	}
	mmRawManifest.defaultExpectation.results = &RegistryImageMockRawManifestResults{ba1, err}
	mmRawManifest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRawManifest.mock
}

// Set uses given function f to mock the RegistryImage.RawManifest method
func (mmRawManifest *mRegistryImageMockRawManifest) Set(f func() (ba1 []byte, err error)) *RegistryImageMock {
	if mmRawManifest.defaultExpectation != nil {
		mmRawManifest.mock.t.Fatalf("Default expectation is already set for the RegistryImage.RawManifest method")
	}

	if len(mmRawManifest.expectations) > 0 {
		mmRawManifest.mock.t.Fatalf("Some expectations are already set for the RegistryImage.RawManifest method")
	}

	mmRawManifest.mock.funcRawManifest = f
	mmRawManifest.mock.funcRawManifestOrigin = minimock.CallerInfo(1)
	return mmRawManifest.mock
}

// Times sets number of times RegistryImage.RawManifest should be invoked
func (mmRawManifest *mRegistryImageMockRawManifest) Times(n uint64) *mRegistryImageMockRawManifest {
	if n == 0 {
		mmRawManifest.mock.t.Fatalf("Times of RegistryImageMock.RawManifest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRawManifest.expectedInvocations, n)
	mmRawManifest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRawManifest
}

func (mmRawManifest *mRegistryImageMockRawManifest) invocationsDone() bool {
	if len(mmRawManifest.expectations) == 0 && mmRawManifest.defaultExpectation == nil && mmRawManifest.mock.funcRawManifest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRawManifest.mock.afterRawManifestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRawManifest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RawManifest implements mm_pkg.RegistryImage
func (mmRawManifest *RegistryImageMock) RawManifest() (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmRawManifest.beforeRawManifestCounter, 1)
	defer mm_atomic.AddUint64(&mmRawManifest.afterRawManifestCounter, 1)

	mmRawManifest.t.Helper()

	if mmRawManifest.inspectFuncRawManifest != nil {
		mmRawManifest.inspectFuncRawManifest()
	}

	if mmRawManifest.RawManifestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRawManifest.RawManifestMock.defaultExpectation.Counter, 1)

		mm_results := mmRawManifest.RawManifestMock.defaultExpectation.results
		if mm_results == nil {
			mmRawManifest.t.Fatal("No results are set for the RegistryImageMock.RawManifest")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmRawManifest.funcRawManifest != nil {
		return mmRawManifest.funcRawManifest()
	}
	mmRawManifest.t.Fatalf("Unexpected call to RegistryImageMock.RawManifest.")
	return
}

// RawManifestAfterCounter returns a count of finished RegistryImageMock.RawManifest invocations
func (mmRawManifest *RegistryImageMock) RawManifestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRawManifest.afterRawManifestCounter)
}

// RawManifestBeforeCounter returns a count of RegistryImageMock.RawManifest invocations
func (mmRawManifest *RegistryImageMock) RawManifestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRawManifest.beforeRawManifestCounter)
}

// MinimockRawManifestDone returns true if the count of the RawManifest invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockRawManifestDone() bool {
	if m.RawManifestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RawManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RawManifestMock.invocationsDone()
}

// MinimockRawManifestInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockRawManifestInspect() {
	for _, e := range m.RawManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.RawManifest")
		}
	}

	afterRawManifestCounter := mm_atomic.LoadUint64(&m.afterRawManifestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RawManifestMock.defaultExpectation != nil && afterRawManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.RawManifest at\n%s", m.RawManifestMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRawManifest != nil && afterRawManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.RawManifest at\n%s", m.funcRawManifestOrigin)
	}

	if !m.RawManifestMock.invocationsDone() && afterRawManifestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.RawManifest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RawManifestMock.expectedInvocations), m.RawManifestMock.expectedInvocationsOrigin, afterRawManifestCounter)
	}
}

type mRegistryImageMockSetMetadata struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockSetMetadataExpectation
	expectations       []*RegistryImageMockSetMetadataExpectation

	callArgs []*RegistryImageMockSetMetadataParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockSetMetadataExpectation specifies expectation struct of the RegistryImage.SetMetadata
type RegistryImageMockSetMetadataExpectation struct {
	mock               *RegistryImageMock
	params             *RegistryImageMockSetMetadataParams
	paramPtrs          *RegistryImageMockSetMetadataParamPtrs
	expectationOrigins RegistryImageMockSetMetadataExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// RegistryImageMockSetMetadataParams contains parameters of the RegistryImage.SetMetadata
type RegistryImageMockSetMetadataParams struct {
	metadata mm_pkg.ImageMeta
}

// RegistryImageMockSetMetadataParamPtrs contains pointers to parameters of the RegistryImage.SetMetadata
type RegistryImageMockSetMetadataParamPtrs struct {
	metadata *mm_pkg.ImageMeta
}

// RegistryImageMockSetMetadataOrigins contains origins of expectations of the RegistryImage.SetMetadata
type RegistryImageMockSetMetadataExpectationOrigins struct {
	origin         string
	originMetadata string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetMetadata *mRegistryImageMockSetMetadata) Optional() *mRegistryImageMockSetMetadata {
	mmSetMetadata.optional = true
	return mmSetMetadata
}

// Expect sets up expected params for RegistryImage.SetMetadata
func (mmSetMetadata *mRegistryImageMockSetMetadata) Expect(metadata mm_pkg.ImageMeta) *mRegistryImageMockSetMetadata {
	if mmSetMetadata.mock.funcSetMetadata != nil {
		mmSetMetadata.mock.t.Fatalf("RegistryImageMock.SetMetadata mock is already set by Set")
	}

	if mmSetMetadata.defaultExpectation == nil {
		mmSetMetadata.defaultExpectation = &RegistryImageMockSetMetadataExpectation{}
	}

	if mmSetMetadata.defaultExpectation.paramPtrs != nil {
		mmSetMetadata.mock.t.Fatalf("RegistryImageMock.SetMetadata mock is already set by ExpectParams functions")
	}

	mmSetMetadata.defaultExpectation.params = &RegistryImageMockSetMetadataParams{metadata}
	mmSetMetadata.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetMetadata.expectations {
		if minimock.Equal(e.params, mmSetMetadata.defaultExpectation.params) {
			mmSetMetadata.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetMetadata.defaultExpectation.params)
		}
	}

	return mmSetMetadata
}

// ExpectMetadataParam1 sets up expected param metadata for RegistryImage.SetMetadata
func (mmSetMetadata *mRegistryImageMockSetMetadata) ExpectMetadataParam1(metadata mm_pkg.ImageMeta) *mRegistryImageMockSetMetadata {
	if mmSetMetadata.mock.funcSetMetadata != nil {
		mmSetMetadata.mock.t.Fatalf("RegistryImageMock.SetMetadata mock is already set by Set")
	}

	if mmSetMetadata.defaultExpectation == nil {
		mmSetMetadata.defaultExpectation = &RegistryImageMockSetMetadataExpectation{}
	}

	if mmSetMetadata.defaultExpectation.params != nil {
		mmSetMetadata.mock.t.Fatalf("RegistryImageMock.SetMetadata mock is already set by Expect")
	}

	if mmSetMetadata.defaultExpectation.paramPtrs == nil {
		mmSetMetadata.defaultExpectation.paramPtrs = &RegistryImageMockSetMetadataParamPtrs{}
	}
	mmSetMetadata.defaultExpectation.paramPtrs.metadata = &metadata
	mmSetMetadata.defaultExpectation.expectationOrigins.originMetadata = minimock.CallerInfo(1)

	return mmSetMetadata
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.SetMetadata
func (mmSetMetadata *mRegistryImageMockSetMetadata) Inspect(f func(metadata mm_pkg.ImageMeta)) *mRegistryImageMockSetMetadata {
	if mmSetMetadata.mock.inspectFuncSetMetadata != nil {
		mmSetMetadata.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.SetMetadata")
	}

	mmSetMetadata.mock.inspectFuncSetMetadata = f

	return mmSetMetadata
}

// Return sets up results that will be returned by RegistryImage.SetMetadata
func (mmSetMetadata *mRegistryImageMockSetMetadata) Return() *RegistryImageMock {
	if mmSetMetadata.mock.funcSetMetadata != nil {
		mmSetMetadata.mock.t.Fatalf("RegistryImageMock.SetMetadata mock is already set by Set")
	}

	if mmSetMetadata.defaultExpectation == nil {
		mmSetMetadata.defaultExpectation = &RegistryImageMockSetMetadataExpectation{mock: mmSetMetadata.mock}
	}

	mmSetMetadata.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetMetadata.mock
}

// Set uses given function f to mock the RegistryImage.SetMetadata method
func (mmSetMetadata *mRegistryImageMockSetMetadata) Set(f func(metadata mm_pkg.ImageMeta)) *RegistryImageMock {
	if mmSetMetadata.defaultExpectation != nil {
		mmSetMetadata.mock.t.Fatalf("Default expectation is already set for the RegistryImage.SetMetadata method")
	}

	if len(mmSetMetadata.expectations) > 0 {
		mmSetMetadata.mock.t.Fatalf("Some expectations are already set for the RegistryImage.SetMetadata method")
	}

	mmSetMetadata.mock.funcSetMetadata = f
	mmSetMetadata.mock.funcSetMetadataOrigin = minimock.CallerInfo(1)
	return mmSetMetadata.mock
}

// When sets expectation for the RegistryImage.SetMetadata which will trigger the result defined by the following
// Then helper
func (mmSetMetadata *mRegistryImageMockSetMetadata) When(metadata mm_pkg.ImageMeta) *RegistryImageMockSetMetadataExpectation {
	if mmSetMetadata.mock.funcSetMetadata != nil {
		mmSetMetadata.mock.t.Fatalf("RegistryImageMock.SetMetadata mock is already set by Set")
	}

	expectation := &RegistryImageMockSetMetadataExpectation{
		mock:               mmSetMetadata.mock,
		params:             &RegistryImageMockSetMetadataParams{metadata},
		expectationOrigins: RegistryImageMockSetMetadataExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetMetadata.expectations = append(mmSetMetadata.expectations, expectation)
	return expectation
}

// Then sets up RegistryImage.SetMetadata return parameters for the expectation previously defined by the When method

func (e *RegistryImageMockSetMetadataExpectation) Then() *RegistryImageMock {
	return e.mock
}

// Times sets number of times RegistryImage.SetMetadata should be invoked
func (mmSetMetadata *mRegistryImageMockSetMetadata) Times(n uint64) *mRegistryImageMockSetMetadata {
	if n == 0 {
		mmSetMetadata.mock.t.Fatalf("Times of RegistryImageMock.SetMetadata mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetMetadata.expectedInvocations, n)
	mmSetMetadata.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetMetadata
}

func (mmSetMetadata *mRegistryImageMockSetMetadata) invocationsDone() bool {
	if len(mmSetMetadata.expectations) == 0 && mmSetMetadata.defaultExpectation == nil && mmSetMetadata.mock.funcSetMetadata == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetMetadata.mock.afterSetMetadataCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetMetadata.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetMetadata implements mm_pkg.RegistryImage
func (mmSetMetadata *RegistryImageMock) SetMetadata(metadata mm_pkg.ImageMeta) {
	mm_atomic.AddUint64(&mmSetMetadata.beforeSetMetadataCounter, 1)
	defer mm_atomic.AddUint64(&mmSetMetadata.afterSetMetadataCounter, 1)

	mmSetMetadata.t.Helper()

	if mmSetMetadata.inspectFuncSetMetadata != nil {
		mmSetMetadata.inspectFuncSetMetadata(metadata)
	}

	mm_params := RegistryImageMockSetMetadataParams{metadata}

	// Record call args
	mmSetMetadata.SetMetadataMock.mutex.Lock()
	mmSetMetadata.SetMetadataMock.callArgs = append(mmSetMetadata.SetMetadataMock.callArgs, &mm_params)
	mmSetMetadata.SetMetadataMock.mutex.Unlock()

	for _, e := range mmSetMetadata.SetMetadataMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetMetadata.SetMetadataMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetMetadata.SetMetadataMock.defaultExpectation.Counter, 1)
		mm_want := mmSetMetadata.SetMetadataMock.defaultExpectation.params
		mm_want_ptrs := mmSetMetadata.SetMetadataMock.defaultExpectation.paramPtrs

		mm_got := RegistryImageMockSetMetadataParams{metadata}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metadata != nil && !minimock.Equal(*mm_want_ptrs.metadata, mm_got.metadata) {
				mmSetMetadata.t.Errorf("RegistryImageMock.SetMetadata got unexpected parameter metadata, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetMetadata.SetMetadataMock.defaultExpectation.expectationOrigins.originMetadata, *mm_want_ptrs.metadata, mm_got.metadata, minimock.Diff(*mm_want_ptrs.metadata, mm_got.metadata))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetMetadata.t.Errorf("RegistryImageMock.SetMetadata got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetMetadata.SetMetadataMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetMetadata.funcSetMetadata != nil {
		mmSetMetadata.funcSetMetadata(metadata)
		return
	}
	mmSetMetadata.t.Fatalf("Unexpected call to RegistryImageMock.SetMetadata. %v", metadata)

}

// SetMetadataAfterCounter returns a count of finished RegistryImageMock.SetMetadata invocations
func (mmSetMetadata *RegistryImageMock) SetMetadataAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMetadata.afterSetMetadataCounter)
}

// SetMetadataBeforeCounter returns a count of RegistryImageMock.SetMetadata invocations
func (mmSetMetadata *RegistryImageMock) SetMetadataBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetMetadata.beforeSetMetadataCounter)
}

// Calls returns a list of arguments used in each call to RegistryImageMock.SetMetadata.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetMetadata *mRegistryImageMockSetMetadata) Calls() []*RegistryImageMockSetMetadataParams {
	mmSetMetadata.mutex.RLock()

	argCopy := make([]*RegistryImageMockSetMetadataParams, len(mmSetMetadata.callArgs))
	copy(argCopy, mmSetMetadata.callArgs)

	mmSetMetadata.mutex.RUnlock()

	return argCopy
}

// MinimockSetMetadataDone returns true if the count of the SetMetadata invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockSetMetadataDone() bool {
	if m.SetMetadataMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMetadataMock.invocationsDone()
}

// MinimockSetMetadataInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockSetMetadataInspect() {
	for _, e := range m.SetMetadataMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryImageMock.SetMetadata at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetMetadataCounter := mm_atomic.LoadUint64(&m.afterSetMetadataCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMetadataMock.defaultExpectation != nil && afterSetMetadataCounter < 1 {
		if m.SetMetadataMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryImageMock.SetMetadata at\n%s", m.SetMetadataMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryImageMock.SetMetadata at\n%s with params: %#v", m.SetMetadataMock.defaultExpectation.expectationOrigins.origin, *m.SetMetadataMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetMetadata != nil && afterSetMetadataCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.SetMetadata at\n%s", m.funcSetMetadataOrigin)
	}

	if !m.SetMetadataMock.invocationsDone() && afterSetMetadataCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.SetMetadata at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMetadataMock.expectedInvocations), m.SetMetadataMock.expectedInvocationsOrigin, afterSetMetadataCounter)
	}
}

type mRegistryImageMockSize struct {
	optional           bool
	mock               *RegistryImageMock
	defaultExpectation *RegistryImageMockSizeExpectation
	expectations       []*RegistryImageMockSizeExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryImageMockSizeExpectation specifies expectation struct of the RegistryImage.Size
type RegistryImageMockSizeExpectation struct {
	mock *RegistryImageMock

	results      *RegistryImageMockSizeResults
	returnOrigin string
	Counter      uint64
}

// RegistryImageMockSizeResults contains results of the RegistryImage.Size
type RegistryImageMockSizeResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSize *mRegistryImageMockSize) Optional() *mRegistryImageMockSize {
	mmSize.optional = true
	return mmSize
}

// Expect sets up expected params for RegistryImage.Size
func (mmSize *mRegistryImageMockSize) Expect() *mRegistryImageMockSize {
	if mmSize.mock.funcSize != nil {
		mmSize.mock.t.Fatalf("RegistryImageMock.Size mock is already set by Set")
	}

	if mmSize.defaultExpectation == nil {
		mmSize.defaultExpectation = &RegistryImageMockSizeExpectation{}
	}

	return mmSize
}

// Inspect accepts an inspector function that has same arguments as the RegistryImage.Size
func (mmSize *mRegistryImageMockSize) Inspect(f func()) *mRegistryImageMockSize {
	if mmSize.mock.inspectFuncSize != nil {
		mmSize.mock.t.Fatalf("Inspect function is already set for RegistryImageMock.Size")
	}

	mmSize.mock.inspectFuncSize = f

	return mmSize
}

// Return sets up results that will be returned by RegistryImage.Size
func (mmSize *mRegistryImageMockSize) Return(i1 int64, err error) *RegistryImageMock {
	if mmSize.mock.funcSize != nil {
		mmSize.mock.t.Fatalf("RegistryImageMock.Size mock is already set by Set")
	}

	if mmSize.defaultExpectation == nil {
		mmSize.defaultExpectation = &RegistryImageMockSizeExpectation{mock: mmSize.mock}
	}
	mmSize.defaultExpectation.results = &RegistryImageMockSizeResults{i1, err}
	mmSize.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSize.mock
}

// Set uses given function f to mock the RegistryImage.Size method
func (mmSize *mRegistryImageMockSize) Set(f func() (i1 int64, err error)) *RegistryImageMock {
	if mmSize.defaultExpectation != nil {
		mmSize.mock.t.Fatalf("Default expectation is already set for the RegistryImage.Size method")
	}

	if len(mmSize.expectations) > 0 {
		mmSize.mock.t.Fatalf("Some expectations are already set for the RegistryImage.Size method")
	}

	mmSize.mock.funcSize = f
	mmSize.mock.funcSizeOrigin = minimock.CallerInfo(1)
	return mmSize.mock
}

// Times sets number of times RegistryImage.Size should be invoked
func (mmSize *mRegistryImageMockSize) Times(n uint64) *mRegistryImageMockSize {
	if n == 0 {
		mmSize.mock.t.Fatalf("Times of RegistryImageMock.Size mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSize.expectedInvocations, n)
	mmSize.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSize
}

func (mmSize *mRegistryImageMockSize) invocationsDone() bool {
	if len(mmSize.expectations) == 0 && mmSize.defaultExpectation == nil && mmSize.mock.funcSize == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSize.mock.afterSizeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSize.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Size implements mm_pkg.RegistryImage
func (mmSize *RegistryImageMock) Size() (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSize.beforeSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmSize.afterSizeCounter, 1)

	mmSize.t.Helper()

	if mmSize.inspectFuncSize != nil {
		mmSize.inspectFuncSize()
	}

	if mmSize.SizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSize.SizeMock.defaultExpectation.Counter, 1)

		mm_results := mmSize.SizeMock.defaultExpectation.results
		if mm_results == nil {
			mmSize.t.Fatal("No results are set for the RegistryImageMock.Size")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSize.funcSize != nil {
		return mmSize.funcSize()
	}
	mmSize.t.Fatalf("Unexpected call to RegistryImageMock.Size.")
	return
}

// SizeAfterCounter returns a count of finished RegistryImageMock.Size invocations
func (mmSize *RegistryImageMock) SizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSize.afterSizeCounter)
}

// SizeBeforeCounter returns a count of RegistryImageMock.Size invocations
func (mmSize *RegistryImageMock) SizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSize.beforeSizeCounter)
}

// MinimockSizeDone returns true if the count of the Size invocations corresponds
// the number of defined expectations
func (m *RegistryImageMock) MinimockSizeDone() bool {
	if m.SizeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SizeMock.invocationsDone()
}

// MinimockSizeInspect logs each unmet expectation
func (m *RegistryImageMock) MinimockSizeInspect() {
	for _, e := range m.SizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryImageMock.Size")
		}
	}

	afterSizeCounter := mm_atomic.LoadUint64(&m.afterSizeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SizeMock.defaultExpectation != nil && afterSizeCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Size at\n%s", m.SizeMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSize != nil && afterSizeCounter < 1 {
		m.t.Errorf("Expected call to RegistryImageMock.Size at\n%s", m.funcSizeOrigin)
	}

	if !m.SizeMock.invocationsDone() && afterSizeCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryImageMock.Size at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SizeMock.expectedInvocations), m.SizeMock.expectedInvocationsOrigin, afterSizeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryImageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConfigFileInspect()

			m.MinimockConfigNameInspect()

			m.MinimockDigestInspect()

			m.MinimockExtractInspect()

			m.MinimockGetMetadataInspect()

			m.MinimockLayerByDiffIDInspect()

			m.MinimockLayerByDigestInspect()

			m.MinimockLayersInspect()

			m.MinimockManifestInspect()

			m.MinimockMediaTypeInspect()

			m.MinimockRawConfigFileInspect()

			m.MinimockRawManifestInspect()

			m.MinimockSetMetadataInspect()

			m.MinimockSizeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryImageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryImageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConfigFileDone() &&
		m.MinimockConfigNameDone() &&
		m.MinimockDigestDone() &&
		m.MinimockExtractDone() &&
		m.MinimockGetMetadataDone() &&
		m.MinimockLayerByDiffIDDone() &&
		m.MinimockLayerByDigestDone() &&
		m.MinimockLayersDone() &&
		m.MinimockManifestDone() &&
		m.MinimockMediaTypeDone() &&
		m.MinimockRawConfigFileDone() &&
		m.MinimockRawManifestDone() &&
		m.MinimockSetMetadataDone() &&
		m.MinimockSizeDone()
}
