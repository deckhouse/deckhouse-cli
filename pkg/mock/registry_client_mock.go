// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/deckhouse-cli/pkg.RegistryClient -o registry_client_mock.go -n RegistryClientMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/deckhouse-cli/pkg"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/remote"
)

// RegistryClientMock implements mm_pkg.RegistryClient
type RegistryClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExtractImageLayers          func(ctx context.Context, repository string, tag string, handler func(mm_pkg.LayerStream) error) (err error)
	funcExtractImageLayersOrigin    string
	inspectFuncExtractImageLayers   func(ctx context.Context, repository string, tag string, handler func(mm_pkg.LayerStream) error)
	afterExtractImageLayersCounter  uint64
	beforeExtractImageLayersCounter uint64
	ExtractImageLayersMock          mRegistryClientMockExtractImageLayers

	funcGetImage          func(ctx context.Context, repository string, tag string) (i1 v1.Image, err error)
	funcGetImageOrigin    string
	inspectFuncGetImage   func(ctx context.Context, repository string, tag string)
	afterGetImageCounter  uint64
	beforeGetImageCounter uint64
	GetImageMock          mRegistryClientMockGetImage

	funcGetImageConfig          func(ctx context.Context, repository string, tag string) (cp1 *v1.ConfigFile, err error)
	funcGetImageConfigOrigin    string
	inspectFuncGetImageConfig   func(ctx context.Context, repository string, tag string)
	afterGetImageConfigCounter  uint64
	beforeGetImageConfigCounter uint64
	GetImageConfigMock          mRegistryClientMockGetImageConfig

	funcGetImageLayers          func(ctx context.Context, repository string, tag string) (la1 []v1.Layer, err error)
	funcGetImageLayersOrigin    string
	inspectFuncGetImageLayers   func(ctx context.Context, repository string, tag string)
	afterGetImageLayersCounter  uint64
	beforeGetImageLayersCounter uint64
	GetImageLayersMock          mRegistryClientMockGetImageLayers

	funcGetLabel          func(ctx context.Context, repository string, tag string, labelKey string) (s1 string, b1 bool, err error)
	funcGetLabelOrigin    string
	inspectFuncGetLabel   func(ctx context.Context, repository string, tag string, labelKey string)
	afterGetLabelCounter  uint64
	beforeGetLabelCounter uint64
	GetLabelMock          mRegistryClientMockGetLabel

	funcGetManifest          func(ctx context.Context, repository string, tag string) (dp1 *remote.Descriptor, err error)
	funcGetManifestOrigin    string
	inspectFuncGetManifest   func(ctx context.Context, repository string, tag string)
	afterGetManifestCounter  uint64
	beforeGetManifestCounter uint64
	GetManifestMock          mRegistryClientMockGetManifest
}

// NewRegistryClientMock returns a mock for mm_pkg.RegistryClient
func NewRegistryClientMock(t minimock.Tester) *RegistryClientMock {
	m := &RegistryClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExtractImageLayersMock = mRegistryClientMockExtractImageLayers{mock: m}
	m.ExtractImageLayersMock.callArgs = []*RegistryClientMockExtractImageLayersParams{}

	m.GetImageMock = mRegistryClientMockGetImage{mock: m}
	m.GetImageMock.callArgs = []*RegistryClientMockGetImageParams{}

	m.GetImageConfigMock = mRegistryClientMockGetImageConfig{mock: m}
	m.GetImageConfigMock.callArgs = []*RegistryClientMockGetImageConfigParams{}

	m.GetImageLayersMock = mRegistryClientMockGetImageLayers{mock: m}
	m.GetImageLayersMock.callArgs = []*RegistryClientMockGetImageLayersParams{}

	m.GetLabelMock = mRegistryClientMockGetLabel{mock: m}
	m.GetLabelMock.callArgs = []*RegistryClientMockGetLabelParams{}

	m.GetManifestMock = mRegistryClientMockGetManifest{mock: m}
	m.GetManifestMock.callArgs = []*RegistryClientMockGetManifestParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryClientMockExtractImageLayers struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockExtractImageLayersExpectation
	expectations       []*RegistryClientMockExtractImageLayersExpectation

	callArgs []*RegistryClientMockExtractImageLayersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockExtractImageLayersExpectation specifies expectation struct of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockExtractImageLayersParams
	paramPtrs          *RegistryClientMockExtractImageLayersParamPtrs
	expectationOrigins RegistryClientMockExtractImageLayersExpectationOrigins
	results            *RegistryClientMockExtractImageLayersResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockExtractImageLayersParams contains parameters of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersParams struct {
	ctx        context.Context
	repository string
	tag        string
	handler    func(mm_pkg.LayerStream) error
}

// RegistryClientMockExtractImageLayersParamPtrs contains pointers to parameters of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
	handler    *func(mm_pkg.LayerStream) error
}

// RegistryClientMockExtractImageLayersResults contains results of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersResults struct {
	err error
}

// RegistryClientMockExtractImageLayersOrigins contains origins of expectations of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originTag        string
	originHandler    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Optional() *mRegistryClientMockExtractImageLayers {
	mmExtractImageLayers.optional = true
	return mmExtractImageLayers
}

// Expect sets up expected params for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Expect(ctx context.Context, repository string, tag string, handler func(mm_pkg.LayerStream) error) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by ExpectParams functions")
	}

	mmExtractImageLayers.defaultExpectation.params = &RegistryClientMockExtractImageLayersParams{ctx, repository, tag, handler}
	mmExtractImageLayers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExtractImageLayers.expectations {
		if minimock.Equal(e.params, mmExtractImageLayers.defaultExpectation.params) {
			mmExtractImageLayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExtractImageLayers.defaultExpectation.params)
		}
	}

	return mmExtractImageLayers
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.params != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Expect")
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs == nil {
		mmExtractImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockExtractImageLayersParamPtrs{}
	}
	mmExtractImageLayers.defaultExpectation.paramPtrs.ctx = &ctx
	mmExtractImageLayers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExtractImageLayers
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) ExpectRepositoryParam2(repository string) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.params != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Expect")
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs == nil {
		mmExtractImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockExtractImageLayersParamPtrs{}
	}
	mmExtractImageLayers.defaultExpectation.paramPtrs.repository = &repository
	mmExtractImageLayers.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmExtractImageLayers
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) ExpectTagParam3(tag string) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.params != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Expect")
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs == nil {
		mmExtractImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockExtractImageLayersParamPtrs{}
	}
	mmExtractImageLayers.defaultExpectation.paramPtrs.tag = &tag
	mmExtractImageLayers.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmExtractImageLayers
}

// ExpectHandlerParam4 sets up expected param handler for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) ExpectHandlerParam4(handler func(mm_pkg.LayerStream) error) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.params != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Expect")
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs == nil {
		mmExtractImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockExtractImageLayersParamPtrs{}
	}
	mmExtractImageLayers.defaultExpectation.paramPtrs.handler = &handler
	mmExtractImageLayers.defaultExpectation.expectationOrigins.originHandler = minimock.CallerInfo(1)

	return mmExtractImageLayers
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Inspect(f func(ctx context.Context, repository string, tag string, handler func(mm_pkg.LayerStream) error)) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.inspectFuncExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ExtractImageLayers")
	}

	mmExtractImageLayers.mock.inspectFuncExtractImageLayers = f

	return mmExtractImageLayers
}

// Return sets up results that will be returned by RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Return(err error) *RegistryClientMock {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{mock: mmExtractImageLayers.mock}
	}
	mmExtractImageLayers.defaultExpectation.results = &RegistryClientMockExtractImageLayersResults{err}
	mmExtractImageLayers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExtractImageLayers.mock
}

// Set uses given function f to mock the RegistryClient.ExtractImageLayers method
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Set(f func(ctx context.Context, repository string, tag string, handler func(mm_pkg.LayerStream) error) (err error)) *RegistryClientMock {
	if mmExtractImageLayers.defaultExpectation != nil {
		mmExtractImageLayers.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ExtractImageLayers method")
	}

	if len(mmExtractImageLayers.expectations) > 0 {
		mmExtractImageLayers.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ExtractImageLayers method")
	}

	mmExtractImageLayers.mock.funcExtractImageLayers = f
	mmExtractImageLayers.mock.funcExtractImageLayersOrigin = minimock.CallerInfo(1)
	return mmExtractImageLayers.mock
}

// When sets expectation for the RegistryClient.ExtractImageLayers which will trigger the result defined by the following
// Then helper
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) When(ctx context.Context, repository string, tag string, handler func(mm_pkg.LayerStream) error) *RegistryClientMockExtractImageLayersExpectation {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	expectation := &RegistryClientMockExtractImageLayersExpectation{
		mock:               mmExtractImageLayers.mock,
		params:             &RegistryClientMockExtractImageLayersParams{ctx, repository, tag, handler},
		expectationOrigins: RegistryClientMockExtractImageLayersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExtractImageLayers.expectations = append(mmExtractImageLayers.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ExtractImageLayers return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockExtractImageLayersExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockExtractImageLayersResults{err}
	return e.mock
}

// Times sets number of times RegistryClient.ExtractImageLayers should be invoked
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Times(n uint64) *mRegistryClientMockExtractImageLayers {
	if n == 0 {
		mmExtractImageLayers.mock.t.Fatalf("Times of RegistryClientMock.ExtractImageLayers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExtractImageLayers.expectedInvocations, n)
	mmExtractImageLayers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExtractImageLayers
}

func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) invocationsDone() bool {
	if len(mmExtractImageLayers.expectations) == 0 && mmExtractImageLayers.defaultExpectation == nil && mmExtractImageLayers.mock.funcExtractImageLayers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExtractImageLayers.mock.afterExtractImageLayersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExtractImageLayers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExtractImageLayers implements mm_pkg.RegistryClient
func (mmExtractImageLayers *RegistryClientMock) ExtractImageLayers(ctx context.Context, repository string, tag string, handler func(mm_pkg.LayerStream) error) (err error) {
	mm_atomic.AddUint64(&mmExtractImageLayers.beforeExtractImageLayersCounter, 1)
	defer mm_atomic.AddUint64(&mmExtractImageLayers.afterExtractImageLayersCounter, 1)

	mmExtractImageLayers.t.Helper()

	if mmExtractImageLayers.inspectFuncExtractImageLayers != nil {
		mmExtractImageLayers.inspectFuncExtractImageLayers(ctx, repository, tag, handler)
	}

	mm_params := RegistryClientMockExtractImageLayersParams{ctx, repository, tag, handler}

	// Record call args
	mmExtractImageLayers.ExtractImageLayersMock.mutex.Lock()
	mmExtractImageLayers.ExtractImageLayersMock.callArgs = append(mmExtractImageLayers.ExtractImageLayersMock.callArgs, &mm_params)
	mmExtractImageLayers.ExtractImageLayersMock.mutex.Unlock()

	for _, e := range mmExtractImageLayers.ExtractImageLayersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.Counter, 1)
		mm_want := mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.params
		mm_want_ptrs := mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockExtractImageLayersParams{ctx, repository, tag, handler}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.handler != nil && !minimock.Equal(*mm_want_ptrs.handler, mm_got.handler) {
				mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameter handler, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.originHandler, *mm_want_ptrs.handler, mm_got.handler, minimock.Diff(*mm_want_ptrs.handler, mm_got.handler))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.results
		if mm_results == nil {
			mmExtractImageLayers.t.Fatal("No results are set for the RegistryClientMock.ExtractImageLayers")
		}
		return (*mm_results).err
	}
	if mmExtractImageLayers.funcExtractImageLayers != nil {
		return mmExtractImageLayers.funcExtractImageLayers(ctx, repository, tag, handler)
	}
	mmExtractImageLayers.t.Fatalf("Unexpected call to RegistryClientMock.ExtractImageLayers. %v %v %v %v", ctx, repository, tag, handler)
	return
}

// ExtractImageLayersAfterCounter returns a count of finished RegistryClientMock.ExtractImageLayers invocations
func (mmExtractImageLayers *RegistryClientMock) ExtractImageLayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractImageLayers.afterExtractImageLayersCounter)
}

// ExtractImageLayersBeforeCounter returns a count of RegistryClientMock.ExtractImageLayers invocations
func (mmExtractImageLayers *RegistryClientMock) ExtractImageLayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractImageLayers.beforeExtractImageLayersCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ExtractImageLayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Calls() []*RegistryClientMockExtractImageLayersParams {
	mmExtractImageLayers.mutex.RLock()

	argCopy := make([]*RegistryClientMockExtractImageLayersParams, len(mmExtractImageLayers.callArgs))
	copy(argCopy, mmExtractImageLayers.callArgs)

	mmExtractImageLayers.mutex.RUnlock()

	return argCopy
}

// MinimockExtractImageLayersDone returns true if the count of the ExtractImageLayers invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockExtractImageLayersDone() bool {
	if m.ExtractImageLayersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExtractImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExtractImageLayersMock.invocationsDone()
}

// MinimockExtractImageLayersInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockExtractImageLayersInspect() {
	for _, e := range m.ExtractImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExtractImageLayersCounter := mm_atomic.LoadUint64(&m.afterExtractImageLayersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExtractImageLayersMock.defaultExpectation != nil && afterExtractImageLayersCounter < 1 {
		if m.ExtractImageLayersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s", m.ExtractImageLayersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s with params: %#v", m.ExtractImageLayersMock.defaultExpectation.expectationOrigins.origin, *m.ExtractImageLayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExtractImageLayers != nil && afterExtractImageLayersCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s", m.funcExtractImageLayersOrigin)
	}

	if !m.ExtractImageLayersMock.invocationsDone() && afterExtractImageLayersCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ExtractImageLayers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExtractImageLayersMock.expectedInvocations), m.ExtractImageLayersMock.expectedInvocationsOrigin, afterExtractImageLayersCounter)
	}
}

type mRegistryClientMockGetImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageExpectation
	expectations       []*RegistryClientMockGetImageExpectation

	callArgs []*RegistryClientMockGetImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageExpectation specifies expectation struct of the RegistryClient.GetImage
type RegistryClientMockGetImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageParams
	paramPtrs          *RegistryClientMockGetImageParamPtrs
	expectationOrigins RegistryClientMockGetImageExpectationOrigins
	results            *RegistryClientMockGetImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageParams contains parameters of the RegistryClient.GetImage
type RegistryClientMockGetImageParams struct {
	ctx        context.Context
	repository string
	tag        string
}

// RegistryClientMockGetImageParamPtrs contains pointers to parameters of the RegistryClient.GetImage
type RegistryClientMockGetImageParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
}

// RegistryClientMockGetImageResults contains results of the RegistryClient.GetImage
type RegistryClientMockGetImageResults struct {
	i1  v1.Image
	err error
}

// RegistryClientMockGetImageOrigins contains origins of expectations of the RegistryClient.GetImage
type RegistryClientMockGetImageExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originTag        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImage *mRegistryClientMockGetImage) Optional() *mRegistryClientMockGetImage {
	mmGetImage.optional = true
	return mmGetImage
}

// Expect sets up expected params for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Expect(ctx context.Context, repository string, tag string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.paramPtrs != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by ExpectParams functions")
	}

	mmGetImage.defaultExpectation.params = &RegistryClientMockGetImageParams{ctx, repository, tag}
	mmGetImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImage.expectations {
		if minimock.Equal(e.params, mmGetImage.defaultExpectation.params) {
			mmGetImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImage.defaultExpectation.params)
		}
	}

	return mmGetImage
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImage
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectRepositoryParam2(repository string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.repository = &repository
	mmGetImage.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmGetImage
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectTagParam3(tag string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.tag = &tag
	mmGetImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImage
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Inspect(f func(ctx context.Context, repository string, tag string)) *mRegistryClientMockGetImage {
	if mmGetImage.mock.inspectFuncGetImage != nil {
		mmGetImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImage")
	}

	mmGetImage.mock.inspectFuncGetImage = f

	return mmGetImage
}

// Return sets up results that will be returned by RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Return(i1 v1.Image, err error) *RegistryClientMock {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{mock: mmGetImage.mock}
	}
	mmGetImage.defaultExpectation.results = &RegistryClientMockGetImageResults{i1, err}
	mmGetImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// Set uses given function f to mock the RegistryClient.GetImage method
func (mmGetImage *mRegistryClientMockGetImage) Set(f func(ctx context.Context, repository string, tag string) (i1 v1.Image, err error)) *RegistryClientMock {
	if mmGetImage.defaultExpectation != nil {
		mmGetImage.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImage method")
	}

	if len(mmGetImage.expectations) > 0 {
		mmGetImage.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImage method")
	}

	mmGetImage.mock.funcGetImage = f
	mmGetImage.mock.funcGetImageOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// When sets expectation for the RegistryClient.GetImage which will trigger the result defined by the following
// Then helper
func (mmGetImage *mRegistryClientMockGetImage) When(ctx context.Context, repository string, tag string) *RegistryClientMockGetImageExpectation {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageExpectation{
		mock:               mmGetImage.mock,
		params:             &RegistryClientMockGetImageParams{ctx, repository, tag},
		expectationOrigins: RegistryClientMockGetImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImage.expectations = append(mmGetImage.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImage return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageExpectation) Then(i1 v1.Image, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageResults{i1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImage should be invoked
func (mmGetImage *mRegistryClientMockGetImage) Times(n uint64) *mRegistryClientMockGetImage {
	if n == 0 {
		mmGetImage.mock.t.Fatalf("Times of RegistryClientMock.GetImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImage.expectedInvocations, n)
	mmGetImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImage
}

func (mmGetImage *mRegistryClientMockGetImage) invocationsDone() bool {
	if len(mmGetImage.expectations) == 0 && mmGetImage.defaultExpectation == nil && mmGetImage.mock.funcGetImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImage.mock.afterGetImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImage implements mm_pkg.RegistryClient
func (mmGetImage *RegistryClientMock) GetImage(ctx context.Context, repository string, tag string) (i1 v1.Image, err error) {
	mm_atomic.AddUint64(&mmGetImage.beforeGetImageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImage.afterGetImageCounter, 1)

	mmGetImage.t.Helper()

	if mmGetImage.inspectFuncGetImage != nil {
		mmGetImage.inspectFuncGetImage(ctx, repository, tag)
	}

	mm_params := RegistryClientMockGetImageParams{ctx, repository, tag}

	// Record call args
	mmGetImage.GetImageMock.mutex.Lock()
	mmGetImage.GetImageMock.callArgs = append(mmGetImage.GetImageMock.callArgs, &mm_params)
	mmGetImage.GetImageMock.mutex.Unlock()

	for _, e := range mmGetImage.GetImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetImage.GetImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImage.GetImageMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImage.GetImageMock.defaultExpectation.params
		mm_want_ptrs := mmGetImage.GetImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageParams{ctx, repository, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImage.GetImageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImage.t.Fatal("No results are set for the RegistryClientMock.GetImage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetImage.funcGetImage != nil {
		return mmGetImage.funcGetImage(ctx, repository, tag)
	}
	mmGetImage.t.Fatalf("Unexpected call to RegistryClientMock.GetImage. %v %v %v", ctx, repository, tag)
	return
}

// GetImageAfterCounter returns a count of finished RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.afterGetImageCounter)
}

// GetImageBeforeCounter returns a count of RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.beforeGetImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImage *mRegistryClientMockGetImage) Calls() []*RegistryClientMockGetImageParams {
	mmGetImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageParams, len(mmGetImage.callArgs))
	copy(argCopy, mmGetImage.callArgs)

	mmGetImage.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageDone returns true if the count of the GetImage invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageDone() bool {
	if m.GetImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageMock.invocationsDone()
}

// MinimockGetImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageInspect() {
	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageCounter := mm_atomic.LoadUint64(&m.afterGetImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageMock.defaultExpectation != nil && afterGetImageCounter < 1 {
		if m.GetImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.GetImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", m.GetImageMock.defaultExpectation.expectationOrigins.origin, *m.GetImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImage != nil && afterGetImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.funcGetImageOrigin)
	}

	if !m.GetImageMock.invocationsDone() && afterGetImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageMock.expectedInvocations), m.GetImageMock.expectedInvocationsOrigin, afterGetImageCounter)
	}
}

type mRegistryClientMockGetImageConfig struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageConfigExpectation
	expectations       []*RegistryClientMockGetImageConfigExpectation

	callArgs []*RegistryClientMockGetImageConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageConfigExpectation specifies expectation struct of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageConfigParams
	paramPtrs          *RegistryClientMockGetImageConfigParamPtrs
	expectationOrigins RegistryClientMockGetImageConfigExpectationOrigins
	results            *RegistryClientMockGetImageConfigResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageConfigParams contains parameters of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigParams struct {
	ctx        context.Context
	repository string
	tag        string
}

// RegistryClientMockGetImageConfigParamPtrs contains pointers to parameters of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
}

// RegistryClientMockGetImageConfigResults contains results of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigResults struct {
	cp1 *v1.ConfigFile
	err error
}

// RegistryClientMockGetImageConfigOrigins contains origins of expectations of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originTag        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Optional() *mRegistryClientMockGetImageConfig {
	mmGetImageConfig.optional = true
	return mmGetImageConfig
}

// Expect sets up expected params for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Expect(ctx context.Context, repository string, tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by ExpectParams functions")
	}

	mmGetImageConfig.defaultExpectation.params = &RegistryClientMockGetImageConfigParams{ctx, repository, tag}
	mmGetImageConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImageConfig.expectations {
		if minimock.Equal(e.params, mmGetImageConfig.defaultExpectation.params) {
			mmGetImageConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImageConfig.defaultExpectation.params)
		}
	}

	return mmGetImageConfig
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImageConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectRepositoryParam2(repository string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.repository = &repository
	mmGetImageConfig.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectTagParam3(tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.tag = &tag
	mmGetImageConfig.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Inspect(f func(ctx context.Context, repository string, tag string)) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImageConfig")
	}

	mmGetImageConfig.mock.inspectFuncGetImageConfig = f

	return mmGetImageConfig
}

// Return sets up results that will be returned by RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Return(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{mock: mmGetImageConfig.mock}
	}
	mmGetImageConfig.defaultExpectation.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	mmGetImageConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// Set uses given function f to mock the RegistryClient.GetImageConfig method
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Set(f func(ctx context.Context, repository string, tag string) (cp1 *v1.ConfigFile, err error)) *RegistryClientMock {
	if mmGetImageConfig.defaultExpectation != nil {
		mmGetImageConfig.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImageConfig method")
	}

	if len(mmGetImageConfig.expectations) > 0 {
		mmGetImageConfig.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImageConfig method")
	}

	mmGetImageConfig.mock.funcGetImageConfig = f
	mmGetImageConfig.mock.funcGetImageConfigOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// When sets expectation for the RegistryClient.GetImageConfig which will trigger the result defined by the following
// Then helper
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) When(ctx context.Context, repository string, tag string) *RegistryClientMockGetImageConfigExpectation {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageConfigExpectation{
		mock:               mmGetImageConfig.mock,
		params:             &RegistryClientMockGetImageConfigParams{ctx, repository, tag},
		expectationOrigins: RegistryClientMockGetImageConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImageConfig.expectations = append(mmGetImageConfig.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImageConfig return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageConfigExpectation) Then(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImageConfig should be invoked
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Times(n uint64) *mRegistryClientMockGetImageConfig {
	if n == 0 {
		mmGetImageConfig.mock.t.Fatalf("Times of RegistryClientMock.GetImageConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImageConfig.expectedInvocations, n)
	mmGetImageConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig
}

func (mmGetImageConfig *mRegistryClientMockGetImageConfig) invocationsDone() bool {
	if len(mmGetImageConfig.expectations) == 0 && mmGetImageConfig.defaultExpectation == nil && mmGetImageConfig.mock.funcGetImageConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.mock.afterGetImageConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImageConfig implements mm_pkg.RegistryClient
func (mmGetImageConfig *RegistryClientMock) GetImageConfig(ctx context.Context, repository string, tag string) (cp1 *v1.ConfigFile, err error) {
	mm_atomic.AddUint64(&mmGetImageConfig.beforeGetImageConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImageConfig.afterGetImageConfigCounter, 1)

	mmGetImageConfig.t.Helper()

	if mmGetImageConfig.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.inspectFuncGetImageConfig(ctx, repository, tag)
	}

	mm_params := RegistryClientMockGetImageConfigParams{ctx, repository, tag}

	// Record call args
	mmGetImageConfig.GetImageConfigMock.mutex.Lock()
	mmGetImageConfig.GetImageConfigMock.callArgs = append(mmGetImageConfig.GetImageConfigMock.callArgs, &mm_params)
	mmGetImageConfig.GetImageConfigMock.mutex.Unlock()

	for _, e := range mmGetImageConfig.GetImageConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetImageConfig.GetImageConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImageConfig.GetImageConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImageConfig.GetImageConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetImageConfig.GetImageConfigMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageConfigParams{ctx, repository, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImageConfig.GetImageConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImageConfig.t.Fatal("No results are set for the RegistryClientMock.GetImageConfig")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetImageConfig.funcGetImageConfig != nil {
		return mmGetImageConfig.funcGetImageConfig(ctx, repository, tag)
	}
	mmGetImageConfig.t.Fatalf("Unexpected call to RegistryClientMock.GetImageConfig. %v %v %v", ctx, repository, tag)
	return
}

// GetImageConfigAfterCounter returns a count of finished RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.afterGetImageConfigCounter)
}

// GetImageConfigBeforeCounter returns a count of RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.beforeGetImageConfigCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImageConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Calls() []*RegistryClientMockGetImageConfigParams {
	mmGetImageConfig.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageConfigParams, len(mmGetImageConfig.callArgs))
	copy(argCopy, mmGetImageConfig.callArgs)

	mmGetImageConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageConfigDone returns true if the count of the GetImageConfig invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageConfigDone() bool {
	if m.GetImageConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageConfigMock.invocationsDone()
}

// MinimockGetImageConfigInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageConfigInspect() {
	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageConfigCounter := mm_atomic.LoadUint64(&m.afterGetImageConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageConfigMock.defaultExpectation != nil && afterGetImageConfigCounter < 1 {
		if m.GetImageConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.GetImageConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", m.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetImageConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImageConfig != nil && afterGetImageConfigCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.funcGetImageConfigOrigin)
	}

	if !m.GetImageConfigMock.invocationsDone() && afterGetImageConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImageConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageConfigMock.expectedInvocations), m.GetImageConfigMock.expectedInvocationsOrigin, afterGetImageConfigCounter)
	}
}

type mRegistryClientMockGetImageLayers struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageLayersExpectation
	expectations       []*RegistryClientMockGetImageLayersExpectation

	callArgs []*RegistryClientMockGetImageLayersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageLayersExpectation specifies expectation struct of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageLayersParams
	paramPtrs          *RegistryClientMockGetImageLayersParamPtrs
	expectationOrigins RegistryClientMockGetImageLayersExpectationOrigins
	results            *RegistryClientMockGetImageLayersResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageLayersParams contains parameters of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersParams struct {
	ctx        context.Context
	repository string
	tag        string
}

// RegistryClientMockGetImageLayersParamPtrs contains pointers to parameters of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
}

// RegistryClientMockGetImageLayersResults contains results of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersResults struct {
	la1 []v1.Layer
	err error
}

// RegistryClientMockGetImageLayersOrigins contains origins of expectations of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originTag        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Optional() *mRegistryClientMockGetImageLayers {
	mmGetImageLayers.optional = true
	return mmGetImageLayers
}

// Expect sets up expected params for RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Expect(ctx context.Context, repository string, tag string) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{}
	}

	if mmGetImageLayers.defaultExpectation.paramPtrs != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by ExpectParams functions")
	}

	mmGetImageLayers.defaultExpectation.params = &RegistryClientMockGetImageLayersParams{ctx, repository, tag}
	mmGetImageLayers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImageLayers.expectations {
		if minimock.Equal(e.params, mmGetImageLayers.defaultExpectation.params) {
			mmGetImageLayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImageLayers.defaultExpectation.params)
		}
	}

	return mmGetImageLayers
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{}
	}

	if mmGetImageLayers.defaultExpectation.params != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Expect")
	}

	if mmGetImageLayers.defaultExpectation.paramPtrs == nil {
		mmGetImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockGetImageLayersParamPtrs{}
	}
	mmGetImageLayers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImageLayers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImageLayers
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) ExpectRepositoryParam2(repository string) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{}
	}

	if mmGetImageLayers.defaultExpectation.params != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Expect")
	}

	if mmGetImageLayers.defaultExpectation.paramPtrs == nil {
		mmGetImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockGetImageLayersParamPtrs{}
	}
	mmGetImageLayers.defaultExpectation.paramPtrs.repository = &repository
	mmGetImageLayers.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmGetImageLayers
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) ExpectTagParam3(tag string) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{}
	}

	if mmGetImageLayers.defaultExpectation.params != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Expect")
	}

	if mmGetImageLayers.defaultExpectation.paramPtrs == nil {
		mmGetImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockGetImageLayersParamPtrs{}
	}
	mmGetImageLayers.defaultExpectation.paramPtrs.tag = &tag
	mmGetImageLayers.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImageLayers
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Inspect(f func(ctx context.Context, repository string, tag string)) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.inspectFuncGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImageLayers")
	}

	mmGetImageLayers.mock.inspectFuncGetImageLayers = f

	return mmGetImageLayers
}

// Return sets up results that will be returned by RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Return(la1 []v1.Layer, err error) *RegistryClientMock {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{mock: mmGetImageLayers.mock}
	}
	mmGetImageLayers.defaultExpectation.results = &RegistryClientMockGetImageLayersResults{la1, err}
	mmGetImageLayers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImageLayers.mock
}

// Set uses given function f to mock the RegistryClient.GetImageLayers method
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Set(f func(ctx context.Context, repository string, tag string) (la1 []v1.Layer, err error)) *RegistryClientMock {
	if mmGetImageLayers.defaultExpectation != nil {
		mmGetImageLayers.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImageLayers method")
	}

	if len(mmGetImageLayers.expectations) > 0 {
		mmGetImageLayers.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImageLayers method")
	}

	mmGetImageLayers.mock.funcGetImageLayers = f
	mmGetImageLayers.mock.funcGetImageLayersOrigin = minimock.CallerInfo(1)
	return mmGetImageLayers.mock
}

// When sets expectation for the RegistryClient.GetImageLayers which will trigger the result defined by the following
// Then helper
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) When(ctx context.Context, repository string, tag string) *RegistryClientMockGetImageLayersExpectation {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageLayersExpectation{
		mock:               mmGetImageLayers.mock,
		params:             &RegistryClientMockGetImageLayersParams{ctx, repository, tag},
		expectationOrigins: RegistryClientMockGetImageLayersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImageLayers.expectations = append(mmGetImageLayers.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImageLayers return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageLayersExpectation) Then(la1 []v1.Layer, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageLayersResults{la1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImageLayers should be invoked
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Times(n uint64) *mRegistryClientMockGetImageLayers {
	if n == 0 {
		mmGetImageLayers.mock.t.Fatalf("Times of RegistryClientMock.GetImageLayers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImageLayers.expectedInvocations, n)
	mmGetImageLayers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImageLayers
}

func (mmGetImageLayers *mRegistryClientMockGetImageLayers) invocationsDone() bool {
	if len(mmGetImageLayers.expectations) == 0 && mmGetImageLayers.defaultExpectation == nil && mmGetImageLayers.mock.funcGetImageLayers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImageLayers.mock.afterGetImageLayersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImageLayers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImageLayers implements mm_pkg.RegistryClient
func (mmGetImageLayers *RegistryClientMock) GetImageLayers(ctx context.Context, repository string, tag string) (la1 []v1.Layer, err error) {
	mm_atomic.AddUint64(&mmGetImageLayers.beforeGetImageLayersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImageLayers.afterGetImageLayersCounter, 1)

	mmGetImageLayers.t.Helper()

	if mmGetImageLayers.inspectFuncGetImageLayers != nil {
		mmGetImageLayers.inspectFuncGetImageLayers(ctx, repository, tag)
	}

	mm_params := RegistryClientMockGetImageLayersParams{ctx, repository, tag}

	// Record call args
	mmGetImageLayers.GetImageLayersMock.mutex.Lock()
	mmGetImageLayers.GetImageLayersMock.callArgs = append(mmGetImageLayers.GetImageLayersMock.callArgs, &mm_params)
	mmGetImageLayers.GetImageLayersMock.mutex.Unlock()

	for _, e := range mmGetImageLayers.GetImageLayersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.la1, e.results.err
		}
	}

	if mmGetImageLayers.GetImageLayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImageLayers.GetImageLayersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImageLayers.GetImageLayersMock.defaultExpectation.params
		mm_want_ptrs := mmGetImageLayers.GetImageLayersMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageLayersParams{ctx, repository, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImageLayers.t.Errorf("RegistryClientMock.GetImageLayers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageLayers.GetImageLayersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmGetImageLayers.t.Errorf("RegistryClientMock.GetImageLayers got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageLayers.GetImageLayersMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImageLayers.t.Errorf("RegistryClientMock.GetImageLayers got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageLayers.GetImageLayersMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImageLayers.t.Errorf("RegistryClientMock.GetImageLayers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImageLayers.GetImageLayersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImageLayers.GetImageLayersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImageLayers.t.Fatal("No results are set for the RegistryClientMock.GetImageLayers")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmGetImageLayers.funcGetImageLayers != nil {
		return mmGetImageLayers.funcGetImageLayers(ctx, repository, tag)
	}
	mmGetImageLayers.t.Fatalf("Unexpected call to RegistryClientMock.GetImageLayers. %v %v %v", ctx, repository, tag)
	return
}

// GetImageLayersAfterCounter returns a count of finished RegistryClientMock.GetImageLayers invocations
func (mmGetImageLayers *RegistryClientMock) GetImageLayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageLayers.afterGetImageLayersCounter)
}

// GetImageLayersBeforeCounter returns a count of RegistryClientMock.GetImageLayers invocations
func (mmGetImageLayers *RegistryClientMock) GetImageLayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageLayers.beforeGetImageLayersCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImageLayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Calls() []*RegistryClientMockGetImageLayersParams {
	mmGetImageLayers.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageLayersParams, len(mmGetImageLayers.callArgs))
	copy(argCopy, mmGetImageLayers.callArgs)

	mmGetImageLayers.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageLayersDone returns true if the count of the GetImageLayers invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageLayersDone() bool {
	if m.GetImageLayersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageLayersMock.invocationsDone()
}

// MinimockGetImageLayersInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageLayersInspect() {
	for _, e := range m.GetImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageLayersCounter := mm_atomic.LoadUint64(&m.afterGetImageLayersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageLayersMock.defaultExpectation != nil && afterGetImageLayersCounter < 1 {
		if m.GetImageLayersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s", m.GetImageLayersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s with params: %#v", m.GetImageLayersMock.defaultExpectation.expectationOrigins.origin, *m.GetImageLayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImageLayers != nil && afterGetImageLayersCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s", m.funcGetImageLayersOrigin)
	}

	if !m.GetImageLayersMock.invocationsDone() && afterGetImageLayersCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImageLayers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageLayersMock.expectedInvocations), m.GetImageLayersMock.expectedInvocationsOrigin, afterGetImageLayersCounter)
	}
}

type mRegistryClientMockGetLabel struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetLabelExpectation
	expectations       []*RegistryClientMockGetLabelExpectation

	callArgs []*RegistryClientMockGetLabelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetLabelExpectation specifies expectation struct of the RegistryClient.GetLabel
type RegistryClientMockGetLabelExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetLabelParams
	paramPtrs          *RegistryClientMockGetLabelParamPtrs
	expectationOrigins RegistryClientMockGetLabelExpectationOrigins
	results            *RegistryClientMockGetLabelResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetLabelParams contains parameters of the RegistryClient.GetLabel
type RegistryClientMockGetLabelParams struct {
	ctx        context.Context
	repository string
	tag        string
	labelKey   string
}

// RegistryClientMockGetLabelParamPtrs contains pointers to parameters of the RegistryClient.GetLabel
type RegistryClientMockGetLabelParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
	labelKey   *string
}

// RegistryClientMockGetLabelResults contains results of the RegistryClient.GetLabel
type RegistryClientMockGetLabelResults struct {
	s1  string
	b1  bool
	err error
}

// RegistryClientMockGetLabelOrigins contains origins of expectations of the RegistryClient.GetLabel
type RegistryClientMockGetLabelExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originTag        string
	originLabelKey   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLabel *mRegistryClientMockGetLabel) Optional() *mRegistryClientMockGetLabel {
	mmGetLabel.optional = true
	return mmGetLabel
}

// Expect sets up expected params for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) Expect(ctx context.Context, repository string, tag string, labelKey string) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.paramPtrs != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by ExpectParams functions")
	}

	mmGetLabel.defaultExpectation.params = &RegistryClientMockGetLabelParams{ctx, repository, tag, labelKey}
	mmGetLabel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLabel.expectations {
		if minimock.Equal(e.params, mmGetLabel.defaultExpectation.params) {
			mmGetLabel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLabel.defaultExpectation.params)
		}
	}

	return mmGetLabel
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.params != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Expect")
	}

	if mmGetLabel.defaultExpectation.paramPtrs == nil {
		mmGetLabel.defaultExpectation.paramPtrs = &RegistryClientMockGetLabelParamPtrs{}
	}
	mmGetLabel.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLabel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLabel
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) ExpectRepositoryParam2(repository string) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.params != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Expect")
	}

	if mmGetLabel.defaultExpectation.paramPtrs == nil {
		mmGetLabel.defaultExpectation.paramPtrs = &RegistryClientMockGetLabelParamPtrs{}
	}
	mmGetLabel.defaultExpectation.paramPtrs.repository = &repository
	mmGetLabel.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmGetLabel
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) ExpectTagParam3(tag string) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.params != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Expect")
	}

	if mmGetLabel.defaultExpectation.paramPtrs == nil {
		mmGetLabel.defaultExpectation.paramPtrs = &RegistryClientMockGetLabelParamPtrs{}
	}
	mmGetLabel.defaultExpectation.paramPtrs.tag = &tag
	mmGetLabel.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetLabel
}

// ExpectLabelKeyParam4 sets up expected param labelKey for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) ExpectLabelKeyParam4(labelKey string) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.params != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Expect")
	}

	if mmGetLabel.defaultExpectation.paramPtrs == nil {
		mmGetLabel.defaultExpectation.paramPtrs = &RegistryClientMockGetLabelParamPtrs{}
	}
	mmGetLabel.defaultExpectation.paramPtrs.labelKey = &labelKey
	mmGetLabel.defaultExpectation.expectationOrigins.originLabelKey = minimock.CallerInfo(1)

	return mmGetLabel
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) Inspect(f func(ctx context.Context, repository string, tag string, labelKey string)) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.inspectFuncGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetLabel")
	}

	mmGetLabel.mock.inspectFuncGetLabel = f

	return mmGetLabel
}

// Return sets up results that will be returned by RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) Return(s1 string, b1 bool, err error) *RegistryClientMock {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{mock: mmGetLabel.mock}
	}
	mmGetLabel.defaultExpectation.results = &RegistryClientMockGetLabelResults{s1, b1, err}
	mmGetLabel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLabel.mock
}

// Set uses given function f to mock the RegistryClient.GetLabel method
func (mmGetLabel *mRegistryClientMockGetLabel) Set(f func(ctx context.Context, repository string, tag string, labelKey string) (s1 string, b1 bool, err error)) *RegistryClientMock {
	if mmGetLabel.defaultExpectation != nil {
		mmGetLabel.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetLabel method")
	}

	if len(mmGetLabel.expectations) > 0 {
		mmGetLabel.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetLabel method")
	}

	mmGetLabel.mock.funcGetLabel = f
	mmGetLabel.mock.funcGetLabelOrigin = minimock.CallerInfo(1)
	return mmGetLabel.mock
}

// When sets expectation for the RegistryClient.GetLabel which will trigger the result defined by the following
// Then helper
func (mmGetLabel *mRegistryClientMockGetLabel) When(ctx context.Context, repository string, tag string, labelKey string) *RegistryClientMockGetLabelExpectation {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	expectation := &RegistryClientMockGetLabelExpectation{
		mock:               mmGetLabel.mock,
		params:             &RegistryClientMockGetLabelParams{ctx, repository, tag, labelKey},
		expectationOrigins: RegistryClientMockGetLabelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLabel.expectations = append(mmGetLabel.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetLabel return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetLabelExpectation) Then(s1 string, b1 bool, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetLabelResults{s1, b1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetLabel should be invoked
func (mmGetLabel *mRegistryClientMockGetLabel) Times(n uint64) *mRegistryClientMockGetLabel {
	if n == 0 {
		mmGetLabel.mock.t.Fatalf("Times of RegistryClientMock.GetLabel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLabel.expectedInvocations, n)
	mmGetLabel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLabel
}

func (mmGetLabel *mRegistryClientMockGetLabel) invocationsDone() bool {
	if len(mmGetLabel.expectations) == 0 && mmGetLabel.defaultExpectation == nil && mmGetLabel.mock.funcGetLabel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLabel.mock.afterGetLabelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLabel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLabel implements mm_pkg.RegistryClient
func (mmGetLabel *RegistryClientMock) GetLabel(ctx context.Context, repository string, tag string, labelKey string) (s1 string, b1 bool, err error) {
	mm_atomic.AddUint64(&mmGetLabel.beforeGetLabelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLabel.afterGetLabelCounter, 1)

	mmGetLabel.t.Helper()

	if mmGetLabel.inspectFuncGetLabel != nil {
		mmGetLabel.inspectFuncGetLabel(ctx, repository, tag, labelKey)
	}

	mm_params := RegistryClientMockGetLabelParams{ctx, repository, tag, labelKey}

	// Record call args
	mmGetLabel.GetLabelMock.mutex.Lock()
	mmGetLabel.GetLabelMock.callArgs = append(mmGetLabel.GetLabelMock.callArgs, &mm_params)
	mmGetLabel.GetLabelMock.mutex.Unlock()

	for _, e := range mmGetLabel.GetLabelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.b1, e.results.err
		}
	}

	if mmGetLabel.GetLabelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLabel.GetLabelMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLabel.GetLabelMock.defaultExpectation.params
		mm_want_ptrs := mmGetLabel.GetLabelMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetLabelParams{ctx, repository, tag, labelKey}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.labelKey != nil && !minimock.Equal(*mm_want_ptrs.labelKey, mm_got.labelKey) {
				mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameter labelKey, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.originLabelKey, *mm_want_ptrs.labelKey, mm_got.labelKey, minimock.Diff(*mm_want_ptrs.labelKey, mm_got.labelKey))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLabel.GetLabelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLabel.t.Fatal("No results are set for the RegistryClientMock.GetLabel")
		}
		return (*mm_results).s1, (*mm_results).b1, (*mm_results).err
	}
	if mmGetLabel.funcGetLabel != nil {
		return mmGetLabel.funcGetLabel(ctx, repository, tag, labelKey)
	}
	mmGetLabel.t.Fatalf("Unexpected call to RegistryClientMock.GetLabel. %v %v %v %v", ctx, repository, tag, labelKey)
	return
}

// GetLabelAfterCounter returns a count of finished RegistryClientMock.GetLabel invocations
func (mmGetLabel *RegistryClientMock) GetLabelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLabel.afterGetLabelCounter)
}

// GetLabelBeforeCounter returns a count of RegistryClientMock.GetLabel invocations
func (mmGetLabel *RegistryClientMock) GetLabelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLabel.beforeGetLabelCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetLabel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLabel *mRegistryClientMockGetLabel) Calls() []*RegistryClientMockGetLabelParams {
	mmGetLabel.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetLabelParams, len(mmGetLabel.callArgs))
	copy(argCopy, mmGetLabel.callArgs)

	mmGetLabel.mutex.RUnlock()

	return argCopy
}

// MinimockGetLabelDone returns true if the count of the GetLabel invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetLabelDone() bool {
	if m.GetLabelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLabelMock.invocationsDone()
}

// MinimockGetLabelInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetLabelInspect() {
	for _, e := range m.GetLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLabelCounter := mm_atomic.LoadUint64(&m.afterGetLabelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLabelMock.defaultExpectation != nil && afterGetLabelCounter < 1 {
		if m.GetLabelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s", m.GetLabelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s with params: %#v", m.GetLabelMock.defaultExpectation.expectationOrigins.origin, *m.GetLabelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLabel != nil && afterGetLabelCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s", m.funcGetLabelOrigin)
	}

	if !m.GetLabelMock.invocationsDone() && afterGetLabelCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetLabel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLabelMock.expectedInvocations), m.GetLabelMock.expectedInvocationsOrigin, afterGetLabelCounter)
	}
}

type mRegistryClientMockGetManifest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetManifestExpectation
	expectations       []*RegistryClientMockGetManifestExpectation

	callArgs []*RegistryClientMockGetManifestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetManifestExpectation specifies expectation struct of the RegistryClient.GetManifest
type RegistryClientMockGetManifestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetManifestParams
	paramPtrs          *RegistryClientMockGetManifestParamPtrs
	expectationOrigins RegistryClientMockGetManifestExpectationOrigins
	results            *RegistryClientMockGetManifestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetManifestParams contains parameters of the RegistryClient.GetManifest
type RegistryClientMockGetManifestParams struct {
	ctx        context.Context
	repository string
	tag        string
}

// RegistryClientMockGetManifestParamPtrs contains pointers to parameters of the RegistryClient.GetManifest
type RegistryClientMockGetManifestParamPtrs struct {
	ctx        *context.Context
	repository *string
	tag        *string
}

// RegistryClientMockGetManifestResults contains results of the RegistryClient.GetManifest
type RegistryClientMockGetManifestResults struct {
	dp1 *remote.Descriptor
	err error
}

// RegistryClientMockGetManifestOrigins contains origins of expectations of the RegistryClient.GetManifest
type RegistryClientMockGetManifestExpectationOrigins struct {
	origin           string
	originCtx        string
	originRepository string
	originTag        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetManifest *mRegistryClientMockGetManifest) Optional() *mRegistryClientMockGetManifest {
	mmGetManifest.optional = true
	return mmGetManifest
}

// Expect sets up expected params for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Expect(ctx context.Context, repository string, tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.paramPtrs != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by ExpectParams functions")
	}

	mmGetManifest.defaultExpectation.params = &RegistryClientMockGetManifestParams{ctx, repository, tag}
	mmGetManifest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetManifest.expectations {
		if minimock.Equal(e.params, mmGetManifest.defaultExpectation.params) {
			mmGetManifest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetManifest.defaultExpectation.params)
		}
	}

	return mmGetManifest
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetManifest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetManifest
}

// ExpectRepositoryParam2 sets up expected param repository for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectRepositoryParam2(repository string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.repository = &repository
	mmGetManifest.defaultExpectation.expectationOrigins.originRepository = minimock.CallerInfo(1)

	return mmGetManifest
}

// ExpectTagParam3 sets up expected param tag for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectTagParam3(tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.tag = &tag
	mmGetManifest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetManifest
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Inspect(f func(ctx context.Context, repository string, tag string)) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.inspectFuncGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetManifest")
	}

	mmGetManifest.mock.inspectFuncGetManifest = f

	return mmGetManifest
}

// Return sets up results that will be returned by RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Return(dp1 *remote.Descriptor, err error) *RegistryClientMock {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{mock: mmGetManifest.mock}
	}
	mmGetManifest.defaultExpectation.results = &RegistryClientMockGetManifestResults{dp1, err}
	mmGetManifest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// Set uses given function f to mock the RegistryClient.GetManifest method
func (mmGetManifest *mRegistryClientMockGetManifest) Set(f func(ctx context.Context, repository string, tag string) (dp1 *remote.Descriptor, err error)) *RegistryClientMock {
	if mmGetManifest.defaultExpectation != nil {
		mmGetManifest.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetManifest method")
	}

	if len(mmGetManifest.expectations) > 0 {
		mmGetManifest.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetManifest method")
	}

	mmGetManifest.mock.funcGetManifest = f
	mmGetManifest.mock.funcGetManifestOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// When sets expectation for the RegistryClient.GetManifest which will trigger the result defined by the following
// Then helper
func (mmGetManifest *mRegistryClientMockGetManifest) When(ctx context.Context, repository string, tag string) *RegistryClientMockGetManifestExpectation {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetManifestExpectation{
		mock:               mmGetManifest.mock,
		params:             &RegistryClientMockGetManifestParams{ctx, repository, tag},
		expectationOrigins: RegistryClientMockGetManifestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetManifest.expectations = append(mmGetManifest.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetManifest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetManifestExpectation) Then(dp1 *remote.Descriptor, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetManifestResults{dp1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetManifest should be invoked
func (mmGetManifest *mRegistryClientMockGetManifest) Times(n uint64) *mRegistryClientMockGetManifest {
	if n == 0 {
		mmGetManifest.mock.t.Fatalf("Times of RegistryClientMock.GetManifest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetManifest.expectedInvocations, n)
	mmGetManifest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetManifest
}

func (mmGetManifest *mRegistryClientMockGetManifest) invocationsDone() bool {
	if len(mmGetManifest.expectations) == 0 && mmGetManifest.defaultExpectation == nil && mmGetManifest.mock.funcGetManifest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetManifest.mock.afterGetManifestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetManifest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetManifest implements mm_pkg.RegistryClient
func (mmGetManifest *RegistryClientMock) GetManifest(ctx context.Context, repository string, tag string) (dp1 *remote.Descriptor, err error) {
	mm_atomic.AddUint64(&mmGetManifest.beforeGetManifestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetManifest.afterGetManifestCounter, 1)

	mmGetManifest.t.Helper()

	if mmGetManifest.inspectFuncGetManifest != nil {
		mmGetManifest.inspectFuncGetManifest(ctx, repository, tag)
	}

	mm_params := RegistryClientMockGetManifestParams{ctx, repository, tag}

	// Record call args
	mmGetManifest.GetManifestMock.mutex.Lock()
	mmGetManifest.GetManifestMock.callArgs = append(mmGetManifest.GetManifestMock.callArgs, &mm_params)
	mmGetManifest.GetManifestMock.mutex.Unlock()

	for _, e := range mmGetManifest.GetManifestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGetManifest.GetManifestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetManifest.GetManifestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetManifest.GetManifestMock.defaultExpectation.params
		mm_want_ptrs := mmGetManifest.GetManifestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetManifestParams{ctx, repository, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.repository != nil && !minimock.Equal(*mm_want_ptrs.repository, mm_got.repository) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter repository, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originRepository, *mm_want_ptrs.repository, mm_got.repository, minimock.Diff(*mm_want_ptrs.repository, mm_got.repository))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetManifest.GetManifestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetManifest.t.Fatal("No results are set for the RegistryClientMock.GetManifest")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGetManifest.funcGetManifest != nil {
		return mmGetManifest.funcGetManifest(ctx, repository, tag)
	}
	mmGetManifest.t.Fatalf("Unexpected call to RegistryClientMock.GetManifest. %v %v %v", ctx, repository, tag)
	return
}

// GetManifestAfterCounter returns a count of finished RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.afterGetManifestCounter)
}

// GetManifestBeforeCounter returns a count of RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.beforeGetManifestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetManifest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetManifest *mRegistryClientMockGetManifest) Calls() []*RegistryClientMockGetManifestParams {
	mmGetManifest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetManifestParams, len(mmGetManifest.callArgs))
	copy(argCopy, mmGetManifest.callArgs)

	mmGetManifest.mutex.RUnlock()

	return argCopy
}

// MinimockGetManifestDone returns true if the count of the GetManifest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetManifestDone() bool {
	if m.GetManifestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetManifestMock.invocationsDone()
}

// MinimockGetManifestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetManifestInspect() {
	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetManifestCounter := mm_atomic.LoadUint64(&m.afterGetManifestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetManifestMock.defaultExpectation != nil && afterGetManifestCounter < 1 {
		if m.GetManifestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.GetManifestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", m.GetManifestMock.defaultExpectation.expectationOrigins.origin, *m.GetManifestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetManifest != nil && afterGetManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.funcGetManifestOrigin)
	}

	if !m.GetManifestMock.invocationsDone() && afterGetManifestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetManifest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetManifestMock.expectedInvocations), m.GetManifestMock.expectedInvocationsOrigin, afterGetManifestCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExtractImageLayersInspect()

			m.MinimockGetImageInspect()

			m.MinimockGetImageConfigInspect()

			m.MinimockGetImageLayersInspect()

			m.MinimockGetLabelInspect()

			m.MinimockGetManifestInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExtractImageLayersDone() &&
		m.MinimockGetImageDone() &&
		m.MinimockGetImageConfigDone() &&
		m.MinimockGetImageLayersDone() &&
		m.MinimockGetLabelDone() &&
		m.MinimockGetManifestDone()
}
