// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/deckhouse-cli/pkg.RegistryClient -o registry_client_mock.go -n RegistryClientMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/deckhouse-cli/pkg"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
)

// RegistryClientMock implements mm_pkg.RegistryClient
type RegistryClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetDigest          func(ctx context.Context, tag string) (hp1 *v1.Hash, err error)
	funcGetDigestOrigin    string
	inspectFuncGetDigest   func(ctx context.Context, tag string)
	afterGetDigestCounter  uint64
	beforeGetDigestCounter uint64
	GetDigestMock          mRegistryClientMockGetDigest

	funcGetImage          func(ctx context.Context, tag string) (r1 mm_pkg.RegistryImage, err error)
	funcGetImageOrigin    string
	inspectFuncGetImage   func(ctx context.Context, tag string)
	afterGetImageCounter  uint64
	beforeGetImageCounter uint64
	GetImageMock          mRegistryClientMockGetImage

	funcGetImageConfig          func(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error)
	funcGetImageConfigOrigin    string
	inspectFuncGetImageConfig   func(ctx context.Context, tag string)
	afterGetImageConfigCounter  uint64
	beforeGetImageConfigCounter uint64
	GetImageConfigMock          mRegistryClientMockGetImageConfig

	funcGetManifest          func(ctx context.Context, tag string) (ba1 []byte, err error)
	funcGetManifestOrigin    string
	inspectFuncGetManifest   func(ctx context.Context, tag string)
	afterGetManifestCounter  uint64
	beforeGetManifestCounter uint64
	GetManifestMock          mRegistryClientMockGetManifest

	funcGetRegistry          func() (s1 string)
	funcGetRegistryOrigin    string
	inspectFuncGetRegistry   func()
	afterGetRegistryCounter  uint64
	beforeGetRegistryCounter uint64
	GetRegistryMock          mRegistryClientMockGetRegistry

	funcListRepositories          func(ctx context.Context) (sa1 []string, err error)
	funcListRepositoriesOrigin    string
	inspectFuncListRepositories   func(ctx context.Context)
	afterListRepositoriesCounter  uint64
	beforeListRepositoriesCounter uint64
	ListRepositoriesMock          mRegistryClientMockListRepositories

	funcListTags          func(ctx context.Context) (sa1 []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mRegistryClientMockListTags

	funcPushImage          func(ctx context.Context, tag string, img mm_pkg.RegistryImage) (err error)
	funcPushImageOrigin    string
	inspectFuncPushImage   func(ctx context.Context, tag string, img mm_pkg.RegistryImage)
	afterPushImageCounter  uint64
	beforePushImageCounter uint64
	PushImageMock          mRegistryClientMockPushImage

	funcWithSegment          func(segments ...string) (r1 mm_pkg.RegistryClient)
	funcWithSegmentOrigin    string
	inspectFuncWithSegment   func(segments ...string)
	afterWithSegmentCounter  uint64
	beforeWithSegmentCounter uint64
	WithSegmentMock          mRegistryClientMockWithSegment
}

// NewRegistryClientMock returns a mock for mm_pkg.RegistryClient
func NewRegistryClientMock(t minimock.Tester) *RegistryClientMock {
	m := &RegistryClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetDigestMock = mRegistryClientMockGetDigest{mock: m}
	m.GetDigestMock.callArgs = []*RegistryClientMockGetDigestParams{}

	m.GetImageMock = mRegistryClientMockGetImage{mock: m}
	m.GetImageMock.callArgs = []*RegistryClientMockGetImageParams{}

	m.GetImageConfigMock = mRegistryClientMockGetImageConfig{mock: m}
	m.GetImageConfigMock.callArgs = []*RegistryClientMockGetImageConfigParams{}

	m.GetManifestMock = mRegistryClientMockGetManifest{mock: m}
	m.GetManifestMock.callArgs = []*RegistryClientMockGetManifestParams{}

	m.GetRegistryMock = mRegistryClientMockGetRegistry{mock: m}

	m.ListRepositoriesMock = mRegistryClientMockListRepositories{mock: m}
	m.ListRepositoriesMock.callArgs = []*RegistryClientMockListRepositoriesParams{}

	m.ListTagsMock = mRegistryClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*RegistryClientMockListTagsParams{}

	m.PushImageMock = mRegistryClientMockPushImage{mock: m}
	m.PushImageMock.callArgs = []*RegistryClientMockPushImageParams{}

	m.WithSegmentMock = mRegistryClientMockWithSegment{mock: m}
	m.WithSegmentMock.callArgs = []*RegistryClientMockWithSegmentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryClientMockGetDigest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetDigestExpectation
	expectations       []*RegistryClientMockGetDigestExpectation

	callArgs []*RegistryClientMockGetDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetDigestExpectation specifies expectation struct of the RegistryClient.GetDigest
type RegistryClientMockGetDigestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetDigestParams
	paramPtrs          *RegistryClientMockGetDigestParamPtrs
	expectationOrigins RegistryClientMockGetDigestExpectationOrigins
	results            *RegistryClientMockGetDigestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetDigestParams contains parameters of the RegistryClient.GetDigest
type RegistryClientMockGetDigestParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetDigestParamPtrs contains pointers to parameters of the RegistryClient.GetDigest
type RegistryClientMockGetDigestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetDigestResults contains results of the RegistryClient.GetDigest
type RegistryClientMockGetDigestResults struct {
	hp1 *v1.Hash
	err error
}

// RegistryClientMockGetDigestOrigins contains origins of expectations of the RegistryClient.GetDigest
type RegistryClientMockGetDigestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDigest *mRegistryClientMockGetDigest) Optional() *mRegistryClientMockGetDigest {
	mmGetDigest.optional = true
	return mmGetDigest
}

// Expect sets up expected params for RegistryClient.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) Expect(ctx context.Context, tag string) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{}
	}

	if mmGetDigest.defaultExpectation.paramPtrs != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by ExpectParams functions")
	}

	mmGetDigest.defaultExpectation.params = &RegistryClientMockGetDigestParams{ctx, tag}
	mmGetDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDigest.expectations {
		if minimock.Equal(e.params, mmGetDigest.defaultExpectation.params) {
			mmGetDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDigest.defaultExpectation.params)
		}
	}

	return mmGetDigest
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{}
	}

	if mmGetDigest.defaultExpectation.params != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Expect")
	}

	if mmGetDigest.defaultExpectation.paramPtrs == nil {
		mmGetDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetDigestParamPtrs{}
	}
	mmGetDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDigest
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) ExpectTagParam2(tag string) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{}
	}

	if mmGetDigest.defaultExpectation.params != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Expect")
	}

	if mmGetDigest.defaultExpectation.paramPtrs == nil {
		mmGetDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetDigestParamPtrs{}
	}
	mmGetDigest.defaultExpectation.paramPtrs.tag = &tag
	mmGetDigest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetDigest
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.inspectFuncGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetDigest")
	}

	mmGetDigest.mock.inspectFuncGetDigest = f

	return mmGetDigest
}

// Return sets up results that will be returned by RegistryClient.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) Return(hp1 *v1.Hash, err error) *RegistryClientMock {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{mock: mmGetDigest.mock}
	}
	mmGetDigest.defaultExpectation.results = &RegistryClientMockGetDigestResults{hp1, err}
	mmGetDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDigest.mock
}

// Set uses given function f to mock the RegistryClient.GetDigest method
func (mmGetDigest *mRegistryClientMockGetDigest) Set(f func(ctx context.Context, tag string) (hp1 *v1.Hash, err error)) *RegistryClientMock {
	if mmGetDigest.defaultExpectation != nil {
		mmGetDigest.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetDigest method")
	}

	if len(mmGetDigest.expectations) > 0 {
		mmGetDigest.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetDigest method")
	}

	mmGetDigest.mock.funcGetDigest = f
	mmGetDigest.mock.funcGetDigestOrigin = minimock.CallerInfo(1)
	return mmGetDigest.mock
}

// When sets expectation for the RegistryClient.GetDigest which will trigger the result defined by the following
// Then helper
func (mmGetDigest *mRegistryClientMockGetDigest) When(ctx context.Context, tag string) *RegistryClientMockGetDigestExpectation {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetDigestExpectation{
		mock:               mmGetDigest.mock,
		params:             &RegistryClientMockGetDigestParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDigest.expectations = append(mmGetDigest.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetDigest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetDigestExpectation) Then(hp1 *v1.Hash, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetDigestResults{hp1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetDigest should be invoked
func (mmGetDigest *mRegistryClientMockGetDigest) Times(n uint64) *mRegistryClientMockGetDigest {
	if n == 0 {
		mmGetDigest.mock.t.Fatalf("Times of RegistryClientMock.GetDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDigest.expectedInvocations, n)
	mmGetDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDigest
}

func (mmGetDigest *mRegistryClientMockGetDigest) invocationsDone() bool {
	if len(mmGetDigest.expectations) == 0 && mmGetDigest.defaultExpectation == nil && mmGetDigest.mock.funcGetDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDigest.mock.afterGetDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDigest implements mm_pkg.RegistryClient
func (mmGetDigest *RegistryClientMock) GetDigest(ctx context.Context, tag string) (hp1 *v1.Hash, err error) {
	mm_atomic.AddUint64(&mmGetDigest.beforeGetDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigest.afterGetDigestCounter, 1)

	mmGetDigest.t.Helper()

	if mmGetDigest.inspectFuncGetDigest != nil {
		mmGetDigest.inspectFuncGetDigest(ctx, tag)
	}

	mm_params := RegistryClientMockGetDigestParams{ctx, tag}

	// Record call args
	mmGetDigest.GetDigestMock.mutex.Lock()
	mmGetDigest.GetDigestMock.callArgs = append(mmGetDigest.GetDigestMock.callArgs, &mm_params)
	mmGetDigest.GetDigestMock.mutex.Unlock()

	for _, e := range mmGetDigest.GetDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmGetDigest.GetDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigest.GetDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDigest.GetDigestMock.defaultExpectation.params
		mm_want_ptrs := mmGetDigest.GetDigestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetDigestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDigest.t.Errorf("RegistryClientMock.GetDigest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDigest.GetDigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetDigest.t.Errorf("RegistryClientMock.GetDigest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDigest.GetDigestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDigest.t.Errorf("RegistryClientMock.GetDigest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDigest.GetDigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDigest.GetDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigest.t.Fatal("No results are set for the RegistryClientMock.GetDigest")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmGetDigest.funcGetDigest != nil {
		return mmGetDigest.funcGetDigest(ctx, tag)
	}
	mmGetDigest.t.Fatalf("Unexpected call to RegistryClientMock.GetDigest. %v %v", ctx, tag)
	return
}

// GetDigestAfterCounter returns a count of finished RegistryClientMock.GetDigest invocations
func (mmGetDigest *RegistryClientMock) GetDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigest.afterGetDigestCounter)
}

// GetDigestBeforeCounter returns a count of RegistryClientMock.GetDigest invocations
func (mmGetDigest *RegistryClientMock) GetDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigest.beforeGetDigestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDigest *mRegistryClientMockGetDigest) Calls() []*RegistryClientMockGetDigestParams {
	mmGetDigest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetDigestParams, len(mmGetDigest.callArgs))
	copy(argCopy, mmGetDigest.callArgs)

	mmGetDigest.mutex.RUnlock()

	return argCopy
}

// MinimockGetDigestDone returns true if the count of the GetDigest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetDigestDone() bool {
	if m.GetDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDigestMock.invocationsDone()
}

// MinimockGetDigestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetDigestInspect() {
	for _, e := range m.GetDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDigestCounter := mm_atomic.LoadUint64(&m.afterGetDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMock.defaultExpectation != nil && afterGetDigestCounter < 1 {
		if m.GetDigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s", m.GetDigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s with params: %#v", m.GetDigestMock.defaultExpectation.expectationOrigins.origin, *m.GetDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigest != nil && afterGetDigestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s", m.funcGetDigestOrigin)
	}

	if !m.GetDigestMock.invocationsDone() && afterGetDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetDigest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDigestMock.expectedInvocations), m.GetDigestMock.expectedInvocationsOrigin, afterGetDigestCounter)
	}
}

type mRegistryClientMockGetImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageExpectation
	expectations       []*RegistryClientMockGetImageExpectation

	callArgs []*RegistryClientMockGetImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageExpectation specifies expectation struct of the RegistryClient.GetImage
type RegistryClientMockGetImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageParams
	paramPtrs          *RegistryClientMockGetImageParamPtrs
	expectationOrigins RegistryClientMockGetImageExpectationOrigins
	results            *RegistryClientMockGetImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageParams contains parameters of the RegistryClient.GetImage
type RegistryClientMockGetImageParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetImageParamPtrs contains pointers to parameters of the RegistryClient.GetImage
type RegistryClientMockGetImageParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetImageResults contains results of the RegistryClient.GetImage
type RegistryClientMockGetImageResults struct {
	r1  mm_pkg.RegistryImage
	err error
}

// RegistryClientMockGetImageOrigins contains origins of expectations of the RegistryClient.GetImage
type RegistryClientMockGetImageExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImage *mRegistryClientMockGetImage) Optional() *mRegistryClientMockGetImage {
	mmGetImage.optional = true
	return mmGetImage
}

// Expect sets up expected params for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Expect(ctx context.Context, tag string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.paramPtrs != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by ExpectParams functions")
	}

	mmGetImage.defaultExpectation.params = &RegistryClientMockGetImageParams{ctx, tag}
	mmGetImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImage.expectations {
		if minimock.Equal(e.params, mmGetImage.defaultExpectation.params) {
			mmGetImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImage.defaultExpectation.params)
		}
	}

	return mmGetImage
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImage
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectTagParam2(tag string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.tag = &tag
	mmGetImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImage
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetImage {
	if mmGetImage.mock.inspectFuncGetImage != nil {
		mmGetImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImage")
	}

	mmGetImage.mock.inspectFuncGetImage = f

	return mmGetImage
}

// Return sets up results that will be returned by RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Return(r1 mm_pkg.RegistryImage, err error) *RegistryClientMock {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{mock: mmGetImage.mock}
	}
	mmGetImage.defaultExpectation.results = &RegistryClientMockGetImageResults{r1, err}
	mmGetImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// Set uses given function f to mock the RegistryClient.GetImage method
func (mmGetImage *mRegistryClientMockGetImage) Set(f func(ctx context.Context, tag string) (r1 mm_pkg.RegistryImage, err error)) *RegistryClientMock {
	if mmGetImage.defaultExpectation != nil {
		mmGetImage.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImage method")
	}

	if len(mmGetImage.expectations) > 0 {
		mmGetImage.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImage method")
	}

	mmGetImage.mock.funcGetImage = f
	mmGetImage.mock.funcGetImageOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// When sets expectation for the RegistryClient.GetImage which will trigger the result defined by the following
// Then helper
func (mmGetImage *mRegistryClientMockGetImage) When(ctx context.Context, tag string) *RegistryClientMockGetImageExpectation {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageExpectation{
		mock:               mmGetImage.mock,
		params:             &RegistryClientMockGetImageParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImage.expectations = append(mmGetImage.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImage return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageExpectation) Then(r1 mm_pkg.RegistryImage, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageResults{r1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImage should be invoked
func (mmGetImage *mRegistryClientMockGetImage) Times(n uint64) *mRegistryClientMockGetImage {
	if n == 0 {
		mmGetImage.mock.t.Fatalf("Times of RegistryClientMock.GetImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImage.expectedInvocations, n)
	mmGetImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImage
}

func (mmGetImage *mRegistryClientMockGetImage) invocationsDone() bool {
	if len(mmGetImage.expectations) == 0 && mmGetImage.defaultExpectation == nil && mmGetImage.mock.funcGetImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImage.mock.afterGetImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImage implements mm_pkg.RegistryClient
func (mmGetImage *RegistryClientMock) GetImage(ctx context.Context, tag string) (r1 mm_pkg.RegistryImage, err error) {
	mm_atomic.AddUint64(&mmGetImage.beforeGetImageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImage.afterGetImageCounter, 1)

	mmGetImage.t.Helper()

	if mmGetImage.inspectFuncGetImage != nil {
		mmGetImage.inspectFuncGetImage(ctx, tag)
	}

	mm_params := RegistryClientMockGetImageParams{ctx, tag}

	// Record call args
	mmGetImage.GetImageMock.mutex.Lock()
	mmGetImage.GetImageMock.callArgs = append(mmGetImage.GetImageMock.callArgs, &mm_params)
	mmGetImage.GetImageMock.mutex.Unlock()

	for _, e := range mmGetImage.GetImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetImage.GetImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImage.GetImageMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImage.GetImageMock.defaultExpectation.params
		mm_want_ptrs := mmGetImage.GetImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImage.GetImageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImage.t.Fatal("No results are set for the RegistryClientMock.GetImage")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetImage.funcGetImage != nil {
		return mmGetImage.funcGetImage(ctx, tag)
	}
	mmGetImage.t.Fatalf("Unexpected call to RegistryClientMock.GetImage. %v %v", ctx, tag)
	return
}

// GetImageAfterCounter returns a count of finished RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.afterGetImageCounter)
}

// GetImageBeforeCounter returns a count of RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.beforeGetImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImage *mRegistryClientMockGetImage) Calls() []*RegistryClientMockGetImageParams {
	mmGetImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageParams, len(mmGetImage.callArgs))
	copy(argCopy, mmGetImage.callArgs)

	mmGetImage.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageDone returns true if the count of the GetImage invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageDone() bool {
	if m.GetImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageMock.invocationsDone()
}

// MinimockGetImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageInspect() {
	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageCounter := mm_atomic.LoadUint64(&m.afterGetImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageMock.defaultExpectation != nil && afterGetImageCounter < 1 {
		if m.GetImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.GetImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", m.GetImageMock.defaultExpectation.expectationOrigins.origin, *m.GetImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImage != nil && afterGetImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.funcGetImageOrigin)
	}

	if !m.GetImageMock.invocationsDone() && afterGetImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageMock.expectedInvocations), m.GetImageMock.expectedInvocationsOrigin, afterGetImageCounter)
	}
}

type mRegistryClientMockGetImageConfig struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageConfigExpectation
	expectations       []*RegistryClientMockGetImageConfigExpectation

	callArgs []*RegistryClientMockGetImageConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageConfigExpectation specifies expectation struct of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageConfigParams
	paramPtrs          *RegistryClientMockGetImageConfigParamPtrs
	expectationOrigins RegistryClientMockGetImageConfigExpectationOrigins
	results            *RegistryClientMockGetImageConfigResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageConfigParams contains parameters of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetImageConfigParamPtrs contains pointers to parameters of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetImageConfigResults contains results of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigResults struct {
	cp1 *v1.ConfigFile
	err error
}

// RegistryClientMockGetImageConfigOrigins contains origins of expectations of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Optional() *mRegistryClientMockGetImageConfig {
	mmGetImageConfig.optional = true
	return mmGetImageConfig
}

// Expect sets up expected params for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Expect(ctx context.Context, tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by ExpectParams functions")
	}

	mmGetImageConfig.defaultExpectation.params = &RegistryClientMockGetImageConfigParams{ctx, tag}
	mmGetImageConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImageConfig.expectations {
		if minimock.Equal(e.params, mmGetImageConfig.defaultExpectation.params) {
			mmGetImageConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImageConfig.defaultExpectation.params)
		}
	}

	return mmGetImageConfig
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImageConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectTagParam2(tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.tag = &tag
	mmGetImageConfig.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImageConfig")
	}

	mmGetImageConfig.mock.inspectFuncGetImageConfig = f

	return mmGetImageConfig
}

// Return sets up results that will be returned by RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Return(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{mock: mmGetImageConfig.mock}
	}
	mmGetImageConfig.defaultExpectation.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	mmGetImageConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// Set uses given function f to mock the RegistryClient.GetImageConfig method
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Set(f func(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error)) *RegistryClientMock {
	if mmGetImageConfig.defaultExpectation != nil {
		mmGetImageConfig.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImageConfig method")
	}

	if len(mmGetImageConfig.expectations) > 0 {
		mmGetImageConfig.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImageConfig method")
	}

	mmGetImageConfig.mock.funcGetImageConfig = f
	mmGetImageConfig.mock.funcGetImageConfigOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// When sets expectation for the RegistryClient.GetImageConfig which will trigger the result defined by the following
// Then helper
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) When(ctx context.Context, tag string) *RegistryClientMockGetImageConfigExpectation {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageConfigExpectation{
		mock:               mmGetImageConfig.mock,
		params:             &RegistryClientMockGetImageConfigParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetImageConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImageConfig.expectations = append(mmGetImageConfig.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImageConfig return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageConfigExpectation) Then(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImageConfig should be invoked
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Times(n uint64) *mRegistryClientMockGetImageConfig {
	if n == 0 {
		mmGetImageConfig.mock.t.Fatalf("Times of RegistryClientMock.GetImageConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImageConfig.expectedInvocations, n)
	mmGetImageConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig
}

func (mmGetImageConfig *mRegistryClientMockGetImageConfig) invocationsDone() bool {
	if len(mmGetImageConfig.expectations) == 0 && mmGetImageConfig.defaultExpectation == nil && mmGetImageConfig.mock.funcGetImageConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.mock.afterGetImageConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImageConfig implements mm_pkg.RegistryClient
func (mmGetImageConfig *RegistryClientMock) GetImageConfig(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error) {
	mm_atomic.AddUint64(&mmGetImageConfig.beforeGetImageConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImageConfig.afterGetImageConfigCounter, 1)

	mmGetImageConfig.t.Helper()

	if mmGetImageConfig.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.inspectFuncGetImageConfig(ctx, tag)
	}

	mm_params := RegistryClientMockGetImageConfigParams{ctx, tag}

	// Record call args
	mmGetImageConfig.GetImageConfigMock.mutex.Lock()
	mmGetImageConfig.GetImageConfigMock.callArgs = append(mmGetImageConfig.GetImageConfigMock.callArgs, &mm_params)
	mmGetImageConfig.GetImageConfigMock.mutex.Unlock()

	for _, e := range mmGetImageConfig.GetImageConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetImageConfig.GetImageConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImageConfig.GetImageConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImageConfig.GetImageConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetImageConfig.GetImageConfigMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageConfigParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImageConfig.GetImageConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImageConfig.t.Fatal("No results are set for the RegistryClientMock.GetImageConfig")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetImageConfig.funcGetImageConfig != nil {
		return mmGetImageConfig.funcGetImageConfig(ctx, tag)
	}
	mmGetImageConfig.t.Fatalf("Unexpected call to RegistryClientMock.GetImageConfig. %v %v", ctx, tag)
	return
}

// GetImageConfigAfterCounter returns a count of finished RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.afterGetImageConfigCounter)
}

// GetImageConfigBeforeCounter returns a count of RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.beforeGetImageConfigCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImageConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Calls() []*RegistryClientMockGetImageConfigParams {
	mmGetImageConfig.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageConfigParams, len(mmGetImageConfig.callArgs))
	copy(argCopy, mmGetImageConfig.callArgs)

	mmGetImageConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageConfigDone returns true if the count of the GetImageConfig invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageConfigDone() bool {
	if m.GetImageConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageConfigMock.invocationsDone()
}

// MinimockGetImageConfigInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageConfigInspect() {
	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageConfigCounter := mm_atomic.LoadUint64(&m.afterGetImageConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageConfigMock.defaultExpectation != nil && afterGetImageConfigCounter < 1 {
		if m.GetImageConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.GetImageConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", m.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetImageConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImageConfig != nil && afterGetImageConfigCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.funcGetImageConfigOrigin)
	}

	if !m.GetImageConfigMock.invocationsDone() && afterGetImageConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImageConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageConfigMock.expectedInvocations), m.GetImageConfigMock.expectedInvocationsOrigin, afterGetImageConfigCounter)
	}
}

type mRegistryClientMockGetManifest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetManifestExpectation
	expectations       []*RegistryClientMockGetManifestExpectation

	callArgs []*RegistryClientMockGetManifestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetManifestExpectation specifies expectation struct of the RegistryClient.GetManifest
type RegistryClientMockGetManifestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetManifestParams
	paramPtrs          *RegistryClientMockGetManifestParamPtrs
	expectationOrigins RegistryClientMockGetManifestExpectationOrigins
	results            *RegistryClientMockGetManifestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetManifestParams contains parameters of the RegistryClient.GetManifest
type RegistryClientMockGetManifestParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetManifestParamPtrs contains pointers to parameters of the RegistryClient.GetManifest
type RegistryClientMockGetManifestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetManifestResults contains results of the RegistryClient.GetManifest
type RegistryClientMockGetManifestResults struct {
	ba1 []byte
	err error
}

// RegistryClientMockGetManifestOrigins contains origins of expectations of the RegistryClient.GetManifest
type RegistryClientMockGetManifestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetManifest *mRegistryClientMockGetManifest) Optional() *mRegistryClientMockGetManifest {
	mmGetManifest.optional = true
	return mmGetManifest
}

// Expect sets up expected params for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Expect(ctx context.Context, tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.paramPtrs != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by ExpectParams functions")
	}

	mmGetManifest.defaultExpectation.params = &RegistryClientMockGetManifestParams{ctx, tag}
	mmGetManifest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetManifest.expectations {
		if minimock.Equal(e.params, mmGetManifest.defaultExpectation.params) {
			mmGetManifest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetManifest.defaultExpectation.params)
		}
	}

	return mmGetManifest
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetManifest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetManifest
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectTagParam2(tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.tag = &tag
	mmGetManifest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetManifest
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.inspectFuncGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetManifest")
	}

	mmGetManifest.mock.inspectFuncGetManifest = f

	return mmGetManifest
}

// Return sets up results that will be returned by RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Return(ba1 []byte, err error) *RegistryClientMock {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{mock: mmGetManifest.mock}
	}
	mmGetManifest.defaultExpectation.results = &RegistryClientMockGetManifestResults{ba1, err}
	mmGetManifest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// Set uses given function f to mock the RegistryClient.GetManifest method
func (mmGetManifest *mRegistryClientMockGetManifest) Set(f func(ctx context.Context, tag string) (ba1 []byte, err error)) *RegistryClientMock {
	if mmGetManifest.defaultExpectation != nil {
		mmGetManifest.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetManifest method")
	}

	if len(mmGetManifest.expectations) > 0 {
		mmGetManifest.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetManifest method")
	}

	mmGetManifest.mock.funcGetManifest = f
	mmGetManifest.mock.funcGetManifestOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// When sets expectation for the RegistryClient.GetManifest which will trigger the result defined by the following
// Then helper
func (mmGetManifest *mRegistryClientMockGetManifest) When(ctx context.Context, tag string) *RegistryClientMockGetManifestExpectation {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetManifestExpectation{
		mock:               mmGetManifest.mock,
		params:             &RegistryClientMockGetManifestParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetManifestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetManifest.expectations = append(mmGetManifest.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetManifest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetManifestExpectation) Then(ba1 []byte, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetManifestResults{ba1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetManifest should be invoked
func (mmGetManifest *mRegistryClientMockGetManifest) Times(n uint64) *mRegistryClientMockGetManifest {
	if n == 0 {
		mmGetManifest.mock.t.Fatalf("Times of RegistryClientMock.GetManifest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetManifest.expectedInvocations, n)
	mmGetManifest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetManifest
}

func (mmGetManifest *mRegistryClientMockGetManifest) invocationsDone() bool {
	if len(mmGetManifest.expectations) == 0 && mmGetManifest.defaultExpectation == nil && mmGetManifest.mock.funcGetManifest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetManifest.mock.afterGetManifestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetManifest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetManifest implements mm_pkg.RegistryClient
func (mmGetManifest *RegistryClientMock) GetManifest(ctx context.Context, tag string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetManifest.beforeGetManifestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetManifest.afterGetManifestCounter, 1)

	mmGetManifest.t.Helper()

	if mmGetManifest.inspectFuncGetManifest != nil {
		mmGetManifest.inspectFuncGetManifest(ctx, tag)
	}

	mm_params := RegistryClientMockGetManifestParams{ctx, tag}

	// Record call args
	mmGetManifest.GetManifestMock.mutex.Lock()
	mmGetManifest.GetManifestMock.callArgs = append(mmGetManifest.GetManifestMock.callArgs, &mm_params)
	mmGetManifest.GetManifestMock.mutex.Unlock()

	for _, e := range mmGetManifest.GetManifestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetManifest.GetManifestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetManifest.GetManifestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetManifest.GetManifestMock.defaultExpectation.params
		mm_want_ptrs := mmGetManifest.GetManifestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetManifestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetManifest.GetManifestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetManifest.t.Fatal("No results are set for the RegistryClientMock.GetManifest")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetManifest.funcGetManifest != nil {
		return mmGetManifest.funcGetManifest(ctx, tag)
	}
	mmGetManifest.t.Fatalf("Unexpected call to RegistryClientMock.GetManifest. %v %v", ctx, tag)
	return
}

// GetManifestAfterCounter returns a count of finished RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.afterGetManifestCounter)
}

// GetManifestBeforeCounter returns a count of RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.beforeGetManifestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetManifest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetManifest *mRegistryClientMockGetManifest) Calls() []*RegistryClientMockGetManifestParams {
	mmGetManifest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetManifestParams, len(mmGetManifest.callArgs))
	copy(argCopy, mmGetManifest.callArgs)

	mmGetManifest.mutex.RUnlock()

	return argCopy
}

// MinimockGetManifestDone returns true if the count of the GetManifest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetManifestDone() bool {
	if m.GetManifestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetManifestMock.invocationsDone()
}

// MinimockGetManifestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetManifestInspect() {
	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetManifestCounter := mm_atomic.LoadUint64(&m.afterGetManifestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetManifestMock.defaultExpectation != nil && afterGetManifestCounter < 1 {
		if m.GetManifestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.GetManifestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", m.GetManifestMock.defaultExpectation.expectationOrigins.origin, *m.GetManifestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetManifest != nil && afterGetManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.funcGetManifestOrigin)
	}

	if !m.GetManifestMock.invocationsDone() && afterGetManifestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetManifest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetManifestMock.expectedInvocations), m.GetManifestMock.expectedInvocationsOrigin, afterGetManifestCounter)
	}
}

type mRegistryClientMockGetRegistry struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetRegistryExpectation
	expectations       []*RegistryClientMockGetRegistryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetRegistryExpectation specifies expectation struct of the RegistryClient.GetRegistry
type RegistryClientMockGetRegistryExpectation struct {
	mock *RegistryClientMock

	results      *RegistryClientMockGetRegistryResults
	returnOrigin string
	Counter      uint64
}

// RegistryClientMockGetRegistryResults contains results of the RegistryClient.GetRegistry
type RegistryClientMockGetRegistryResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRegistry *mRegistryClientMockGetRegistry) Optional() *mRegistryClientMockGetRegistry {
	mmGetRegistry.optional = true
	return mmGetRegistry
}

// Expect sets up expected params for RegistryClient.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Expect() *mRegistryClientMockGetRegistry {
	if mmGetRegistry.mock.funcGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("RegistryClientMock.GetRegistry mock is already set by Set")
	}

	if mmGetRegistry.defaultExpectation == nil {
		mmGetRegistry.defaultExpectation = &RegistryClientMockGetRegistryExpectation{}
	}

	return mmGetRegistry
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Inspect(f func()) *mRegistryClientMockGetRegistry {
	if mmGetRegistry.mock.inspectFuncGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetRegistry")
	}

	mmGetRegistry.mock.inspectFuncGetRegistry = f

	return mmGetRegistry
}

// Return sets up results that will be returned by RegistryClient.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Return(s1 string) *RegistryClientMock {
	if mmGetRegistry.mock.funcGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("RegistryClientMock.GetRegistry mock is already set by Set")
	}

	if mmGetRegistry.defaultExpectation == nil {
		mmGetRegistry.defaultExpectation = &RegistryClientMockGetRegistryExpectation{mock: mmGetRegistry.mock}
	}
	mmGetRegistry.defaultExpectation.results = &RegistryClientMockGetRegistryResults{s1}
	mmGetRegistry.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRegistry.mock
}

// Set uses given function f to mock the RegistryClient.GetRegistry method
func (mmGetRegistry *mRegistryClientMockGetRegistry) Set(f func() (s1 string)) *RegistryClientMock {
	if mmGetRegistry.defaultExpectation != nil {
		mmGetRegistry.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetRegistry method")
	}

	if len(mmGetRegistry.expectations) > 0 {
		mmGetRegistry.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetRegistry method")
	}

	mmGetRegistry.mock.funcGetRegistry = f
	mmGetRegistry.mock.funcGetRegistryOrigin = minimock.CallerInfo(1)
	return mmGetRegistry.mock
}

// Times sets number of times RegistryClient.GetRegistry should be invoked
func (mmGetRegistry *mRegistryClientMockGetRegistry) Times(n uint64) *mRegistryClientMockGetRegistry {
	if n == 0 {
		mmGetRegistry.mock.t.Fatalf("Times of RegistryClientMock.GetRegistry mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRegistry.expectedInvocations, n)
	mmGetRegistry.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRegistry
}

func (mmGetRegistry *mRegistryClientMockGetRegistry) invocationsDone() bool {
	if len(mmGetRegistry.expectations) == 0 && mmGetRegistry.defaultExpectation == nil && mmGetRegistry.mock.funcGetRegistry == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRegistry.mock.afterGetRegistryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRegistry.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRegistry implements mm_pkg.RegistryClient
func (mmGetRegistry *RegistryClientMock) GetRegistry() (s1 string) {
	mm_atomic.AddUint64(&mmGetRegistry.beforeGetRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRegistry.afterGetRegistryCounter, 1)

	mmGetRegistry.t.Helper()

	if mmGetRegistry.inspectFuncGetRegistry != nil {
		mmGetRegistry.inspectFuncGetRegistry()
	}

	if mmGetRegistry.GetRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRegistry.GetRegistryMock.defaultExpectation.Counter, 1)

		mm_results := mmGetRegistry.GetRegistryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRegistry.t.Fatal("No results are set for the RegistryClientMock.GetRegistry")
		}
		return (*mm_results).s1
	}
	if mmGetRegistry.funcGetRegistry != nil {
		return mmGetRegistry.funcGetRegistry()
	}
	mmGetRegistry.t.Fatalf("Unexpected call to RegistryClientMock.GetRegistry.")
	return
}

// GetRegistryAfterCounter returns a count of finished RegistryClientMock.GetRegistry invocations
func (mmGetRegistry *RegistryClientMock) GetRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistry.afterGetRegistryCounter)
}

// GetRegistryBeforeCounter returns a count of RegistryClientMock.GetRegistry invocations
func (mmGetRegistry *RegistryClientMock) GetRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistry.beforeGetRegistryCounter)
}

// MinimockGetRegistryDone returns true if the count of the GetRegistry invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetRegistryDone() bool {
	if m.GetRegistryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRegistryMock.invocationsDone()
}

// MinimockGetRegistryInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetRegistryInspect() {
	for _, e := range m.GetRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryClientMock.GetRegistry")
		}
	}

	afterGetRegistryCounter := mm_atomic.LoadUint64(&m.afterGetRegistryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRegistryMock.defaultExpectation != nil && afterGetRegistryCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetRegistry at\n%s", m.GetRegistryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRegistry != nil && afterGetRegistryCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetRegistry at\n%s", m.funcGetRegistryOrigin)
	}

	if !m.GetRegistryMock.invocationsDone() && afterGetRegistryCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetRegistry at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRegistryMock.expectedInvocations), m.GetRegistryMock.expectedInvocationsOrigin, afterGetRegistryCounter)
	}
}

type mRegistryClientMockListRepositories struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListRepositoriesExpectation
	expectations       []*RegistryClientMockListRepositoriesExpectation

	callArgs []*RegistryClientMockListRepositoriesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListRepositoriesExpectation specifies expectation struct of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListRepositoriesParams
	paramPtrs          *RegistryClientMockListRepositoriesParamPtrs
	expectationOrigins RegistryClientMockListRepositoriesExpectationOrigins
	results            *RegistryClientMockListRepositoriesResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListRepositoriesParams contains parameters of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesParams struct {
	ctx context.Context
}

// RegistryClientMockListRepositoriesParamPtrs contains pointers to parameters of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesParamPtrs struct {
	ctx *context.Context
}

// RegistryClientMockListRepositoriesResults contains results of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesResults struct {
	sa1 []string
	err error
}

// RegistryClientMockListRepositoriesOrigins contains origins of expectations of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListRepositories *mRegistryClientMockListRepositories) Optional() *mRegistryClientMockListRepositories {
	mmListRepositories.optional = true
	return mmListRepositories
}

// Expect sets up expected params for RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Expect(ctx context.Context) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{}
	}

	if mmListRepositories.defaultExpectation.paramPtrs != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by ExpectParams functions")
	}

	mmListRepositories.defaultExpectation.params = &RegistryClientMockListRepositoriesParams{ctx}
	mmListRepositories.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListRepositories.expectations {
		if minimock.Equal(e.params, mmListRepositories.defaultExpectation.params) {
			mmListRepositories.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListRepositories.defaultExpectation.params)
		}
	}

	return mmListRepositories
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{}
	}

	if mmListRepositories.defaultExpectation.params != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Expect")
	}

	if mmListRepositories.defaultExpectation.paramPtrs == nil {
		mmListRepositories.defaultExpectation.paramPtrs = &RegistryClientMockListRepositoriesParamPtrs{}
	}
	mmListRepositories.defaultExpectation.paramPtrs.ctx = &ctx
	mmListRepositories.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListRepositories
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Inspect(f func(ctx context.Context)) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.inspectFuncListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListRepositories")
	}

	mmListRepositories.mock.inspectFuncListRepositories = f

	return mmListRepositories
}

// Return sets up results that will be returned by RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Return(sa1 []string, err error) *RegistryClientMock {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{mock: mmListRepositories.mock}
	}
	mmListRepositories.defaultExpectation.results = &RegistryClientMockListRepositoriesResults{sa1, err}
	mmListRepositories.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListRepositories.mock
}

// Set uses given function f to mock the RegistryClient.ListRepositories method
func (mmListRepositories *mRegistryClientMockListRepositories) Set(f func(ctx context.Context) (sa1 []string, err error)) *RegistryClientMock {
	if mmListRepositories.defaultExpectation != nil {
		mmListRepositories.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ListRepositories method")
	}

	if len(mmListRepositories.expectations) > 0 {
		mmListRepositories.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ListRepositories method")
	}

	mmListRepositories.mock.funcListRepositories = f
	mmListRepositories.mock.funcListRepositoriesOrigin = minimock.CallerInfo(1)
	return mmListRepositories.mock
}

// When sets expectation for the RegistryClient.ListRepositories which will trigger the result defined by the following
// Then helper
func (mmListRepositories *mRegistryClientMockListRepositories) When(ctx context.Context) *RegistryClientMockListRepositoriesExpectation {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	expectation := &RegistryClientMockListRepositoriesExpectation{
		mock:               mmListRepositories.mock,
		params:             &RegistryClientMockListRepositoriesParams{ctx},
		expectationOrigins: RegistryClientMockListRepositoriesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListRepositories.expectations = append(mmListRepositories.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ListRepositories return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListRepositoriesExpectation) Then(sa1 []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListRepositoriesResults{sa1, err}
	return e.mock
}

// Times sets number of times RegistryClient.ListRepositories should be invoked
func (mmListRepositories *mRegistryClientMockListRepositories) Times(n uint64) *mRegistryClientMockListRepositories {
	if n == 0 {
		mmListRepositories.mock.t.Fatalf("Times of RegistryClientMock.ListRepositories mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListRepositories.expectedInvocations, n)
	mmListRepositories.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListRepositories
}

func (mmListRepositories *mRegistryClientMockListRepositories) invocationsDone() bool {
	if len(mmListRepositories.expectations) == 0 && mmListRepositories.defaultExpectation == nil && mmListRepositories.mock.funcListRepositories == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListRepositories.mock.afterListRepositoriesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListRepositories.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListRepositories implements mm_pkg.RegistryClient
func (mmListRepositories *RegistryClientMock) ListRepositories(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListRepositories.beforeListRepositoriesCounter, 1)
	defer mm_atomic.AddUint64(&mmListRepositories.afterListRepositoriesCounter, 1)

	mmListRepositories.t.Helper()

	if mmListRepositories.inspectFuncListRepositories != nil {
		mmListRepositories.inspectFuncListRepositories(ctx)
	}

	mm_params := RegistryClientMockListRepositoriesParams{ctx}

	// Record call args
	mmListRepositories.ListRepositoriesMock.mutex.Lock()
	mmListRepositories.ListRepositoriesMock.callArgs = append(mmListRepositories.ListRepositoriesMock.callArgs, &mm_params)
	mmListRepositories.ListRepositoriesMock.mutex.Unlock()

	for _, e := range mmListRepositories.ListRepositoriesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListRepositories.ListRepositoriesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListRepositories.ListRepositoriesMock.defaultExpectation.Counter, 1)
		mm_want := mmListRepositories.ListRepositoriesMock.defaultExpectation.params
		mm_want_ptrs := mmListRepositories.ListRepositoriesMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListRepositoriesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListRepositories.t.Errorf("RegistryClientMock.ListRepositories got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositories.ListRepositoriesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListRepositories.t.Errorf("RegistryClientMock.ListRepositories got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListRepositories.ListRepositoriesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListRepositories.ListRepositoriesMock.defaultExpectation.results
		if mm_results == nil {
			mmListRepositories.t.Fatal("No results are set for the RegistryClientMock.ListRepositories")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListRepositories.funcListRepositories != nil {
		return mmListRepositories.funcListRepositories(ctx)
	}
	mmListRepositories.t.Fatalf("Unexpected call to RegistryClientMock.ListRepositories. %v", ctx)
	return
}

// ListRepositoriesAfterCounter returns a count of finished RegistryClientMock.ListRepositories invocations
func (mmListRepositories *RegistryClientMock) ListRepositoriesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositories.afterListRepositoriesCounter)
}

// ListRepositoriesBeforeCounter returns a count of RegistryClientMock.ListRepositories invocations
func (mmListRepositories *RegistryClientMock) ListRepositoriesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositories.beforeListRepositoriesCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListRepositories.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListRepositories *mRegistryClientMockListRepositories) Calls() []*RegistryClientMockListRepositoriesParams {
	mmListRepositories.mutex.RLock()

	argCopy := make([]*RegistryClientMockListRepositoriesParams, len(mmListRepositories.callArgs))
	copy(argCopy, mmListRepositories.callArgs)

	mmListRepositories.mutex.RUnlock()

	return argCopy
}

// MinimockListRepositoriesDone returns true if the count of the ListRepositories invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListRepositoriesDone() bool {
	if m.ListRepositoriesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListRepositoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListRepositoriesMock.invocationsDone()
}

// MinimockListRepositoriesInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListRepositoriesInspect() {
	for _, e := range m.ListRepositoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListRepositoriesCounter := mm_atomic.LoadUint64(&m.afterListRepositoriesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListRepositoriesMock.defaultExpectation != nil && afterListRepositoriesCounter < 1 {
		if m.ListRepositoriesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s", m.ListRepositoriesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s with params: %#v", m.ListRepositoriesMock.defaultExpectation.expectationOrigins.origin, *m.ListRepositoriesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListRepositories != nil && afterListRepositoriesCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s", m.funcListRepositoriesOrigin)
	}

	if !m.ListRepositoriesMock.invocationsDone() && afterListRepositoriesCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListRepositories at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListRepositoriesMock.expectedInvocations), m.ListRepositoriesMock.expectedInvocationsOrigin, afterListRepositoriesCounter)
	}
}

type mRegistryClientMockListTags struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListTagsExpectation
	expectations       []*RegistryClientMockListTagsExpectation

	callArgs []*RegistryClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListTagsExpectation specifies expectation struct of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListTagsParams
	paramPtrs          *RegistryClientMockListTagsParamPtrs
	expectationOrigins RegistryClientMockListTagsExpectationOrigins
	results            *RegistryClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListTagsParams contains parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParams struct {
	ctx context.Context
}

// RegistryClientMockListTagsParamPtrs contains pointers to parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParamPtrs struct {
	ctx *context.Context
}

// RegistryClientMockListTagsResults contains results of the RegistryClient.ListTags
type RegistryClientMockListTagsResults struct {
	sa1 []string
	err error
}

// RegistryClientMockListTagsOrigins contains origins of expectations of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mRegistryClientMockListTags) Optional() *mRegistryClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Expect(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &RegistryClientMockListTagsParams{ctx}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Inspect(f func(ctx context.Context)) *mRegistryClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Return(sa1 []string, err error) *RegistryClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &RegistryClientMockListTagsResults{sa1, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the RegistryClient.ListTags method
func (mmListTags *mRegistryClientMockListTags) Set(f func(ctx context.Context) (sa1 []string, err error)) *RegistryClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the RegistryClient.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mRegistryClientMockListTags) When(ctx context.Context) *RegistryClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	expectation := &RegistryClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &RegistryClientMockListTagsParams{ctx},
		expectationOrigins: RegistryClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ListTags return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListTagsExpectation) Then(sa1 []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListTagsResults{sa1, err}
	return e.mock
}

// Times sets number of times RegistryClient.ListTags should be invoked
func (mmListTags *mRegistryClientMockListTags) Times(n uint64) *mRegistryClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of RegistryClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mRegistryClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements mm_pkg.RegistryClient
func (mmListTags *RegistryClientMock) ListTags(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx)
	}

	mm_params := RegistryClientMockListTagsParams{ctx}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListTagsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the RegistryClientMock.ListTags")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx)
	}
	mmListTags.t.Fatalf("Unexpected call to RegistryClientMock.ListTags. %v", ctx)
	return
}

// ListTagsAfterCounter returns a count of finished RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mRegistryClientMockListTags) Calls() []*RegistryClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*RegistryClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

type mRegistryClientMockPushImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockPushImageExpectation
	expectations       []*RegistryClientMockPushImageExpectation

	callArgs []*RegistryClientMockPushImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockPushImageExpectation specifies expectation struct of the RegistryClient.PushImage
type RegistryClientMockPushImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockPushImageParams
	paramPtrs          *RegistryClientMockPushImageParamPtrs
	expectationOrigins RegistryClientMockPushImageExpectationOrigins
	results            *RegistryClientMockPushImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockPushImageParams contains parameters of the RegistryClient.PushImage
type RegistryClientMockPushImageParams struct {
	ctx context.Context
	tag string
	img mm_pkg.RegistryImage
}

// RegistryClientMockPushImageParamPtrs contains pointers to parameters of the RegistryClient.PushImage
type RegistryClientMockPushImageParamPtrs struct {
	ctx *context.Context
	tag *string
	img *mm_pkg.RegistryImage
}

// RegistryClientMockPushImageResults contains results of the RegistryClient.PushImage
type RegistryClientMockPushImageResults struct {
	err error
}

// RegistryClientMockPushImageOrigins contains origins of expectations of the RegistryClient.PushImage
type RegistryClientMockPushImageExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
	originImg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPushImage *mRegistryClientMockPushImage) Optional() *mRegistryClientMockPushImage {
	mmPushImage.optional = true
	return mmPushImage
}

// Expect sets up expected params for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Expect(ctx context.Context, tag string, img mm_pkg.RegistryImage) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.paramPtrs != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by ExpectParams functions")
	}

	mmPushImage.defaultExpectation.params = &RegistryClientMockPushImageParams{ctx, tag, img}
	mmPushImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPushImage.expectations {
		if minimock.Equal(e.params, mmPushImage.defaultExpectation.params) {
			mmPushImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPushImage.defaultExpectation.params)
		}
	}

	return mmPushImage
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmPushImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPushImage
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectTagParam2(tag string) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.tag = &tag
	mmPushImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmPushImage
}

// ExpectImgParam3 sets up expected param img for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectImgParam3(img mm_pkg.RegistryImage) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.img = &img
	mmPushImage.defaultExpectation.expectationOrigins.originImg = minimock.CallerInfo(1)

	return mmPushImage
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Inspect(f func(ctx context.Context, tag string, img mm_pkg.RegistryImage)) *mRegistryClientMockPushImage {
	if mmPushImage.mock.inspectFuncPushImage != nil {
		mmPushImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.PushImage")
	}

	mmPushImage.mock.inspectFuncPushImage = f

	return mmPushImage
}

// Return sets up results that will be returned by RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Return(err error) *RegistryClientMock {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{mock: mmPushImage.mock}
	}
	mmPushImage.defaultExpectation.results = &RegistryClientMockPushImageResults{err}
	mmPushImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPushImage.mock
}

// Set uses given function f to mock the RegistryClient.PushImage method
func (mmPushImage *mRegistryClientMockPushImage) Set(f func(ctx context.Context, tag string, img mm_pkg.RegistryImage) (err error)) *RegistryClientMock {
	if mmPushImage.defaultExpectation != nil {
		mmPushImage.mock.t.Fatalf("Default expectation is already set for the RegistryClient.PushImage method")
	}

	if len(mmPushImage.expectations) > 0 {
		mmPushImage.mock.t.Fatalf("Some expectations are already set for the RegistryClient.PushImage method")
	}

	mmPushImage.mock.funcPushImage = f
	mmPushImage.mock.funcPushImageOrigin = minimock.CallerInfo(1)
	return mmPushImage.mock
}

// When sets expectation for the RegistryClient.PushImage which will trigger the result defined by the following
// Then helper
func (mmPushImage *mRegistryClientMockPushImage) When(ctx context.Context, tag string, img mm_pkg.RegistryImage) *RegistryClientMockPushImageExpectation {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	expectation := &RegistryClientMockPushImageExpectation{
		mock:               mmPushImage.mock,
		params:             &RegistryClientMockPushImageParams{ctx, tag, img},
		expectationOrigins: RegistryClientMockPushImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPushImage.expectations = append(mmPushImage.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.PushImage return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockPushImageExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockPushImageResults{err}
	return e.mock
}

// Times sets number of times RegistryClient.PushImage should be invoked
func (mmPushImage *mRegistryClientMockPushImage) Times(n uint64) *mRegistryClientMockPushImage {
	if n == 0 {
		mmPushImage.mock.t.Fatalf("Times of RegistryClientMock.PushImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPushImage.expectedInvocations, n)
	mmPushImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPushImage
}

func (mmPushImage *mRegistryClientMockPushImage) invocationsDone() bool {
	if len(mmPushImage.expectations) == 0 && mmPushImage.defaultExpectation == nil && mmPushImage.mock.funcPushImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPushImage.mock.afterPushImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPushImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PushImage implements mm_pkg.RegistryClient
func (mmPushImage *RegistryClientMock) PushImage(ctx context.Context, tag string, img mm_pkg.RegistryImage) (err error) {
	mm_atomic.AddUint64(&mmPushImage.beforePushImageCounter, 1)
	defer mm_atomic.AddUint64(&mmPushImage.afterPushImageCounter, 1)

	mmPushImage.t.Helper()

	if mmPushImage.inspectFuncPushImage != nil {
		mmPushImage.inspectFuncPushImage(ctx, tag, img)
	}

	mm_params := RegistryClientMockPushImageParams{ctx, tag, img}

	// Record call args
	mmPushImage.PushImageMock.mutex.Lock()
	mmPushImage.PushImageMock.callArgs = append(mmPushImage.PushImageMock.callArgs, &mm_params)
	mmPushImage.PushImageMock.mutex.Unlock()

	for _, e := range mmPushImage.PushImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPushImage.PushImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPushImage.PushImageMock.defaultExpectation.Counter, 1)
		mm_want := mmPushImage.PushImageMock.defaultExpectation.params
		mm_want_ptrs := mmPushImage.PushImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockPushImageParams{ctx, tag, img}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.img != nil && !minimock.Equal(*mm_want_ptrs.img, mm_got.img) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter img, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originImg, *mm_want_ptrs.img, mm_got.img, minimock.Diff(*mm_want_ptrs.img, mm_got.img))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPushImage.PushImageMock.defaultExpectation.results
		if mm_results == nil {
			mmPushImage.t.Fatal("No results are set for the RegistryClientMock.PushImage")
		}
		return (*mm_results).err
	}
	if mmPushImage.funcPushImage != nil {
		return mmPushImage.funcPushImage(ctx, tag, img)
	}
	mmPushImage.t.Fatalf("Unexpected call to RegistryClientMock.PushImage. %v %v %v", ctx, tag, img)
	return
}

// PushImageAfterCounter returns a count of finished RegistryClientMock.PushImage invocations
func (mmPushImage *RegistryClientMock) PushImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushImage.afterPushImageCounter)
}

// PushImageBeforeCounter returns a count of RegistryClientMock.PushImage invocations
func (mmPushImage *RegistryClientMock) PushImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushImage.beforePushImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.PushImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPushImage *mRegistryClientMockPushImage) Calls() []*RegistryClientMockPushImageParams {
	mmPushImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockPushImageParams, len(mmPushImage.callArgs))
	copy(argCopy, mmPushImage.callArgs)

	mmPushImage.mutex.RUnlock()

	return argCopy
}

// MinimockPushImageDone returns true if the count of the PushImage invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockPushImageDone() bool {
	if m.PushImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PushImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PushImageMock.invocationsDone()
}

// MinimockPushImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockPushImageInspect() {
	for _, e := range m.PushImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPushImageCounter := mm_atomic.LoadUint64(&m.afterPushImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PushImageMock.defaultExpectation != nil && afterPushImageCounter < 1 {
		if m.PushImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s", m.PushImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s with params: %#v", m.PushImageMock.defaultExpectation.expectationOrigins.origin, *m.PushImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPushImage != nil && afterPushImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s", m.funcPushImageOrigin)
	}

	if !m.PushImageMock.invocationsDone() && afterPushImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.PushImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PushImageMock.expectedInvocations), m.PushImageMock.expectedInvocationsOrigin, afterPushImageCounter)
	}
}

type mRegistryClientMockWithSegment struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockWithSegmentExpectation
	expectations       []*RegistryClientMockWithSegmentExpectation

	callArgs []*RegistryClientMockWithSegmentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockWithSegmentExpectation specifies expectation struct of the RegistryClient.WithSegment
type RegistryClientMockWithSegmentExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockWithSegmentParams
	paramPtrs          *RegistryClientMockWithSegmentParamPtrs
	expectationOrigins RegistryClientMockWithSegmentExpectationOrigins
	results            *RegistryClientMockWithSegmentResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockWithSegmentParams contains parameters of the RegistryClient.WithSegment
type RegistryClientMockWithSegmentParams struct {
	segments []string
}

// RegistryClientMockWithSegmentParamPtrs contains pointers to parameters of the RegistryClient.WithSegment
type RegistryClientMockWithSegmentParamPtrs struct {
	segments *[]string
}

// RegistryClientMockWithSegmentResults contains results of the RegistryClient.WithSegment
type RegistryClientMockWithSegmentResults struct {
	r1 mm_pkg.RegistryClient
}

// RegistryClientMockWithSegmentOrigins contains origins of expectations of the RegistryClient.WithSegment
type RegistryClientMockWithSegmentExpectationOrigins struct {
	origin         string
	originSegments string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithSegment *mRegistryClientMockWithSegment) Optional() *mRegistryClientMockWithSegment {
	mmWithSegment.optional = true
	return mmWithSegment
}

// Expect sets up expected params for RegistryClient.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) Expect(segments ...string) *mRegistryClientMockWithSegment {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	if mmWithSegment.defaultExpectation == nil {
		mmWithSegment.defaultExpectation = &RegistryClientMockWithSegmentExpectation{}
	}

	if mmWithSegment.defaultExpectation.paramPtrs != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by ExpectParams functions")
	}

	mmWithSegment.defaultExpectation.params = &RegistryClientMockWithSegmentParams{segments}
	mmWithSegment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithSegment.expectations {
		if minimock.Equal(e.params, mmWithSegment.defaultExpectation.params) {
			mmWithSegment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithSegment.defaultExpectation.params)
		}
	}

	return mmWithSegment
}

// ExpectSegmentsParam1 sets up expected param segments for RegistryClient.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) ExpectSegmentsParam1(segments ...string) *mRegistryClientMockWithSegment {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	if mmWithSegment.defaultExpectation == nil {
		mmWithSegment.defaultExpectation = &RegistryClientMockWithSegmentExpectation{}
	}

	if mmWithSegment.defaultExpectation.params != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Expect")
	}

	if mmWithSegment.defaultExpectation.paramPtrs == nil {
		mmWithSegment.defaultExpectation.paramPtrs = &RegistryClientMockWithSegmentParamPtrs{}
	}
	mmWithSegment.defaultExpectation.paramPtrs.segments = &segments
	mmWithSegment.defaultExpectation.expectationOrigins.originSegments = minimock.CallerInfo(1)

	return mmWithSegment
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) Inspect(f func(segments ...string)) *mRegistryClientMockWithSegment {
	if mmWithSegment.mock.inspectFuncWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.WithSegment")
	}

	mmWithSegment.mock.inspectFuncWithSegment = f

	return mmWithSegment
}

// Return sets up results that will be returned by RegistryClient.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) Return(r1 mm_pkg.RegistryClient) *RegistryClientMock {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	if mmWithSegment.defaultExpectation == nil {
		mmWithSegment.defaultExpectation = &RegistryClientMockWithSegmentExpectation{mock: mmWithSegment.mock}
	}
	mmWithSegment.defaultExpectation.results = &RegistryClientMockWithSegmentResults{r1}
	mmWithSegment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithSegment.mock
}

// Set uses given function f to mock the RegistryClient.WithSegment method
func (mmWithSegment *mRegistryClientMockWithSegment) Set(f func(segments ...string) (r1 mm_pkg.RegistryClient)) *RegistryClientMock {
	if mmWithSegment.defaultExpectation != nil {
		mmWithSegment.mock.t.Fatalf("Default expectation is already set for the RegistryClient.WithSegment method")
	}

	if len(mmWithSegment.expectations) > 0 {
		mmWithSegment.mock.t.Fatalf("Some expectations are already set for the RegistryClient.WithSegment method")
	}

	mmWithSegment.mock.funcWithSegment = f
	mmWithSegment.mock.funcWithSegmentOrigin = minimock.CallerInfo(1)
	return mmWithSegment.mock
}

// When sets expectation for the RegistryClient.WithSegment which will trigger the result defined by the following
// Then helper
func (mmWithSegment *mRegistryClientMockWithSegment) When(segments ...string) *RegistryClientMockWithSegmentExpectation {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	expectation := &RegistryClientMockWithSegmentExpectation{
		mock:               mmWithSegment.mock,
		params:             &RegistryClientMockWithSegmentParams{segments},
		expectationOrigins: RegistryClientMockWithSegmentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithSegment.expectations = append(mmWithSegment.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.WithSegment return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockWithSegmentExpectation) Then(r1 mm_pkg.RegistryClient) *RegistryClientMock {
	e.results = &RegistryClientMockWithSegmentResults{r1}
	return e.mock
}

// Times sets number of times RegistryClient.WithSegment should be invoked
func (mmWithSegment *mRegistryClientMockWithSegment) Times(n uint64) *mRegistryClientMockWithSegment {
	if n == 0 {
		mmWithSegment.mock.t.Fatalf("Times of RegistryClientMock.WithSegment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithSegment.expectedInvocations, n)
	mmWithSegment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithSegment
}

func (mmWithSegment *mRegistryClientMockWithSegment) invocationsDone() bool {
	if len(mmWithSegment.expectations) == 0 && mmWithSegment.defaultExpectation == nil && mmWithSegment.mock.funcWithSegment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithSegment.mock.afterWithSegmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithSegment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithSegment implements mm_pkg.RegistryClient
func (mmWithSegment *RegistryClientMock) WithSegment(segments ...string) (r1 mm_pkg.RegistryClient) {
	mm_atomic.AddUint64(&mmWithSegment.beforeWithSegmentCounter, 1)
	defer mm_atomic.AddUint64(&mmWithSegment.afterWithSegmentCounter, 1)

	mmWithSegment.t.Helper()

	if mmWithSegment.inspectFuncWithSegment != nil {
		mmWithSegment.inspectFuncWithSegment(segments...)
	}

	mm_params := RegistryClientMockWithSegmentParams{segments}

	// Record call args
	mmWithSegment.WithSegmentMock.mutex.Lock()
	mmWithSegment.WithSegmentMock.callArgs = append(mmWithSegment.WithSegmentMock.callArgs, &mm_params)
	mmWithSegment.WithSegmentMock.mutex.Unlock()

	for _, e := range mmWithSegment.WithSegmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmWithSegment.WithSegmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithSegment.WithSegmentMock.defaultExpectation.Counter, 1)
		mm_want := mmWithSegment.WithSegmentMock.defaultExpectation.params
		mm_want_ptrs := mmWithSegment.WithSegmentMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockWithSegmentParams{segments}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.segments != nil && !minimock.Equal(*mm_want_ptrs.segments, mm_got.segments) {
				mmWithSegment.t.Errorf("RegistryClientMock.WithSegment got unexpected parameter segments, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithSegment.WithSegmentMock.defaultExpectation.expectationOrigins.originSegments, *mm_want_ptrs.segments, mm_got.segments, minimock.Diff(*mm_want_ptrs.segments, mm_got.segments))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithSegment.t.Errorf("RegistryClientMock.WithSegment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithSegment.WithSegmentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithSegment.WithSegmentMock.defaultExpectation.results
		if mm_results == nil {
			mmWithSegment.t.Fatal("No results are set for the RegistryClientMock.WithSegment")
		}
		return (*mm_results).r1
	}
	if mmWithSegment.funcWithSegment != nil {
		return mmWithSegment.funcWithSegment(segments...)
	}
	mmWithSegment.t.Fatalf("Unexpected call to RegistryClientMock.WithSegment. %v", segments)
	return
}

// WithSegmentAfterCounter returns a count of finished RegistryClientMock.WithSegment invocations
func (mmWithSegment *RegistryClientMock) WithSegmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithSegment.afterWithSegmentCounter)
}

// WithSegmentBeforeCounter returns a count of RegistryClientMock.WithSegment invocations
func (mmWithSegment *RegistryClientMock) WithSegmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithSegment.beforeWithSegmentCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.WithSegment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithSegment *mRegistryClientMockWithSegment) Calls() []*RegistryClientMockWithSegmentParams {
	mmWithSegment.mutex.RLock()

	argCopy := make([]*RegistryClientMockWithSegmentParams, len(mmWithSegment.callArgs))
	copy(argCopy, mmWithSegment.callArgs)

	mmWithSegment.mutex.RUnlock()

	return argCopy
}

// MinimockWithSegmentDone returns true if the count of the WithSegment invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockWithSegmentDone() bool {
	if m.WithSegmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithSegmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithSegmentMock.invocationsDone()
}

// MinimockWithSegmentInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockWithSegmentInspect() {
	for _, e := range m.WithSegmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithSegmentCounter := mm_atomic.LoadUint64(&m.afterWithSegmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithSegmentMock.defaultExpectation != nil && afterWithSegmentCounter < 1 {
		if m.WithSegmentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s", m.WithSegmentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s with params: %#v", m.WithSegmentMock.defaultExpectation.expectationOrigins.origin, *m.WithSegmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithSegment != nil && afterWithSegmentCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s", m.funcWithSegmentOrigin)
	}

	if !m.WithSegmentMock.invocationsDone() && afterWithSegmentCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.WithSegment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithSegmentMock.expectedInvocations), m.WithSegmentMock.expectedInvocationsOrigin, afterWithSegmentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetDigestInspect()

			m.MinimockGetImageInspect()

			m.MinimockGetImageConfigInspect()

			m.MinimockGetManifestInspect()

			m.MinimockGetRegistryInspect()

			m.MinimockListRepositoriesInspect()

			m.MinimockListTagsInspect()

			m.MinimockPushImageInspect()

			m.MinimockWithSegmentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDigestDone() &&
		m.MinimockGetImageDone() &&
		m.MinimockGetImageConfigDone() &&
		m.MinimockGetManifestDone() &&
		m.MinimockGetRegistryDone() &&
		m.MinimockListRepositoriesDone() &&
		m.MinimockListTagsDone() &&
		m.MinimockPushImageDone() &&
		m.MinimockWithSegmentDone()
}
