// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/deckhouse-cli/pkg.RegistryClient -o registry_client_mock.go -n RegistryClientMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_pkg "github.com/deckhouse/deckhouse-cli/pkg"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/remote"
)

// RegistryClientMock implements mm_pkg.RegistryClient
type RegistryClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExtractImageLayers          func(ctx context.Context, tag string, handler func(mm_pkg.LayerStream) error) (err error)
	funcExtractImageLayersOrigin    string
	inspectFuncExtractImageLayers   func(ctx context.Context, tag string, handler func(mm_pkg.LayerStream) error)
	afterExtractImageLayersCounter  uint64
	beforeExtractImageLayersCounter uint64
	ExtractImageLayersMock          mRegistryClientMockExtractImageLayers

	funcGetImage          func(ctx context.Context, tag string) (i1 v1.Image, err error)
	funcGetImageOrigin    string
	inspectFuncGetImage   func(ctx context.Context, tag string)
	afterGetImageCounter  uint64
	beforeGetImageCounter uint64
	GetImageMock          mRegistryClientMockGetImage

	funcGetImageConfig          func(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error)
	funcGetImageConfigOrigin    string
	inspectFuncGetImageConfig   func(ctx context.Context, tag string)
	afterGetImageConfigCounter  uint64
	beforeGetImageConfigCounter uint64
	GetImageConfigMock          mRegistryClientMockGetImageConfig

	funcGetImageLayers          func(ctx context.Context, tag string) (la1 []v1.Layer, err error)
	funcGetImageLayersOrigin    string
	inspectFuncGetImageLayers   func(ctx context.Context, tag string)
	afterGetImageLayersCounter  uint64
	beforeGetImageLayersCounter uint64
	GetImageLayersMock          mRegistryClientMockGetImageLayers

	funcGetLabel          func(ctx context.Context, tag string, labelKey string) (s1 string, b1 bool, err error)
	funcGetLabelOrigin    string
	inspectFuncGetLabel   func(ctx context.Context, tag string, labelKey string)
	afterGetLabelCounter  uint64
	beforeGetLabelCounter uint64
	GetLabelMock          mRegistryClientMockGetLabel

	funcGetManifest          func(ctx context.Context, tag string) (dp1 *remote.Descriptor, err error)
	funcGetManifestOrigin    string
	inspectFuncGetManifest   func(ctx context.Context, tag string)
	afterGetManifestCounter  uint64
	beforeGetManifestCounter uint64
	GetManifestMock          mRegistryClientMockGetManifest

	funcGetRegistry          func() (s1 string)
	funcGetRegistryOrigin    string
	inspectFuncGetRegistry   func()
	afterGetRegistryCounter  uint64
	beforeGetRegistryCounter uint64
	GetRegistryMock          mRegistryClientMockGetRegistry

	funcListRepositories          func(ctx context.Context) (sa1 []string, err error)
	funcListRepositoriesOrigin    string
	inspectFuncListRepositories   func(ctx context.Context)
	afterListRepositoriesCounter  uint64
	beforeListRepositoriesCounter uint64
	ListRepositoriesMock          mRegistryClientMockListRepositories

	funcListTags          func(ctx context.Context) (sa1 []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mRegistryClientMockListTags

	funcPushImage          func(ctx context.Context, tag string, img v1.Image) (err error)
	funcPushImageOrigin    string
	inspectFuncPushImage   func(ctx context.Context, tag string, img v1.Image)
	afterPushImageCounter  uint64
	beforePushImageCounter uint64
	PushImageMock          mRegistryClientMockPushImage

	funcWithScope          func(scope string) (r1 mm_pkg.RegistryClient)
	funcWithScopeOrigin    string
	inspectFuncWithScope   func(scope string)
	afterWithScopeCounter  uint64
	beforeWithScopeCounter uint64
	WithScopeMock          mRegistryClientMockWithScope
}

// NewRegistryClientMock returns a mock for mm_pkg.RegistryClient
func NewRegistryClientMock(t minimock.Tester) *RegistryClientMock {
	m := &RegistryClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExtractImageLayersMock = mRegistryClientMockExtractImageLayers{mock: m}
	m.ExtractImageLayersMock.callArgs = []*RegistryClientMockExtractImageLayersParams{}

	m.GetImageMock = mRegistryClientMockGetImage{mock: m}
	m.GetImageMock.callArgs = []*RegistryClientMockGetImageParams{}

	m.GetImageConfigMock = mRegistryClientMockGetImageConfig{mock: m}
	m.GetImageConfigMock.callArgs = []*RegistryClientMockGetImageConfigParams{}

	m.GetImageLayersMock = mRegistryClientMockGetImageLayers{mock: m}
	m.GetImageLayersMock.callArgs = []*RegistryClientMockGetImageLayersParams{}

	m.GetLabelMock = mRegistryClientMockGetLabel{mock: m}
	m.GetLabelMock.callArgs = []*RegistryClientMockGetLabelParams{}

	m.GetManifestMock = mRegistryClientMockGetManifest{mock: m}
	m.GetManifestMock.callArgs = []*RegistryClientMockGetManifestParams{}

	m.GetRegistryMock = mRegistryClientMockGetRegistry{mock: m}

	m.ListRepositoriesMock = mRegistryClientMockListRepositories{mock: m}
	m.ListRepositoriesMock.callArgs = []*RegistryClientMockListRepositoriesParams{}

	m.ListTagsMock = mRegistryClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*RegistryClientMockListTagsParams{}

	m.PushImageMock = mRegistryClientMockPushImage{mock: m}
	m.PushImageMock.callArgs = []*RegistryClientMockPushImageParams{}

	m.WithScopeMock = mRegistryClientMockWithScope{mock: m}
	m.WithScopeMock.callArgs = []*RegistryClientMockWithScopeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryClientMockExtractImageLayers struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockExtractImageLayersExpectation
	expectations       []*RegistryClientMockExtractImageLayersExpectation

	callArgs []*RegistryClientMockExtractImageLayersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockExtractImageLayersExpectation specifies expectation struct of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockExtractImageLayersParams
	paramPtrs          *RegistryClientMockExtractImageLayersParamPtrs
	expectationOrigins RegistryClientMockExtractImageLayersExpectationOrigins
	results            *RegistryClientMockExtractImageLayersResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockExtractImageLayersParams contains parameters of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersParams struct {
	ctx     context.Context
	tag     string
	handler func(mm_pkg.LayerStream) error
}

// RegistryClientMockExtractImageLayersParamPtrs contains pointers to parameters of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersParamPtrs struct {
	ctx     *context.Context
	tag     *string
	handler *func(mm_pkg.LayerStream) error
}

// RegistryClientMockExtractImageLayersResults contains results of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersResults struct {
	err error
}

// RegistryClientMockExtractImageLayersOrigins contains origins of expectations of the RegistryClient.ExtractImageLayers
type RegistryClientMockExtractImageLayersExpectationOrigins struct {
	origin        string
	originCtx     string
	originTag     string
	originHandler string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Optional() *mRegistryClientMockExtractImageLayers {
	mmExtractImageLayers.optional = true
	return mmExtractImageLayers
}

// Expect sets up expected params for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Expect(ctx context.Context, tag string, handler func(mm_pkg.LayerStream) error) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by ExpectParams functions")
	}

	mmExtractImageLayers.defaultExpectation.params = &RegistryClientMockExtractImageLayersParams{ctx, tag, handler}
	mmExtractImageLayers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExtractImageLayers.expectations {
		if minimock.Equal(e.params, mmExtractImageLayers.defaultExpectation.params) {
			mmExtractImageLayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExtractImageLayers.defaultExpectation.params)
		}
	}

	return mmExtractImageLayers
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.params != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Expect")
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs == nil {
		mmExtractImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockExtractImageLayersParamPtrs{}
	}
	mmExtractImageLayers.defaultExpectation.paramPtrs.ctx = &ctx
	mmExtractImageLayers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExtractImageLayers
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) ExpectTagParam2(tag string) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.params != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Expect")
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs == nil {
		mmExtractImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockExtractImageLayersParamPtrs{}
	}
	mmExtractImageLayers.defaultExpectation.paramPtrs.tag = &tag
	mmExtractImageLayers.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmExtractImageLayers
}

// ExpectHandlerParam3 sets up expected param handler for RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) ExpectHandlerParam3(handler func(mm_pkg.LayerStream) error) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{}
	}

	if mmExtractImageLayers.defaultExpectation.params != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Expect")
	}

	if mmExtractImageLayers.defaultExpectation.paramPtrs == nil {
		mmExtractImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockExtractImageLayersParamPtrs{}
	}
	mmExtractImageLayers.defaultExpectation.paramPtrs.handler = &handler
	mmExtractImageLayers.defaultExpectation.expectationOrigins.originHandler = minimock.CallerInfo(1)

	return mmExtractImageLayers
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Inspect(f func(ctx context.Context, tag string, handler func(mm_pkg.LayerStream) error)) *mRegistryClientMockExtractImageLayers {
	if mmExtractImageLayers.mock.inspectFuncExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ExtractImageLayers")
	}

	mmExtractImageLayers.mock.inspectFuncExtractImageLayers = f

	return mmExtractImageLayers
}

// Return sets up results that will be returned by RegistryClient.ExtractImageLayers
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Return(err error) *RegistryClientMock {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	if mmExtractImageLayers.defaultExpectation == nil {
		mmExtractImageLayers.defaultExpectation = &RegistryClientMockExtractImageLayersExpectation{mock: mmExtractImageLayers.mock}
	}
	mmExtractImageLayers.defaultExpectation.results = &RegistryClientMockExtractImageLayersResults{err}
	mmExtractImageLayers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExtractImageLayers.mock
}

// Set uses given function f to mock the RegistryClient.ExtractImageLayers method
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Set(f func(ctx context.Context, tag string, handler func(mm_pkg.LayerStream) error) (err error)) *RegistryClientMock {
	if mmExtractImageLayers.defaultExpectation != nil {
		mmExtractImageLayers.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ExtractImageLayers method")
	}

	if len(mmExtractImageLayers.expectations) > 0 {
		mmExtractImageLayers.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ExtractImageLayers method")
	}

	mmExtractImageLayers.mock.funcExtractImageLayers = f
	mmExtractImageLayers.mock.funcExtractImageLayersOrigin = minimock.CallerInfo(1)
	return mmExtractImageLayers.mock
}

// When sets expectation for the RegistryClient.ExtractImageLayers which will trigger the result defined by the following
// Then helper
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) When(ctx context.Context, tag string, handler func(mm_pkg.LayerStream) error) *RegistryClientMockExtractImageLayersExpectation {
	if mmExtractImageLayers.mock.funcExtractImageLayers != nil {
		mmExtractImageLayers.mock.t.Fatalf("RegistryClientMock.ExtractImageLayers mock is already set by Set")
	}

	expectation := &RegistryClientMockExtractImageLayersExpectation{
		mock:               mmExtractImageLayers.mock,
		params:             &RegistryClientMockExtractImageLayersParams{ctx, tag, handler},
		expectationOrigins: RegistryClientMockExtractImageLayersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExtractImageLayers.expectations = append(mmExtractImageLayers.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ExtractImageLayers return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockExtractImageLayersExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockExtractImageLayersResults{err}
	return e.mock
}

// Times sets number of times RegistryClient.ExtractImageLayers should be invoked
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Times(n uint64) *mRegistryClientMockExtractImageLayers {
	if n == 0 {
		mmExtractImageLayers.mock.t.Fatalf("Times of RegistryClientMock.ExtractImageLayers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExtractImageLayers.expectedInvocations, n)
	mmExtractImageLayers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExtractImageLayers
}

func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) invocationsDone() bool {
	if len(mmExtractImageLayers.expectations) == 0 && mmExtractImageLayers.defaultExpectation == nil && mmExtractImageLayers.mock.funcExtractImageLayers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExtractImageLayers.mock.afterExtractImageLayersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExtractImageLayers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExtractImageLayers implements mm_pkg.RegistryClient
func (mmExtractImageLayers *RegistryClientMock) ExtractImageLayers(ctx context.Context, tag string, handler func(mm_pkg.LayerStream) error) (err error) {
	mm_atomic.AddUint64(&mmExtractImageLayers.beforeExtractImageLayersCounter, 1)
	defer mm_atomic.AddUint64(&mmExtractImageLayers.afterExtractImageLayersCounter, 1)

	mmExtractImageLayers.t.Helper()

	if mmExtractImageLayers.inspectFuncExtractImageLayers != nil {
		mmExtractImageLayers.inspectFuncExtractImageLayers(ctx, tag, handler)
	}

	mm_params := RegistryClientMockExtractImageLayersParams{ctx, tag, handler}

	// Record call args
	mmExtractImageLayers.ExtractImageLayersMock.mutex.Lock()
	mmExtractImageLayers.ExtractImageLayersMock.callArgs = append(mmExtractImageLayers.ExtractImageLayersMock.callArgs, &mm_params)
	mmExtractImageLayers.ExtractImageLayersMock.mutex.Unlock()

	for _, e := range mmExtractImageLayers.ExtractImageLayersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.Counter, 1)
		mm_want := mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.params
		mm_want_ptrs := mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockExtractImageLayersParams{ctx, tag, handler}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.handler != nil && !minimock.Equal(*mm_want_ptrs.handler, mm_got.handler) {
				mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameter handler, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.originHandler, *mm_want_ptrs.handler, mm_got.handler, minimock.Diff(*mm_want_ptrs.handler, mm_got.handler))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExtractImageLayers.t.Errorf("RegistryClientMock.ExtractImageLayers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExtractImageLayers.ExtractImageLayersMock.defaultExpectation.results
		if mm_results == nil {
			mmExtractImageLayers.t.Fatal("No results are set for the RegistryClientMock.ExtractImageLayers")
		}
		return (*mm_results).err
	}
	if mmExtractImageLayers.funcExtractImageLayers != nil {
		return mmExtractImageLayers.funcExtractImageLayers(ctx, tag, handler)
	}
	mmExtractImageLayers.t.Fatalf("Unexpected call to RegistryClientMock.ExtractImageLayers. %v %v %v", ctx, tag, handler)
	return
}

// ExtractImageLayersAfterCounter returns a count of finished RegistryClientMock.ExtractImageLayers invocations
func (mmExtractImageLayers *RegistryClientMock) ExtractImageLayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractImageLayers.afterExtractImageLayersCounter)
}

// ExtractImageLayersBeforeCounter returns a count of RegistryClientMock.ExtractImageLayers invocations
func (mmExtractImageLayers *RegistryClientMock) ExtractImageLayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExtractImageLayers.beforeExtractImageLayersCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ExtractImageLayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExtractImageLayers *mRegistryClientMockExtractImageLayers) Calls() []*RegistryClientMockExtractImageLayersParams {
	mmExtractImageLayers.mutex.RLock()

	argCopy := make([]*RegistryClientMockExtractImageLayersParams, len(mmExtractImageLayers.callArgs))
	copy(argCopy, mmExtractImageLayers.callArgs)

	mmExtractImageLayers.mutex.RUnlock()

	return argCopy
}

// MinimockExtractImageLayersDone returns true if the count of the ExtractImageLayers invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockExtractImageLayersDone() bool {
	if m.ExtractImageLayersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExtractImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExtractImageLayersMock.invocationsDone()
}

// MinimockExtractImageLayersInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockExtractImageLayersInspect() {
	for _, e := range m.ExtractImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExtractImageLayersCounter := mm_atomic.LoadUint64(&m.afterExtractImageLayersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExtractImageLayersMock.defaultExpectation != nil && afterExtractImageLayersCounter < 1 {
		if m.ExtractImageLayersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s", m.ExtractImageLayersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s with params: %#v", m.ExtractImageLayersMock.defaultExpectation.expectationOrigins.origin, *m.ExtractImageLayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExtractImageLayers != nil && afterExtractImageLayersCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ExtractImageLayers at\n%s", m.funcExtractImageLayersOrigin)
	}

	if !m.ExtractImageLayersMock.invocationsDone() && afterExtractImageLayersCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ExtractImageLayers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExtractImageLayersMock.expectedInvocations), m.ExtractImageLayersMock.expectedInvocationsOrigin, afterExtractImageLayersCounter)
	}
}

type mRegistryClientMockGetImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageExpectation
	expectations       []*RegistryClientMockGetImageExpectation

	callArgs []*RegistryClientMockGetImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageExpectation specifies expectation struct of the RegistryClient.GetImage
type RegistryClientMockGetImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageParams
	paramPtrs          *RegistryClientMockGetImageParamPtrs
	expectationOrigins RegistryClientMockGetImageExpectationOrigins
	results            *RegistryClientMockGetImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageParams contains parameters of the RegistryClient.GetImage
type RegistryClientMockGetImageParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetImageParamPtrs contains pointers to parameters of the RegistryClient.GetImage
type RegistryClientMockGetImageParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetImageResults contains results of the RegistryClient.GetImage
type RegistryClientMockGetImageResults struct {
	i1  v1.Image
	err error
}

// RegistryClientMockGetImageOrigins contains origins of expectations of the RegistryClient.GetImage
type RegistryClientMockGetImageExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImage *mRegistryClientMockGetImage) Optional() *mRegistryClientMockGetImage {
	mmGetImage.optional = true
	return mmGetImage
}

// Expect sets up expected params for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Expect(ctx context.Context, tag string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.paramPtrs != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by ExpectParams functions")
	}

	mmGetImage.defaultExpectation.params = &RegistryClientMockGetImageParams{ctx, tag}
	mmGetImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImage.expectations {
		if minimock.Equal(e.params, mmGetImage.defaultExpectation.params) {
			mmGetImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImage.defaultExpectation.params)
		}
	}

	return mmGetImage
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImage
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectTagParam2(tag string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.tag = &tag
	mmGetImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImage
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetImage {
	if mmGetImage.mock.inspectFuncGetImage != nil {
		mmGetImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImage")
	}

	mmGetImage.mock.inspectFuncGetImage = f

	return mmGetImage
}

// Return sets up results that will be returned by RegistryClient.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Return(i1 v1.Image, err error) *RegistryClientMock {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{mock: mmGetImage.mock}
	}
	mmGetImage.defaultExpectation.results = &RegistryClientMockGetImageResults{i1, err}
	mmGetImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// Set uses given function f to mock the RegistryClient.GetImage method
func (mmGetImage *mRegistryClientMockGetImage) Set(f func(ctx context.Context, tag string) (i1 v1.Image, err error)) *RegistryClientMock {
	if mmGetImage.defaultExpectation != nil {
		mmGetImage.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImage method")
	}

	if len(mmGetImage.expectations) > 0 {
		mmGetImage.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImage method")
	}

	mmGetImage.mock.funcGetImage = f
	mmGetImage.mock.funcGetImageOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// When sets expectation for the RegistryClient.GetImage which will trigger the result defined by the following
// Then helper
func (mmGetImage *mRegistryClientMockGetImage) When(ctx context.Context, tag string) *RegistryClientMockGetImageExpectation {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageExpectation{
		mock:               mmGetImage.mock,
		params:             &RegistryClientMockGetImageParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImage.expectations = append(mmGetImage.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImage return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageExpectation) Then(i1 v1.Image, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageResults{i1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImage should be invoked
func (mmGetImage *mRegistryClientMockGetImage) Times(n uint64) *mRegistryClientMockGetImage {
	if n == 0 {
		mmGetImage.mock.t.Fatalf("Times of RegistryClientMock.GetImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImage.expectedInvocations, n)
	mmGetImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImage
}

func (mmGetImage *mRegistryClientMockGetImage) invocationsDone() bool {
	if len(mmGetImage.expectations) == 0 && mmGetImage.defaultExpectation == nil && mmGetImage.mock.funcGetImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImage.mock.afterGetImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImage implements mm_pkg.RegistryClient
func (mmGetImage *RegistryClientMock) GetImage(ctx context.Context, tag string) (i1 v1.Image, err error) {
	mm_atomic.AddUint64(&mmGetImage.beforeGetImageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImage.afterGetImageCounter, 1)

	mmGetImage.t.Helper()

	if mmGetImage.inspectFuncGetImage != nil {
		mmGetImage.inspectFuncGetImage(ctx, tag)
	}

	mm_params := RegistryClientMockGetImageParams{ctx, tag}

	// Record call args
	mmGetImage.GetImageMock.mutex.Lock()
	mmGetImage.GetImageMock.callArgs = append(mmGetImage.GetImageMock.callArgs, &mm_params)
	mmGetImage.GetImageMock.mutex.Unlock()

	for _, e := range mmGetImage.GetImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetImage.GetImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImage.GetImageMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImage.GetImageMock.defaultExpectation.params
		mm_want_ptrs := mmGetImage.GetImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImage.GetImageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImage.t.Fatal("No results are set for the RegistryClientMock.GetImage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetImage.funcGetImage != nil {
		return mmGetImage.funcGetImage(ctx, tag)
	}
	mmGetImage.t.Fatalf("Unexpected call to RegistryClientMock.GetImage. %v %v", ctx, tag)
	return
}

// GetImageAfterCounter returns a count of finished RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.afterGetImageCounter)
}

// GetImageBeforeCounter returns a count of RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.beforeGetImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImage *mRegistryClientMockGetImage) Calls() []*RegistryClientMockGetImageParams {
	mmGetImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageParams, len(mmGetImage.callArgs))
	copy(argCopy, mmGetImage.callArgs)

	mmGetImage.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageDone returns true if the count of the GetImage invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageDone() bool {
	if m.GetImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageMock.invocationsDone()
}

// MinimockGetImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageInspect() {
	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageCounter := mm_atomic.LoadUint64(&m.afterGetImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageMock.defaultExpectation != nil && afterGetImageCounter < 1 {
		if m.GetImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.GetImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", m.GetImageMock.defaultExpectation.expectationOrigins.origin, *m.GetImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImage != nil && afterGetImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.funcGetImageOrigin)
	}

	if !m.GetImageMock.invocationsDone() && afterGetImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageMock.expectedInvocations), m.GetImageMock.expectedInvocationsOrigin, afterGetImageCounter)
	}
}

type mRegistryClientMockGetImageConfig struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageConfigExpectation
	expectations       []*RegistryClientMockGetImageConfigExpectation

	callArgs []*RegistryClientMockGetImageConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageConfigExpectation specifies expectation struct of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageConfigParams
	paramPtrs          *RegistryClientMockGetImageConfigParamPtrs
	expectationOrigins RegistryClientMockGetImageConfigExpectationOrigins
	results            *RegistryClientMockGetImageConfigResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageConfigParams contains parameters of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetImageConfigParamPtrs contains pointers to parameters of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetImageConfigResults contains results of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigResults struct {
	cp1 *v1.ConfigFile
	err error
}

// RegistryClientMockGetImageConfigOrigins contains origins of expectations of the RegistryClient.GetImageConfig
type RegistryClientMockGetImageConfigExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Optional() *mRegistryClientMockGetImageConfig {
	mmGetImageConfig.optional = true
	return mmGetImageConfig
}

// Expect sets up expected params for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Expect(ctx context.Context, tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by ExpectParams functions")
	}

	mmGetImageConfig.defaultExpectation.params = &RegistryClientMockGetImageConfigParams{ctx, tag}
	mmGetImageConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImageConfig.expectations {
		if minimock.Equal(e.params, mmGetImageConfig.defaultExpectation.params) {
			mmGetImageConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImageConfig.defaultExpectation.params)
		}
	}

	return mmGetImageConfig
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImageConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectTagParam2(tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.tag = &tag
	mmGetImageConfig.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImageConfig")
	}

	mmGetImageConfig.mock.inspectFuncGetImageConfig = f

	return mmGetImageConfig
}

// Return sets up results that will be returned by RegistryClient.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Return(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{mock: mmGetImageConfig.mock}
	}
	mmGetImageConfig.defaultExpectation.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	mmGetImageConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// Set uses given function f to mock the RegistryClient.GetImageConfig method
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Set(f func(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error)) *RegistryClientMock {
	if mmGetImageConfig.defaultExpectation != nil {
		mmGetImageConfig.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImageConfig method")
	}

	if len(mmGetImageConfig.expectations) > 0 {
		mmGetImageConfig.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImageConfig method")
	}

	mmGetImageConfig.mock.funcGetImageConfig = f
	mmGetImageConfig.mock.funcGetImageConfigOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// When sets expectation for the RegistryClient.GetImageConfig which will trigger the result defined by the following
// Then helper
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) When(ctx context.Context, tag string) *RegistryClientMockGetImageConfigExpectation {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageConfigExpectation{
		mock:               mmGetImageConfig.mock,
		params:             &RegistryClientMockGetImageConfigParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetImageConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImageConfig.expectations = append(mmGetImageConfig.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImageConfig return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageConfigExpectation) Then(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImageConfig should be invoked
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Times(n uint64) *mRegistryClientMockGetImageConfig {
	if n == 0 {
		mmGetImageConfig.mock.t.Fatalf("Times of RegistryClientMock.GetImageConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImageConfig.expectedInvocations, n)
	mmGetImageConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig
}

func (mmGetImageConfig *mRegistryClientMockGetImageConfig) invocationsDone() bool {
	if len(mmGetImageConfig.expectations) == 0 && mmGetImageConfig.defaultExpectation == nil && mmGetImageConfig.mock.funcGetImageConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.mock.afterGetImageConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImageConfig implements mm_pkg.RegistryClient
func (mmGetImageConfig *RegistryClientMock) GetImageConfig(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error) {
	mm_atomic.AddUint64(&mmGetImageConfig.beforeGetImageConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImageConfig.afterGetImageConfigCounter, 1)

	mmGetImageConfig.t.Helper()

	if mmGetImageConfig.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.inspectFuncGetImageConfig(ctx, tag)
	}

	mm_params := RegistryClientMockGetImageConfigParams{ctx, tag}

	// Record call args
	mmGetImageConfig.GetImageConfigMock.mutex.Lock()
	mmGetImageConfig.GetImageConfigMock.callArgs = append(mmGetImageConfig.GetImageConfigMock.callArgs, &mm_params)
	mmGetImageConfig.GetImageConfigMock.mutex.Unlock()

	for _, e := range mmGetImageConfig.GetImageConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetImageConfig.GetImageConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImageConfig.GetImageConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImageConfig.GetImageConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetImageConfig.GetImageConfigMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageConfigParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImageConfig.GetImageConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImageConfig.t.Fatal("No results are set for the RegistryClientMock.GetImageConfig")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetImageConfig.funcGetImageConfig != nil {
		return mmGetImageConfig.funcGetImageConfig(ctx, tag)
	}
	mmGetImageConfig.t.Fatalf("Unexpected call to RegistryClientMock.GetImageConfig. %v %v", ctx, tag)
	return
}

// GetImageConfigAfterCounter returns a count of finished RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.afterGetImageConfigCounter)
}

// GetImageConfigBeforeCounter returns a count of RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.beforeGetImageConfigCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImageConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Calls() []*RegistryClientMockGetImageConfigParams {
	mmGetImageConfig.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageConfigParams, len(mmGetImageConfig.callArgs))
	copy(argCopy, mmGetImageConfig.callArgs)

	mmGetImageConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageConfigDone returns true if the count of the GetImageConfig invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageConfigDone() bool {
	if m.GetImageConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageConfigMock.invocationsDone()
}

// MinimockGetImageConfigInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageConfigInspect() {
	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageConfigCounter := mm_atomic.LoadUint64(&m.afterGetImageConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageConfigMock.defaultExpectation != nil && afterGetImageConfigCounter < 1 {
		if m.GetImageConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.GetImageConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", m.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetImageConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImageConfig != nil && afterGetImageConfigCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.funcGetImageConfigOrigin)
	}

	if !m.GetImageConfigMock.invocationsDone() && afterGetImageConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImageConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageConfigMock.expectedInvocations), m.GetImageConfigMock.expectedInvocationsOrigin, afterGetImageConfigCounter)
	}
}

type mRegistryClientMockGetImageLayers struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageLayersExpectation
	expectations       []*RegistryClientMockGetImageLayersExpectation

	callArgs []*RegistryClientMockGetImageLayersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageLayersExpectation specifies expectation struct of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageLayersParams
	paramPtrs          *RegistryClientMockGetImageLayersParamPtrs
	expectationOrigins RegistryClientMockGetImageLayersExpectationOrigins
	results            *RegistryClientMockGetImageLayersResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageLayersParams contains parameters of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetImageLayersParamPtrs contains pointers to parameters of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetImageLayersResults contains results of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersResults struct {
	la1 []v1.Layer
	err error
}

// RegistryClientMockGetImageLayersOrigins contains origins of expectations of the RegistryClient.GetImageLayers
type RegistryClientMockGetImageLayersExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Optional() *mRegistryClientMockGetImageLayers {
	mmGetImageLayers.optional = true
	return mmGetImageLayers
}

// Expect sets up expected params for RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Expect(ctx context.Context, tag string) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{}
	}

	if mmGetImageLayers.defaultExpectation.paramPtrs != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by ExpectParams functions")
	}

	mmGetImageLayers.defaultExpectation.params = &RegistryClientMockGetImageLayersParams{ctx, tag}
	mmGetImageLayers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImageLayers.expectations {
		if minimock.Equal(e.params, mmGetImageLayers.defaultExpectation.params) {
			mmGetImageLayers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImageLayers.defaultExpectation.params)
		}
	}

	return mmGetImageLayers
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{}
	}

	if mmGetImageLayers.defaultExpectation.params != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Expect")
	}

	if mmGetImageLayers.defaultExpectation.paramPtrs == nil {
		mmGetImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockGetImageLayersParamPtrs{}
	}
	mmGetImageLayers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImageLayers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImageLayers
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) ExpectTagParam2(tag string) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{}
	}

	if mmGetImageLayers.defaultExpectation.params != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Expect")
	}

	if mmGetImageLayers.defaultExpectation.paramPtrs == nil {
		mmGetImageLayers.defaultExpectation.paramPtrs = &RegistryClientMockGetImageLayersParamPtrs{}
	}
	mmGetImageLayers.defaultExpectation.paramPtrs.tag = &tag
	mmGetImageLayers.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImageLayers
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetImageLayers {
	if mmGetImageLayers.mock.inspectFuncGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImageLayers")
	}

	mmGetImageLayers.mock.inspectFuncGetImageLayers = f

	return mmGetImageLayers
}

// Return sets up results that will be returned by RegistryClient.GetImageLayers
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Return(la1 []v1.Layer, err error) *RegistryClientMock {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	if mmGetImageLayers.defaultExpectation == nil {
		mmGetImageLayers.defaultExpectation = &RegistryClientMockGetImageLayersExpectation{mock: mmGetImageLayers.mock}
	}
	mmGetImageLayers.defaultExpectation.results = &RegistryClientMockGetImageLayersResults{la1, err}
	mmGetImageLayers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImageLayers.mock
}

// Set uses given function f to mock the RegistryClient.GetImageLayers method
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Set(f func(ctx context.Context, tag string) (la1 []v1.Layer, err error)) *RegistryClientMock {
	if mmGetImageLayers.defaultExpectation != nil {
		mmGetImageLayers.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetImageLayers method")
	}

	if len(mmGetImageLayers.expectations) > 0 {
		mmGetImageLayers.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetImageLayers method")
	}

	mmGetImageLayers.mock.funcGetImageLayers = f
	mmGetImageLayers.mock.funcGetImageLayersOrigin = minimock.CallerInfo(1)
	return mmGetImageLayers.mock
}

// When sets expectation for the RegistryClient.GetImageLayers which will trigger the result defined by the following
// Then helper
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) When(ctx context.Context, tag string) *RegistryClientMockGetImageLayersExpectation {
	if mmGetImageLayers.mock.funcGetImageLayers != nil {
		mmGetImageLayers.mock.t.Fatalf("RegistryClientMock.GetImageLayers mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageLayersExpectation{
		mock:               mmGetImageLayers.mock,
		params:             &RegistryClientMockGetImageLayersParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetImageLayersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImageLayers.expectations = append(mmGetImageLayers.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetImageLayers return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageLayersExpectation) Then(la1 []v1.Layer, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageLayersResults{la1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetImageLayers should be invoked
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Times(n uint64) *mRegistryClientMockGetImageLayers {
	if n == 0 {
		mmGetImageLayers.mock.t.Fatalf("Times of RegistryClientMock.GetImageLayers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImageLayers.expectedInvocations, n)
	mmGetImageLayers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImageLayers
}

func (mmGetImageLayers *mRegistryClientMockGetImageLayers) invocationsDone() bool {
	if len(mmGetImageLayers.expectations) == 0 && mmGetImageLayers.defaultExpectation == nil && mmGetImageLayers.mock.funcGetImageLayers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImageLayers.mock.afterGetImageLayersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImageLayers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImageLayers implements mm_pkg.RegistryClient
func (mmGetImageLayers *RegistryClientMock) GetImageLayers(ctx context.Context, tag string) (la1 []v1.Layer, err error) {
	mm_atomic.AddUint64(&mmGetImageLayers.beforeGetImageLayersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImageLayers.afterGetImageLayersCounter, 1)

	mmGetImageLayers.t.Helper()

	if mmGetImageLayers.inspectFuncGetImageLayers != nil {
		mmGetImageLayers.inspectFuncGetImageLayers(ctx, tag)
	}

	mm_params := RegistryClientMockGetImageLayersParams{ctx, tag}

	// Record call args
	mmGetImageLayers.GetImageLayersMock.mutex.Lock()
	mmGetImageLayers.GetImageLayersMock.callArgs = append(mmGetImageLayers.GetImageLayersMock.callArgs, &mm_params)
	mmGetImageLayers.GetImageLayersMock.mutex.Unlock()

	for _, e := range mmGetImageLayers.GetImageLayersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.la1, e.results.err
		}
	}

	if mmGetImageLayers.GetImageLayersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImageLayers.GetImageLayersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImageLayers.GetImageLayersMock.defaultExpectation.params
		mm_want_ptrs := mmGetImageLayers.GetImageLayersMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageLayersParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImageLayers.t.Errorf("RegistryClientMock.GetImageLayers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageLayers.GetImageLayersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImageLayers.t.Errorf("RegistryClientMock.GetImageLayers got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageLayers.GetImageLayersMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImageLayers.t.Errorf("RegistryClientMock.GetImageLayers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImageLayers.GetImageLayersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImageLayers.GetImageLayersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImageLayers.t.Fatal("No results are set for the RegistryClientMock.GetImageLayers")
		}
		return (*mm_results).la1, (*mm_results).err
	}
	if mmGetImageLayers.funcGetImageLayers != nil {
		return mmGetImageLayers.funcGetImageLayers(ctx, tag)
	}
	mmGetImageLayers.t.Fatalf("Unexpected call to RegistryClientMock.GetImageLayers. %v %v", ctx, tag)
	return
}

// GetImageLayersAfterCounter returns a count of finished RegistryClientMock.GetImageLayers invocations
func (mmGetImageLayers *RegistryClientMock) GetImageLayersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageLayers.afterGetImageLayersCounter)
}

// GetImageLayersBeforeCounter returns a count of RegistryClientMock.GetImageLayers invocations
func (mmGetImageLayers *RegistryClientMock) GetImageLayersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageLayers.beforeGetImageLayersCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImageLayers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImageLayers *mRegistryClientMockGetImageLayers) Calls() []*RegistryClientMockGetImageLayersParams {
	mmGetImageLayers.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageLayersParams, len(mmGetImageLayers.callArgs))
	copy(argCopy, mmGetImageLayers.callArgs)

	mmGetImageLayers.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageLayersDone returns true if the count of the GetImageLayers invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageLayersDone() bool {
	if m.GetImageLayersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageLayersMock.invocationsDone()
}

// MinimockGetImageLayersInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageLayersInspect() {
	for _, e := range m.GetImageLayersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageLayersCounter := mm_atomic.LoadUint64(&m.afterGetImageLayersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageLayersMock.defaultExpectation != nil && afterGetImageLayersCounter < 1 {
		if m.GetImageLayersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s", m.GetImageLayersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s with params: %#v", m.GetImageLayersMock.defaultExpectation.expectationOrigins.origin, *m.GetImageLayersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImageLayers != nil && afterGetImageLayersCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImageLayers at\n%s", m.funcGetImageLayersOrigin)
	}

	if !m.GetImageLayersMock.invocationsDone() && afterGetImageLayersCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImageLayers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageLayersMock.expectedInvocations), m.GetImageLayersMock.expectedInvocationsOrigin, afterGetImageLayersCounter)
	}
}

type mRegistryClientMockGetLabel struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetLabelExpectation
	expectations       []*RegistryClientMockGetLabelExpectation

	callArgs []*RegistryClientMockGetLabelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetLabelExpectation specifies expectation struct of the RegistryClient.GetLabel
type RegistryClientMockGetLabelExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetLabelParams
	paramPtrs          *RegistryClientMockGetLabelParamPtrs
	expectationOrigins RegistryClientMockGetLabelExpectationOrigins
	results            *RegistryClientMockGetLabelResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetLabelParams contains parameters of the RegistryClient.GetLabel
type RegistryClientMockGetLabelParams struct {
	ctx      context.Context
	tag      string
	labelKey string
}

// RegistryClientMockGetLabelParamPtrs contains pointers to parameters of the RegistryClient.GetLabel
type RegistryClientMockGetLabelParamPtrs struct {
	ctx      *context.Context
	tag      *string
	labelKey *string
}

// RegistryClientMockGetLabelResults contains results of the RegistryClient.GetLabel
type RegistryClientMockGetLabelResults struct {
	s1  string
	b1  bool
	err error
}

// RegistryClientMockGetLabelOrigins contains origins of expectations of the RegistryClient.GetLabel
type RegistryClientMockGetLabelExpectationOrigins struct {
	origin         string
	originCtx      string
	originTag      string
	originLabelKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLabel *mRegistryClientMockGetLabel) Optional() *mRegistryClientMockGetLabel {
	mmGetLabel.optional = true
	return mmGetLabel
}

// Expect sets up expected params for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) Expect(ctx context.Context, tag string, labelKey string) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.paramPtrs != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by ExpectParams functions")
	}

	mmGetLabel.defaultExpectation.params = &RegistryClientMockGetLabelParams{ctx, tag, labelKey}
	mmGetLabel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLabel.expectations {
		if minimock.Equal(e.params, mmGetLabel.defaultExpectation.params) {
			mmGetLabel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLabel.defaultExpectation.params)
		}
	}

	return mmGetLabel
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.params != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Expect")
	}

	if mmGetLabel.defaultExpectation.paramPtrs == nil {
		mmGetLabel.defaultExpectation.paramPtrs = &RegistryClientMockGetLabelParamPtrs{}
	}
	mmGetLabel.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLabel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLabel
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) ExpectTagParam2(tag string) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.params != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Expect")
	}

	if mmGetLabel.defaultExpectation.paramPtrs == nil {
		mmGetLabel.defaultExpectation.paramPtrs = &RegistryClientMockGetLabelParamPtrs{}
	}
	mmGetLabel.defaultExpectation.paramPtrs.tag = &tag
	mmGetLabel.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetLabel
}

// ExpectLabelKeyParam3 sets up expected param labelKey for RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) ExpectLabelKeyParam3(labelKey string) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{}
	}

	if mmGetLabel.defaultExpectation.params != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Expect")
	}

	if mmGetLabel.defaultExpectation.paramPtrs == nil {
		mmGetLabel.defaultExpectation.paramPtrs = &RegistryClientMockGetLabelParamPtrs{}
	}
	mmGetLabel.defaultExpectation.paramPtrs.labelKey = &labelKey
	mmGetLabel.defaultExpectation.expectationOrigins.originLabelKey = minimock.CallerInfo(1)

	return mmGetLabel
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) Inspect(f func(ctx context.Context, tag string, labelKey string)) *mRegistryClientMockGetLabel {
	if mmGetLabel.mock.inspectFuncGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetLabel")
	}

	mmGetLabel.mock.inspectFuncGetLabel = f

	return mmGetLabel
}

// Return sets up results that will be returned by RegistryClient.GetLabel
func (mmGetLabel *mRegistryClientMockGetLabel) Return(s1 string, b1 bool, err error) *RegistryClientMock {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	if mmGetLabel.defaultExpectation == nil {
		mmGetLabel.defaultExpectation = &RegistryClientMockGetLabelExpectation{mock: mmGetLabel.mock}
	}
	mmGetLabel.defaultExpectation.results = &RegistryClientMockGetLabelResults{s1, b1, err}
	mmGetLabel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLabel.mock
}

// Set uses given function f to mock the RegistryClient.GetLabel method
func (mmGetLabel *mRegistryClientMockGetLabel) Set(f func(ctx context.Context, tag string, labelKey string) (s1 string, b1 bool, err error)) *RegistryClientMock {
	if mmGetLabel.defaultExpectation != nil {
		mmGetLabel.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetLabel method")
	}

	if len(mmGetLabel.expectations) > 0 {
		mmGetLabel.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetLabel method")
	}

	mmGetLabel.mock.funcGetLabel = f
	mmGetLabel.mock.funcGetLabelOrigin = minimock.CallerInfo(1)
	return mmGetLabel.mock
}

// When sets expectation for the RegistryClient.GetLabel which will trigger the result defined by the following
// Then helper
func (mmGetLabel *mRegistryClientMockGetLabel) When(ctx context.Context, tag string, labelKey string) *RegistryClientMockGetLabelExpectation {
	if mmGetLabel.mock.funcGetLabel != nil {
		mmGetLabel.mock.t.Fatalf("RegistryClientMock.GetLabel mock is already set by Set")
	}

	expectation := &RegistryClientMockGetLabelExpectation{
		mock:               mmGetLabel.mock,
		params:             &RegistryClientMockGetLabelParams{ctx, tag, labelKey},
		expectationOrigins: RegistryClientMockGetLabelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLabel.expectations = append(mmGetLabel.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetLabel return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetLabelExpectation) Then(s1 string, b1 bool, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetLabelResults{s1, b1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetLabel should be invoked
func (mmGetLabel *mRegistryClientMockGetLabel) Times(n uint64) *mRegistryClientMockGetLabel {
	if n == 0 {
		mmGetLabel.mock.t.Fatalf("Times of RegistryClientMock.GetLabel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLabel.expectedInvocations, n)
	mmGetLabel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLabel
}

func (mmGetLabel *mRegistryClientMockGetLabel) invocationsDone() bool {
	if len(mmGetLabel.expectations) == 0 && mmGetLabel.defaultExpectation == nil && mmGetLabel.mock.funcGetLabel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLabel.mock.afterGetLabelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLabel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLabel implements mm_pkg.RegistryClient
func (mmGetLabel *RegistryClientMock) GetLabel(ctx context.Context, tag string, labelKey string) (s1 string, b1 bool, err error) {
	mm_atomic.AddUint64(&mmGetLabel.beforeGetLabelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLabel.afterGetLabelCounter, 1)

	mmGetLabel.t.Helper()

	if mmGetLabel.inspectFuncGetLabel != nil {
		mmGetLabel.inspectFuncGetLabel(ctx, tag, labelKey)
	}

	mm_params := RegistryClientMockGetLabelParams{ctx, tag, labelKey}

	// Record call args
	mmGetLabel.GetLabelMock.mutex.Lock()
	mmGetLabel.GetLabelMock.callArgs = append(mmGetLabel.GetLabelMock.callArgs, &mm_params)
	mmGetLabel.GetLabelMock.mutex.Unlock()

	for _, e := range mmGetLabel.GetLabelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.b1, e.results.err
		}
	}

	if mmGetLabel.GetLabelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLabel.GetLabelMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLabel.GetLabelMock.defaultExpectation.params
		mm_want_ptrs := mmGetLabel.GetLabelMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetLabelParams{ctx, tag, labelKey}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.labelKey != nil && !minimock.Equal(*mm_want_ptrs.labelKey, mm_got.labelKey) {
				mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameter labelKey, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.originLabelKey, *mm_want_ptrs.labelKey, mm_got.labelKey, minimock.Diff(*mm_want_ptrs.labelKey, mm_got.labelKey))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLabel.t.Errorf("RegistryClientMock.GetLabel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLabel.GetLabelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLabel.GetLabelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLabel.t.Fatal("No results are set for the RegistryClientMock.GetLabel")
		}
		return (*mm_results).s1, (*mm_results).b1, (*mm_results).err
	}
	if mmGetLabel.funcGetLabel != nil {
		return mmGetLabel.funcGetLabel(ctx, tag, labelKey)
	}
	mmGetLabel.t.Fatalf("Unexpected call to RegistryClientMock.GetLabel. %v %v %v", ctx, tag, labelKey)
	return
}

// GetLabelAfterCounter returns a count of finished RegistryClientMock.GetLabel invocations
func (mmGetLabel *RegistryClientMock) GetLabelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLabel.afterGetLabelCounter)
}

// GetLabelBeforeCounter returns a count of RegistryClientMock.GetLabel invocations
func (mmGetLabel *RegistryClientMock) GetLabelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLabel.beforeGetLabelCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetLabel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLabel *mRegistryClientMockGetLabel) Calls() []*RegistryClientMockGetLabelParams {
	mmGetLabel.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetLabelParams, len(mmGetLabel.callArgs))
	copy(argCopy, mmGetLabel.callArgs)

	mmGetLabel.mutex.RUnlock()

	return argCopy
}

// MinimockGetLabelDone returns true if the count of the GetLabel invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetLabelDone() bool {
	if m.GetLabelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLabelMock.invocationsDone()
}

// MinimockGetLabelInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetLabelInspect() {
	for _, e := range m.GetLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLabelCounter := mm_atomic.LoadUint64(&m.afterGetLabelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLabelMock.defaultExpectation != nil && afterGetLabelCounter < 1 {
		if m.GetLabelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s", m.GetLabelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s with params: %#v", m.GetLabelMock.defaultExpectation.expectationOrigins.origin, *m.GetLabelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLabel != nil && afterGetLabelCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetLabel at\n%s", m.funcGetLabelOrigin)
	}

	if !m.GetLabelMock.invocationsDone() && afterGetLabelCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetLabel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLabelMock.expectedInvocations), m.GetLabelMock.expectedInvocationsOrigin, afterGetLabelCounter)
	}
}

type mRegistryClientMockGetManifest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetManifestExpectation
	expectations       []*RegistryClientMockGetManifestExpectation

	callArgs []*RegistryClientMockGetManifestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetManifestExpectation specifies expectation struct of the RegistryClient.GetManifest
type RegistryClientMockGetManifestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetManifestParams
	paramPtrs          *RegistryClientMockGetManifestParamPtrs
	expectationOrigins RegistryClientMockGetManifestExpectationOrigins
	results            *RegistryClientMockGetManifestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetManifestParams contains parameters of the RegistryClient.GetManifest
type RegistryClientMockGetManifestParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetManifestParamPtrs contains pointers to parameters of the RegistryClient.GetManifest
type RegistryClientMockGetManifestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetManifestResults contains results of the RegistryClient.GetManifest
type RegistryClientMockGetManifestResults struct {
	dp1 *remote.Descriptor
	err error
}

// RegistryClientMockGetManifestOrigins contains origins of expectations of the RegistryClient.GetManifest
type RegistryClientMockGetManifestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetManifest *mRegistryClientMockGetManifest) Optional() *mRegistryClientMockGetManifest {
	mmGetManifest.optional = true
	return mmGetManifest
}

// Expect sets up expected params for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Expect(ctx context.Context, tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.paramPtrs != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by ExpectParams functions")
	}

	mmGetManifest.defaultExpectation.params = &RegistryClientMockGetManifestParams{ctx, tag}
	mmGetManifest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetManifest.expectations {
		if minimock.Equal(e.params, mmGetManifest.defaultExpectation.params) {
			mmGetManifest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetManifest.defaultExpectation.params)
		}
	}

	return mmGetManifest
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetManifest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetManifest
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectTagParam2(tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.tag = &tag
	mmGetManifest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetManifest
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.inspectFuncGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetManifest")
	}

	mmGetManifest.mock.inspectFuncGetManifest = f

	return mmGetManifest
}

// Return sets up results that will be returned by RegistryClient.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Return(dp1 *remote.Descriptor, err error) *RegistryClientMock {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{mock: mmGetManifest.mock}
	}
	mmGetManifest.defaultExpectation.results = &RegistryClientMockGetManifestResults{dp1, err}
	mmGetManifest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// Set uses given function f to mock the RegistryClient.GetManifest method
func (mmGetManifest *mRegistryClientMockGetManifest) Set(f func(ctx context.Context, tag string) (dp1 *remote.Descriptor, err error)) *RegistryClientMock {
	if mmGetManifest.defaultExpectation != nil {
		mmGetManifest.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetManifest method")
	}

	if len(mmGetManifest.expectations) > 0 {
		mmGetManifest.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetManifest method")
	}

	mmGetManifest.mock.funcGetManifest = f
	mmGetManifest.mock.funcGetManifestOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// When sets expectation for the RegistryClient.GetManifest which will trigger the result defined by the following
// Then helper
func (mmGetManifest *mRegistryClientMockGetManifest) When(ctx context.Context, tag string) *RegistryClientMockGetManifestExpectation {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetManifestExpectation{
		mock:               mmGetManifest.mock,
		params:             &RegistryClientMockGetManifestParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetManifestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetManifest.expectations = append(mmGetManifest.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.GetManifest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetManifestExpectation) Then(dp1 *remote.Descriptor, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetManifestResults{dp1, err}
	return e.mock
}

// Times sets number of times RegistryClient.GetManifest should be invoked
func (mmGetManifest *mRegistryClientMockGetManifest) Times(n uint64) *mRegistryClientMockGetManifest {
	if n == 0 {
		mmGetManifest.mock.t.Fatalf("Times of RegistryClientMock.GetManifest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetManifest.expectedInvocations, n)
	mmGetManifest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetManifest
}

func (mmGetManifest *mRegistryClientMockGetManifest) invocationsDone() bool {
	if len(mmGetManifest.expectations) == 0 && mmGetManifest.defaultExpectation == nil && mmGetManifest.mock.funcGetManifest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetManifest.mock.afterGetManifestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetManifest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetManifest implements mm_pkg.RegistryClient
func (mmGetManifest *RegistryClientMock) GetManifest(ctx context.Context, tag string) (dp1 *remote.Descriptor, err error) {
	mm_atomic.AddUint64(&mmGetManifest.beforeGetManifestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetManifest.afterGetManifestCounter, 1)

	mmGetManifest.t.Helper()

	if mmGetManifest.inspectFuncGetManifest != nil {
		mmGetManifest.inspectFuncGetManifest(ctx, tag)
	}

	mm_params := RegistryClientMockGetManifestParams{ctx, tag}

	// Record call args
	mmGetManifest.GetManifestMock.mutex.Lock()
	mmGetManifest.GetManifestMock.callArgs = append(mmGetManifest.GetManifestMock.callArgs, &mm_params)
	mmGetManifest.GetManifestMock.mutex.Unlock()

	for _, e := range mmGetManifest.GetManifestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGetManifest.GetManifestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetManifest.GetManifestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetManifest.GetManifestMock.defaultExpectation.params
		mm_want_ptrs := mmGetManifest.GetManifestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetManifestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetManifest.GetManifestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetManifest.t.Fatal("No results are set for the RegistryClientMock.GetManifest")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGetManifest.funcGetManifest != nil {
		return mmGetManifest.funcGetManifest(ctx, tag)
	}
	mmGetManifest.t.Fatalf("Unexpected call to RegistryClientMock.GetManifest. %v %v", ctx, tag)
	return
}

// GetManifestAfterCounter returns a count of finished RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.afterGetManifestCounter)
}

// GetManifestBeforeCounter returns a count of RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.beforeGetManifestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetManifest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetManifest *mRegistryClientMockGetManifest) Calls() []*RegistryClientMockGetManifestParams {
	mmGetManifest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetManifestParams, len(mmGetManifest.callArgs))
	copy(argCopy, mmGetManifest.callArgs)

	mmGetManifest.mutex.RUnlock()

	return argCopy
}

// MinimockGetManifestDone returns true if the count of the GetManifest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetManifestDone() bool {
	if m.GetManifestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetManifestMock.invocationsDone()
}

// MinimockGetManifestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetManifestInspect() {
	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetManifestCounter := mm_atomic.LoadUint64(&m.afterGetManifestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetManifestMock.defaultExpectation != nil && afterGetManifestCounter < 1 {
		if m.GetManifestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.GetManifestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", m.GetManifestMock.defaultExpectation.expectationOrigins.origin, *m.GetManifestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetManifest != nil && afterGetManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.funcGetManifestOrigin)
	}

	if !m.GetManifestMock.invocationsDone() && afterGetManifestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetManifest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetManifestMock.expectedInvocations), m.GetManifestMock.expectedInvocationsOrigin, afterGetManifestCounter)
	}
}

type mRegistryClientMockGetRegistry struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetRegistryExpectation
	expectations       []*RegistryClientMockGetRegistryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetRegistryExpectation specifies expectation struct of the RegistryClient.GetRegistry
type RegistryClientMockGetRegistryExpectation struct {
	mock *RegistryClientMock

	results      *RegistryClientMockGetRegistryResults
	returnOrigin string
	Counter      uint64
}

// RegistryClientMockGetRegistryResults contains results of the RegistryClient.GetRegistry
type RegistryClientMockGetRegistryResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRegistry *mRegistryClientMockGetRegistry) Optional() *mRegistryClientMockGetRegistry {
	mmGetRegistry.optional = true
	return mmGetRegistry
}

// Expect sets up expected params for RegistryClient.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Expect() *mRegistryClientMockGetRegistry {
	if mmGetRegistry.mock.funcGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("RegistryClientMock.GetRegistry mock is already set by Set")
	}

	if mmGetRegistry.defaultExpectation == nil {
		mmGetRegistry.defaultExpectation = &RegistryClientMockGetRegistryExpectation{}
	}

	return mmGetRegistry
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Inspect(f func()) *mRegistryClientMockGetRegistry {
	if mmGetRegistry.mock.inspectFuncGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetRegistry")
	}

	mmGetRegistry.mock.inspectFuncGetRegistry = f

	return mmGetRegistry
}

// Return sets up results that will be returned by RegistryClient.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Return(s1 string) *RegistryClientMock {
	if mmGetRegistry.mock.funcGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("RegistryClientMock.GetRegistry mock is already set by Set")
	}

	if mmGetRegistry.defaultExpectation == nil {
		mmGetRegistry.defaultExpectation = &RegistryClientMockGetRegistryExpectation{mock: mmGetRegistry.mock}
	}
	mmGetRegistry.defaultExpectation.results = &RegistryClientMockGetRegistryResults{s1}
	mmGetRegistry.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRegistry.mock
}

// Set uses given function f to mock the RegistryClient.GetRegistry method
func (mmGetRegistry *mRegistryClientMockGetRegistry) Set(f func() (s1 string)) *RegistryClientMock {
	if mmGetRegistry.defaultExpectation != nil {
		mmGetRegistry.mock.t.Fatalf("Default expectation is already set for the RegistryClient.GetRegistry method")
	}

	if len(mmGetRegistry.expectations) > 0 {
		mmGetRegistry.mock.t.Fatalf("Some expectations are already set for the RegistryClient.GetRegistry method")
	}

	mmGetRegistry.mock.funcGetRegistry = f
	mmGetRegistry.mock.funcGetRegistryOrigin = minimock.CallerInfo(1)
	return mmGetRegistry.mock
}

// Times sets number of times RegistryClient.GetRegistry should be invoked
func (mmGetRegistry *mRegistryClientMockGetRegistry) Times(n uint64) *mRegistryClientMockGetRegistry {
	if n == 0 {
		mmGetRegistry.mock.t.Fatalf("Times of RegistryClientMock.GetRegistry mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRegistry.expectedInvocations, n)
	mmGetRegistry.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRegistry
}

func (mmGetRegistry *mRegistryClientMockGetRegistry) invocationsDone() bool {
	if len(mmGetRegistry.expectations) == 0 && mmGetRegistry.defaultExpectation == nil && mmGetRegistry.mock.funcGetRegistry == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRegistry.mock.afterGetRegistryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRegistry.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRegistry implements mm_pkg.RegistryClient
func (mmGetRegistry *RegistryClientMock) GetRegistry() (s1 string) {
	mm_atomic.AddUint64(&mmGetRegistry.beforeGetRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRegistry.afterGetRegistryCounter, 1)

	mmGetRegistry.t.Helper()

	if mmGetRegistry.inspectFuncGetRegistry != nil {
		mmGetRegistry.inspectFuncGetRegistry()
	}

	if mmGetRegistry.GetRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRegistry.GetRegistryMock.defaultExpectation.Counter, 1)

		mm_results := mmGetRegistry.GetRegistryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRegistry.t.Fatal("No results are set for the RegistryClientMock.GetRegistry")
		}
		return (*mm_results).s1
	}
	if mmGetRegistry.funcGetRegistry != nil {
		return mmGetRegistry.funcGetRegistry()
	}
	mmGetRegistry.t.Fatalf("Unexpected call to RegistryClientMock.GetRegistry.")
	return
}

// GetRegistryAfterCounter returns a count of finished RegistryClientMock.GetRegistry invocations
func (mmGetRegistry *RegistryClientMock) GetRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistry.afterGetRegistryCounter)
}

// GetRegistryBeforeCounter returns a count of RegistryClientMock.GetRegistry invocations
func (mmGetRegistry *RegistryClientMock) GetRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistry.beforeGetRegistryCounter)
}

// MinimockGetRegistryDone returns true if the count of the GetRegistry invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetRegistryDone() bool {
	if m.GetRegistryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRegistryMock.invocationsDone()
}

// MinimockGetRegistryInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetRegistryInspect() {
	for _, e := range m.GetRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryClientMock.GetRegistry")
		}
	}

	afterGetRegistryCounter := mm_atomic.LoadUint64(&m.afterGetRegistryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRegistryMock.defaultExpectation != nil && afterGetRegistryCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetRegistry at\n%s", m.GetRegistryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRegistry != nil && afterGetRegistryCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetRegistry at\n%s", m.funcGetRegistryOrigin)
	}

	if !m.GetRegistryMock.invocationsDone() && afterGetRegistryCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetRegistry at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRegistryMock.expectedInvocations), m.GetRegistryMock.expectedInvocationsOrigin, afterGetRegistryCounter)
	}
}

type mRegistryClientMockListRepositories struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListRepositoriesExpectation
	expectations       []*RegistryClientMockListRepositoriesExpectation

	callArgs []*RegistryClientMockListRepositoriesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListRepositoriesExpectation specifies expectation struct of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListRepositoriesParams
	paramPtrs          *RegistryClientMockListRepositoriesParamPtrs
	expectationOrigins RegistryClientMockListRepositoriesExpectationOrigins
	results            *RegistryClientMockListRepositoriesResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListRepositoriesParams contains parameters of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesParams struct {
	ctx context.Context
}

// RegistryClientMockListRepositoriesParamPtrs contains pointers to parameters of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesParamPtrs struct {
	ctx *context.Context
}

// RegistryClientMockListRepositoriesResults contains results of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesResults struct {
	sa1 []string
	err error
}

// RegistryClientMockListRepositoriesOrigins contains origins of expectations of the RegistryClient.ListRepositories
type RegistryClientMockListRepositoriesExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListRepositories *mRegistryClientMockListRepositories) Optional() *mRegistryClientMockListRepositories {
	mmListRepositories.optional = true
	return mmListRepositories
}

// Expect sets up expected params for RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Expect(ctx context.Context) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{}
	}

	if mmListRepositories.defaultExpectation.paramPtrs != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by ExpectParams functions")
	}

	mmListRepositories.defaultExpectation.params = &RegistryClientMockListRepositoriesParams{ctx}
	mmListRepositories.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListRepositories.expectations {
		if minimock.Equal(e.params, mmListRepositories.defaultExpectation.params) {
			mmListRepositories.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListRepositories.defaultExpectation.params)
		}
	}

	return mmListRepositories
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{}
	}

	if mmListRepositories.defaultExpectation.params != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Expect")
	}

	if mmListRepositories.defaultExpectation.paramPtrs == nil {
		mmListRepositories.defaultExpectation.paramPtrs = &RegistryClientMockListRepositoriesParamPtrs{}
	}
	mmListRepositories.defaultExpectation.paramPtrs.ctx = &ctx
	mmListRepositories.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListRepositories
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Inspect(f func(ctx context.Context)) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.inspectFuncListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListRepositories")
	}

	mmListRepositories.mock.inspectFuncListRepositories = f

	return mmListRepositories
}

// Return sets up results that will be returned by RegistryClient.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Return(sa1 []string, err error) *RegistryClientMock {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{mock: mmListRepositories.mock}
	}
	mmListRepositories.defaultExpectation.results = &RegistryClientMockListRepositoriesResults{sa1, err}
	mmListRepositories.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListRepositories.mock
}

// Set uses given function f to mock the RegistryClient.ListRepositories method
func (mmListRepositories *mRegistryClientMockListRepositories) Set(f func(ctx context.Context) (sa1 []string, err error)) *RegistryClientMock {
	if mmListRepositories.defaultExpectation != nil {
		mmListRepositories.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ListRepositories method")
	}

	if len(mmListRepositories.expectations) > 0 {
		mmListRepositories.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ListRepositories method")
	}

	mmListRepositories.mock.funcListRepositories = f
	mmListRepositories.mock.funcListRepositoriesOrigin = minimock.CallerInfo(1)
	return mmListRepositories.mock
}

// When sets expectation for the RegistryClient.ListRepositories which will trigger the result defined by the following
// Then helper
func (mmListRepositories *mRegistryClientMockListRepositories) When(ctx context.Context) *RegistryClientMockListRepositoriesExpectation {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	expectation := &RegistryClientMockListRepositoriesExpectation{
		mock:               mmListRepositories.mock,
		params:             &RegistryClientMockListRepositoriesParams{ctx},
		expectationOrigins: RegistryClientMockListRepositoriesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListRepositories.expectations = append(mmListRepositories.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ListRepositories return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListRepositoriesExpectation) Then(sa1 []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListRepositoriesResults{sa1, err}
	return e.mock
}

// Times sets number of times RegistryClient.ListRepositories should be invoked
func (mmListRepositories *mRegistryClientMockListRepositories) Times(n uint64) *mRegistryClientMockListRepositories {
	if n == 0 {
		mmListRepositories.mock.t.Fatalf("Times of RegistryClientMock.ListRepositories mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListRepositories.expectedInvocations, n)
	mmListRepositories.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListRepositories
}

func (mmListRepositories *mRegistryClientMockListRepositories) invocationsDone() bool {
	if len(mmListRepositories.expectations) == 0 && mmListRepositories.defaultExpectation == nil && mmListRepositories.mock.funcListRepositories == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListRepositories.mock.afterListRepositoriesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListRepositories.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListRepositories implements mm_pkg.RegistryClient
func (mmListRepositories *RegistryClientMock) ListRepositories(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListRepositories.beforeListRepositoriesCounter, 1)
	defer mm_atomic.AddUint64(&mmListRepositories.afterListRepositoriesCounter, 1)

	mmListRepositories.t.Helper()

	if mmListRepositories.inspectFuncListRepositories != nil {
		mmListRepositories.inspectFuncListRepositories(ctx)
	}

	mm_params := RegistryClientMockListRepositoriesParams{ctx}

	// Record call args
	mmListRepositories.ListRepositoriesMock.mutex.Lock()
	mmListRepositories.ListRepositoriesMock.callArgs = append(mmListRepositories.ListRepositoriesMock.callArgs, &mm_params)
	mmListRepositories.ListRepositoriesMock.mutex.Unlock()

	for _, e := range mmListRepositories.ListRepositoriesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListRepositories.ListRepositoriesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListRepositories.ListRepositoriesMock.defaultExpectation.Counter, 1)
		mm_want := mmListRepositories.ListRepositoriesMock.defaultExpectation.params
		mm_want_ptrs := mmListRepositories.ListRepositoriesMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListRepositoriesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListRepositories.t.Errorf("RegistryClientMock.ListRepositories got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositories.ListRepositoriesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListRepositories.t.Errorf("RegistryClientMock.ListRepositories got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListRepositories.ListRepositoriesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListRepositories.ListRepositoriesMock.defaultExpectation.results
		if mm_results == nil {
			mmListRepositories.t.Fatal("No results are set for the RegistryClientMock.ListRepositories")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListRepositories.funcListRepositories != nil {
		return mmListRepositories.funcListRepositories(ctx)
	}
	mmListRepositories.t.Fatalf("Unexpected call to RegistryClientMock.ListRepositories. %v", ctx)
	return
}

// ListRepositoriesAfterCounter returns a count of finished RegistryClientMock.ListRepositories invocations
func (mmListRepositories *RegistryClientMock) ListRepositoriesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositories.afterListRepositoriesCounter)
}

// ListRepositoriesBeforeCounter returns a count of RegistryClientMock.ListRepositories invocations
func (mmListRepositories *RegistryClientMock) ListRepositoriesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositories.beforeListRepositoriesCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListRepositories.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListRepositories *mRegistryClientMockListRepositories) Calls() []*RegistryClientMockListRepositoriesParams {
	mmListRepositories.mutex.RLock()

	argCopy := make([]*RegistryClientMockListRepositoriesParams, len(mmListRepositories.callArgs))
	copy(argCopy, mmListRepositories.callArgs)

	mmListRepositories.mutex.RUnlock()

	return argCopy
}

// MinimockListRepositoriesDone returns true if the count of the ListRepositories invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListRepositoriesDone() bool {
	if m.ListRepositoriesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListRepositoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListRepositoriesMock.invocationsDone()
}

// MinimockListRepositoriesInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListRepositoriesInspect() {
	for _, e := range m.ListRepositoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListRepositoriesCounter := mm_atomic.LoadUint64(&m.afterListRepositoriesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListRepositoriesMock.defaultExpectation != nil && afterListRepositoriesCounter < 1 {
		if m.ListRepositoriesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s", m.ListRepositoriesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s with params: %#v", m.ListRepositoriesMock.defaultExpectation.expectationOrigins.origin, *m.ListRepositoriesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListRepositories != nil && afterListRepositoriesCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s", m.funcListRepositoriesOrigin)
	}

	if !m.ListRepositoriesMock.invocationsDone() && afterListRepositoriesCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListRepositories at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListRepositoriesMock.expectedInvocations), m.ListRepositoriesMock.expectedInvocationsOrigin, afterListRepositoriesCounter)
	}
}

type mRegistryClientMockListTags struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListTagsExpectation
	expectations       []*RegistryClientMockListTagsExpectation

	callArgs []*RegistryClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListTagsExpectation specifies expectation struct of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListTagsParams
	paramPtrs          *RegistryClientMockListTagsParamPtrs
	expectationOrigins RegistryClientMockListTagsExpectationOrigins
	results            *RegistryClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListTagsParams contains parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParams struct {
	ctx context.Context
}

// RegistryClientMockListTagsParamPtrs contains pointers to parameters of the RegistryClient.ListTags
type RegistryClientMockListTagsParamPtrs struct {
	ctx *context.Context
}

// RegistryClientMockListTagsResults contains results of the RegistryClient.ListTags
type RegistryClientMockListTagsResults struct {
	sa1 []string
	err error
}

// RegistryClientMockListTagsOrigins contains origins of expectations of the RegistryClient.ListTags
type RegistryClientMockListTagsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mRegistryClientMockListTags) Optional() *mRegistryClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Expect(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &RegistryClientMockListTagsParams{ctx}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Inspect(f func(ctx context.Context)) *mRegistryClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by RegistryClient.ListTags
func (mmListTags *mRegistryClientMockListTags) Return(sa1 []string, err error) *RegistryClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &RegistryClientMockListTagsResults{sa1, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the RegistryClient.ListTags method
func (mmListTags *mRegistryClientMockListTags) Set(f func(ctx context.Context) (sa1 []string, err error)) *RegistryClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the RegistryClient.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the RegistryClient.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the RegistryClient.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mRegistryClientMockListTags) When(ctx context.Context) *RegistryClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	expectation := &RegistryClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &RegistryClientMockListTagsParams{ctx},
		expectationOrigins: RegistryClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.ListTags return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListTagsExpectation) Then(sa1 []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListTagsResults{sa1, err}
	return e.mock
}

// Times sets number of times RegistryClient.ListTags should be invoked
func (mmListTags *mRegistryClientMockListTags) Times(n uint64) *mRegistryClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of RegistryClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mRegistryClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements mm_pkg.RegistryClient
func (mmListTags *RegistryClientMock) ListTags(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx)
	}

	mm_params := RegistryClientMockListTagsParams{ctx}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListTagsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the RegistryClientMock.ListTags")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx)
	}
	mmListTags.t.Fatalf("Unexpected call to RegistryClientMock.ListTags. %v", ctx)
	return
}

// ListTagsAfterCounter returns a count of finished RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mRegistryClientMockListTags) Calls() []*RegistryClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*RegistryClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

type mRegistryClientMockPushImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockPushImageExpectation
	expectations       []*RegistryClientMockPushImageExpectation

	callArgs []*RegistryClientMockPushImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockPushImageExpectation specifies expectation struct of the RegistryClient.PushImage
type RegistryClientMockPushImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockPushImageParams
	paramPtrs          *RegistryClientMockPushImageParamPtrs
	expectationOrigins RegistryClientMockPushImageExpectationOrigins
	results            *RegistryClientMockPushImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockPushImageParams contains parameters of the RegistryClient.PushImage
type RegistryClientMockPushImageParams struct {
	ctx context.Context
	tag string
	img v1.Image
}

// RegistryClientMockPushImageParamPtrs contains pointers to parameters of the RegistryClient.PushImage
type RegistryClientMockPushImageParamPtrs struct {
	ctx *context.Context
	tag *string
	img *v1.Image
}

// RegistryClientMockPushImageResults contains results of the RegistryClient.PushImage
type RegistryClientMockPushImageResults struct {
	err error
}

// RegistryClientMockPushImageOrigins contains origins of expectations of the RegistryClient.PushImage
type RegistryClientMockPushImageExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
	originImg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPushImage *mRegistryClientMockPushImage) Optional() *mRegistryClientMockPushImage {
	mmPushImage.optional = true
	return mmPushImage
}

// Expect sets up expected params for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Expect(ctx context.Context, tag string, img v1.Image) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.paramPtrs != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by ExpectParams functions")
	}

	mmPushImage.defaultExpectation.params = &RegistryClientMockPushImageParams{ctx, tag, img}
	mmPushImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPushImage.expectations {
		if minimock.Equal(e.params, mmPushImage.defaultExpectation.params) {
			mmPushImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPushImage.defaultExpectation.params)
		}
	}

	return mmPushImage
}

// ExpectCtxParam1 sets up expected param ctx for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmPushImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPushImage
}

// ExpectTagParam2 sets up expected param tag for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectTagParam2(tag string) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.tag = &tag
	mmPushImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmPushImage
}

// ExpectImgParam3 sets up expected param img for RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectImgParam3(img v1.Image) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.img = &img
	mmPushImage.defaultExpectation.expectationOrigins.originImg = minimock.CallerInfo(1)

	return mmPushImage
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Inspect(f func(ctx context.Context, tag string, img v1.Image)) *mRegistryClientMockPushImage {
	if mmPushImage.mock.inspectFuncPushImage != nil {
		mmPushImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.PushImage")
	}

	mmPushImage.mock.inspectFuncPushImage = f

	return mmPushImage
}

// Return sets up results that will be returned by RegistryClient.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Return(err error) *RegistryClientMock {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{mock: mmPushImage.mock}
	}
	mmPushImage.defaultExpectation.results = &RegistryClientMockPushImageResults{err}
	mmPushImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPushImage.mock
}

// Set uses given function f to mock the RegistryClient.PushImage method
func (mmPushImage *mRegistryClientMockPushImage) Set(f func(ctx context.Context, tag string, img v1.Image) (err error)) *RegistryClientMock {
	if mmPushImage.defaultExpectation != nil {
		mmPushImage.mock.t.Fatalf("Default expectation is already set for the RegistryClient.PushImage method")
	}

	if len(mmPushImage.expectations) > 0 {
		mmPushImage.mock.t.Fatalf("Some expectations are already set for the RegistryClient.PushImage method")
	}

	mmPushImage.mock.funcPushImage = f
	mmPushImage.mock.funcPushImageOrigin = minimock.CallerInfo(1)
	return mmPushImage.mock
}

// When sets expectation for the RegistryClient.PushImage which will trigger the result defined by the following
// Then helper
func (mmPushImage *mRegistryClientMockPushImage) When(ctx context.Context, tag string, img v1.Image) *RegistryClientMockPushImageExpectation {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	expectation := &RegistryClientMockPushImageExpectation{
		mock:               mmPushImage.mock,
		params:             &RegistryClientMockPushImageParams{ctx, tag, img},
		expectationOrigins: RegistryClientMockPushImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPushImage.expectations = append(mmPushImage.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.PushImage return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockPushImageExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockPushImageResults{err}
	return e.mock
}

// Times sets number of times RegistryClient.PushImage should be invoked
func (mmPushImage *mRegistryClientMockPushImage) Times(n uint64) *mRegistryClientMockPushImage {
	if n == 0 {
		mmPushImage.mock.t.Fatalf("Times of RegistryClientMock.PushImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPushImage.expectedInvocations, n)
	mmPushImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPushImage
}

func (mmPushImage *mRegistryClientMockPushImage) invocationsDone() bool {
	if len(mmPushImage.expectations) == 0 && mmPushImage.defaultExpectation == nil && mmPushImage.mock.funcPushImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPushImage.mock.afterPushImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPushImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PushImage implements mm_pkg.RegistryClient
func (mmPushImage *RegistryClientMock) PushImage(ctx context.Context, tag string, img v1.Image) (err error) {
	mm_atomic.AddUint64(&mmPushImage.beforePushImageCounter, 1)
	defer mm_atomic.AddUint64(&mmPushImage.afterPushImageCounter, 1)

	mmPushImage.t.Helper()

	if mmPushImage.inspectFuncPushImage != nil {
		mmPushImage.inspectFuncPushImage(ctx, tag, img)
	}

	mm_params := RegistryClientMockPushImageParams{ctx, tag, img}

	// Record call args
	mmPushImage.PushImageMock.mutex.Lock()
	mmPushImage.PushImageMock.callArgs = append(mmPushImage.PushImageMock.callArgs, &mm_params)
	mmPushImage.PushImageMock.mutex.Unlock()

	for _, e := range mmPushImage.PushImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPushImage.PushImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPushImage.PushImageMock.defaultExpectation.Counter, 1)
		mm_want := mmPushImage.PushImageMock.defaultExpectation.params
		mm_want_ptrs := mmPushImage.PushImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockPushImageParams{ctx, tag, img}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.img != nil && !minimock.Equal(*mm_want_ptrs.img, mm_got.img) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter img, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originImg, *mm_want_ptrs.img, mm_got.img, minimock.Diff(*mm_want_ptrs.img, mm_got.img))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPushImage.PushImageMock.defaultExpectation.results
		if mm_results == nil {
			mmPushImage.t.Fatal("No results are set for the RegistryClientMock.PushImage")
		}
		return (*mm_results).err
	}
	if mmPushImage.funcPushImage != nil {
		return mmPushImage.funcPushImage(ctx, tag, img)
	}
	mmPushImage.t.Fatalf("Unexpected call to RegistryClientMock.PushImage. %v %v %v", ctx, tag, img)
	return
}

// PushImageAfterCounter returns a count of finished RegistryClientMock.PushImage invocations
func (mmPushImage *RegistryClientMock) PushImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushImage.afterPushImageCounter)
}

// PushImageBeforeCounter returns a count of RegistryClientMock.PushImage invocations
func (mmPushImage *RegistryClientMock) PushImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushImage.beforePushImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.PushImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPushImage *mRegistryClientMockPushImage) Calls() []*RegistryClientMockPushImageParams {
	mmPushImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockPushImageParams, len(mmPushImage.callArgs))
	copy(argCopy, mmPushImage.callArgs)

	mmPushImage.mutex.RUnlock()

	return argCopy
}

// MinimockPushImageDone returns true if the count of the PushImage invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockPushImageDone() bool {
	if m.PushImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PushImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PushImageMock.invocationsDone()
}

// MinimockPushImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockPushImageInspect() {
	for _, e := range m.PushImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPushImageCounter := mm_atomic.LoadUint64(&m.afterPushImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PushImageMock.defaultExpectation != nil && afterPushImageCounter < 1 {
		if m.PushImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s", m.PushImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s with params: %#v", m.PushImageMock.defaultExpectation.expectationOrigins.origin, *m.PushImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPushImage != nil && afterPushImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s", m.funcPushImageOrigin)
	}

	if !m.PushImageMock.invocationsDone() && afterPushImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.PushImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PushImageMock.expectedInvocations), m.PushImageMock.expectedInvocationsOrigin, afterPushImageCounter)
	}
}

type mRegistryClientMockWithScope struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockWithScopeExpectation
	expectations       []*RegistryClientMockWithScopeExpectation

	callArgs []*RegistryClientMockWithScopeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockWithScopeExpectation specifies expectation struct of the RegistryClient.WithScope
type RegistryClientMockWithScopeExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockWithScopeParams
	paramPtrs          *RegistryClientMockWithScopeParamPtrs
	expectationOrigins RegistryClientMockWithScopeExpectationOrigins
	results            *RegistryClientMockWithScopeResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockWithScopeParams contains parameters of the RegistryClient.WithScope
type RegistryClientMockWithScopeParams struct {
	scope string
}

// RegistryClientMockWithScopeParamPtrs contains pointers to parameters of the RegistryClient.WithScope
type RegistryClientMockWithScopeParamPtrs struct {
	scope *string
}

// RegistryClientMockWithScopeResults contains results of the RegistryClient.WithScope
type RegistryClientMockWithScopeResults struct {
	r1 mm_pkg.RegistryClient
}

// RegistryClientMockWithScopeOrigins contains origins of expectations of the RegistryClient.WithScope
type RegistryClientMockWithScopeExpectationOrigins struct {
	origin      string
	originScope string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithScope *mRegistryClientMockWithScope) Optional() *mRegistryClientMockWithScope {
	mmWithScope.optional = true
	return mmWithScope
}

// Expect sets up expected params for RegistryClient.WithScope
func (mmWithScope *mRegistryClientMockWithScope) Expect(scope string) *mRegistryClientMockWithScope {
	if mmWithScope.mock.funcWithScope != nil {
		mmWithScope.mock.t.Fatalf("RegistryClientMock.WithScope mock is already set by Set")
	}

	if mmWithScope.defaultExpectation == nil {
		mmWithScope.defaultExpectation = &RegistryClientMockWithScopeExpectation{}
	}

	if mmWithScope.defaultExpectation.paramPtrs != nil {
		mmWithScope.mock.t.Fatalf("RegistryClientMock.WithScope mock is already set by ExpectParams functions")
	}

	mmWithScope.defaultExpectation.params = &RegistryClientMockWithScopeParams{scope}
	mmWithScope.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithScope.expectations {
		if minimock.Equal(e.params, mmWithScope.defaultExpectation.params) {
			mmWithScope.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithScope.defaultExpectation.params)
		}
	}

	return mmWithScope
}

// ExpectScopeParam1 sets up expected param scope for RegistryClient.WithScope
func (mmWithScope *mRegistryClientMockWithScope) ExpectScopeParam1(scope string) *mRegistryClientMockWithScope {
	if mmWithScope.mock.funcWithScope != nil {
		mmWithScope.mock.t.Fatalf("RegistryClientMock.WithScope mock is already set by Set")
	}

	if mmWithScope.defaultExpectation == nil {
		mmWithScope.defaultExpectation = &RegistryClientMockWithScopeExpectation{}
	}

	if mmWithScope.defaultExpectation.params != nil {
		mmWithScope.mock.t.Fatalf("RegistryClientMock.WithScope mock is already set by Expect")
	}

	if mmWithScope.defaultExpectation.paramPtrs == nil {
		mmWithScope.defaultExpectation.paramPtrs = &RegistryClientMockWithScopeParamPtrs{}
	}
	mmWithScope.defaultExpectation.paramPtrs.scope = &scope
	mmWithScope.defaultExpectation.expectationOrigins.originScope = minimock.CallerInfo(1)

	return mmWithScope
}

// Inspect accepts an inspector function that has same arguments as the RegistryClient.WithScope
func (mmWithScope *mRegistryClientMockWithScope) Inspect(f func(scope string)) *mRegistryClientMockWithScope {
	if mmWithScope.mock.inspectFuncWithScope != nil {
		mmWithScope.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.WithScope")
	}

	mmWithScope.mock.inspectFuncWithScope = f

	return mmWithScope
}

// Return sets up results that will be returned by RegistryClient.WithScope
func (mmWithScope *mRegistryClientMockWithScope) Return(r1 mm_pkg.RegistryClient) *RegistryClientMock {
	if mmWithScope.mock.funcWithScope != nil {
		mmWithScope.mock.t.Fatalf("RegistryClientMock.WithScope mock is already set by Set")
	}

	if mmWithScope.defaultExpectation == nil {
		mmWithScope.defaultExpectation = &RegistryClientMockWithScopeExpectation{mock: mmWithScope.mock}
	}
	mmWithScope.defaultExpectation.results = &RegistryClientMockWithScopeResults{r1}
	mmWithScope.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithScope.mock
}

// Set uses given function f to mock the RegistryClient.WithScope method
func (mmWithScope *mRegistryClientMockWithScope) Set(f func(scope string) (r1 mm_pkg.RegistryClient)) *RegistryClientMock {
	if mmWithScope.defaultExpectation != nil {
		mmWithScope.mock.t.Fatalf("Default expectation is already set for the RegistryClient.WithScope method")
	}

	if len(mmWithScope.expectations) > 0 {
		mmWithScope.mock.t.Fatalf("Some expectations are already set for the RegistryClient.WithScope method")
	}

	mmWithScope.mock.funcWithScope = f
	mmWithScope.mock.funcWithScopeOrigin = minimock.CallerInfo(1)
	return mmWithScope.mock
}

// When sets expectation for the RegistryClient.WithScope which will trigger the result defined by the following
// Then helper
func (mmWithScope *mRegistryClientMockWithScope) When(scope string) *RegistryClientMockWithScopeExpectation {
	if mmWithScope.mock.funcWithScope != nil {
		mmWithScope.mock.t.Fatalf("RegistryClientMock.WithScope mock is already set by Set")
	}

	expectation := &RegistryClientMockWithScopeExpectation{
		mock:               mmWithScope.mock,
		params:             &RegistryClientMockWithScopeParams{scope},
		expectationOrigins: RegistryClientMockWithScopeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithScope.expectations = append(mmWithScope.expectations, expectation)
	return expectation
}

// Then sets up RegistryClient.WithScope return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockWithScopeExpectation) Then(r1 mm_pkg.RegistryClient) *RegistryClientMock {
	e.results = &RegistryClientMockWithScopeResults{r1}
	return e.mock
}

// Times sets number of times RegistryClient.WithScope should be invoked
func (mmWithScope *mRegistryClientMockWithScope) Times(n uint64) *mRegistryClientMockWithScope {
	if n == 0 {
		mmWithScope.mock.t.Fatalf("Times of RegistryClientMock.WithScope mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithScope.expectedInvocations, n)
	mmWithScope.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithScope
}

func (mmWithScope *mRegistryClientMockWithScope) invocationsDone() bool {
	if len(mmWithScope.expectations) == 0 && mmWithScope.defaultExpectation == nil && mmWithScope.mock.funcWithScope == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithScope.mock.afterWithScopeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithScope.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithScope implements mm_pkg.RegistryClient
func (mmWithScope *RegistryClientMock) WithScope(scope string) (r1 mm_pkg.RegistryClient) {
	mm_atomic.AddUint64(&mmWithScope.beforeWithScopeCounter, 1)
	defer mm_atomic.AddUint64(&mmWithScope.afterWithScopeCounter, 1)

	mmWithScope.t.Helper()

	if mmWithScope.inspectFuncWithScope != nil {
		mmWithScope.inspectFuncWithScope(scope)
	}

	mm_params := RegistryClientMockWithScopeParams{scope}

	// Record call args
	mmWithScope.WithScopeMock.mutex.Lock()
	mmWithScope.WithScopeMock.callArgs = append(mmWithScope.WithScopeMock.callArgs, &mm_params)
	mmWithScope.WithScopeMock.mutex.Unlock()

	for _, e := range mmWithScope.WithScopeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmWithScope.WithScopeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithScope.WithScopeMock.defaultExpectation.Counter, 1)
		mm_want := mmWithScope.WithScopeMock.defaultExpectation.params
		mm_want_ptrs := mmWithScope.WithScopeMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockWithScopeParams{scope}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.scope != nil && !minimock.Equal(*mm_want_ptrs.scope, mm_got.scope) {
				mmWithScope.t.Errorf("RegistryClientMock.WithScope got unexpected parameter scope, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithScope.WithScopeMock.defaultExpectation.expectationOrigins.originScope, *mm_want_ptrs.scope, mm_got.scope, minimock.Diff(*mm_want_ptrs.scope, mm_got.scope))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithScope.t.Errorf("RegistryClientMock.WithScope got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithScope.WithScopeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithScope.WithScopeMock.defaultExpectation.results
		if mm_results == nil {
			mmWithScope.t.Fatal("No results are set for the RegistryClientMock.WithScope")
		}
		return (*mm_results).r1
	}
	if mmWithScope.funcWithScope != nil {
		return mmWithScope.funcWithScope(scope)
	}
	mmWithScope.t.Fatalf("Unexpected call to RegistryClientMock.WithScope. %v", scope)
	return
}

// WithScopeAfterCounter returns a count of finished RegistryClientMock.WithScope invocations
func (mmWithScope *RegistryClientMock) WithScopeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithScope.afterWithScopeCounter)
}

// WithScopeBeforeCounter returns a count of RegistryClientMock.WithScope invocations
func (mmWithScope *RegistryClientMock) WithScopeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithScope.beforeWithScopeCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.WithScope.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithScope *mRegistryClientMockWithScope) Calls() []*RegistryClientMockWithScopeParams {
	mmWithScope.mutex.RLock()

	argCopy := make([]*RegistryClientMockWithScopeParams, len(mmWithScope.callArgs))
	copy(argCopy, mmWithScope.callArgs)

	mmWithScope.mutex.RUnlock()

	return argCopy
}

// MinimockWithScopeDone returns true if the count of the WithScope invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockWithScopeDone() bool {
	if m.WithScopeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithScopeMock.invocationsDone()
}

// MinimockWithScopeInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockWithScopeInspect() {
	for _, e := range m.WithScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.WithScope at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithScopeCounter := mm_atomic.LoadUint64(&m.afterWithScopeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithScopeMock.defaultExpectation != nil && afterWithScopeCounter < 1 {
		if m.WithScopeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.WithScope at\n%s", m.WithScopeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.WithScope at\n%s with params: %#v", m.WithScopeMock.defaultExpectation.expectationOrigins.origin, *m.WithScopeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithScope != nil && afterWithScopeCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.WithScope at\n%s", m.funcWithScopeOrigin)
	}

	if !m.WithScopeMock.invocationsDone() && afterWithScopeCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.WithScope at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithScopeMock.expectedInvocations), m.WithScopeMock.expectedInvocationsOrigin, afterWithScopeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExtractImageLayersInspect()

			m.MinimockGetImageInspect()

			m.MinimockGetImageConfigInspect()

			m.MinimockGetImageLayersInspect()

			m.MinimockGetLabelInspect()

			m.MinimockGetManifestInspect()

			m.MinimockGetRegistryInspect()

			m.MinimockListRepositoriesInspect()

			m.MinimockListTagsInspect()

			m.MinimockPushImageInspect()

			m.MinimockWithScopeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExtractImageLayersDone() &&
		m.MinimockGetImageDone() &&
		m.MinimockGetImageConfigDone() &&
		m.MinimockGetImageLayersDone() &&
		m.MinimockGetLabelDone() &&
		m.MinimockGetManifestDone() &&
		m.MinimockGetRegistryDone() &&
		m.MinimockListRepositoriesDone() &&
		m.MinimockListTagsDone() &&
		m.MinimockPushImageDone() &&
		m.MinimockWithScopeDone()
}
