// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/deckhouse/deckhouse/pkg/registry.Client -o registry_client_mock.go -n RegistryClientMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_registry "github.com/deckhouse/deckhouse/pkg/registry"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
)

// RegistryClientMock implements mm_registry.Client
type RegistryClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckImageExists          func(ctx context.Context, tag string) (err error)
	funcCheckImageExistsOrigin    string
	inspectFuncCheckImageExists   func(ctx context.Context, tag string)
	afterCheckImageExistsCounter  uint64
	beforeCheckImageExistsCounter uint64
	CheckImageExistsMock          mRegistryClientMockCheckImageExists

	funcGetDigest          func(ctx context.Context, tag string) (hp1 *v1.Hash, err error)
	funcGetDigestOrigin    string
	inspectFuncGetDigest   func(ctx context.Context, tag string)
	afterGetDigestCounter  uint64
	beforeGetDigestCounter uint64
	GetDigestMock          mRegistryClientMockGetDigest

	funcGetImage          func(ctx context.Context, tag string, opts ...mm_registry.ImageGetOption) (i1 mm_registry.Image, err error)
	funcGetImageOrigin    string
	inspectFuncGetImage   func(ctx context.Context, tag string, opts ...mm_registry.ImageGetOption)
	afterGetImageCounter  uint64
	beforeGetImageCounter uint64
	GetImageMock          mRegistryClientMockGetImage

	funcGetImageConfig          func(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error)
	funcGetImageConfigOrigin    string
	inspectFuncGetImageConfig   func(ctx context.Context, tag string)
	afterGetImageConfigCounter  uint64
	beforeGetImageConfigCounter uint64
	GetImageConfigMock          mRegistryClientMockGetImageConfig

	funcGetManifest          func(ctx context.Context, tag string) (m1 mm_registry.ManifestResult, err error)
	funcGetManifestOrigin    string
	inspectFuncGetManifest   func(ctx context.Context, tag string)
	afterGetManifestCounter  uint64
	beforeGetManifestCounter uint64
	GetManifestMock          mRegistryClientMockGetManifest

	funcGetRegistry          func() (s1 string)
	funcGetRegistryOrigin    string
	inspectFuncGetRegistry   func()
	afterGetRegistryCounter  uint64
	beforeGetRegistryCounter uint64
	GetRegistryMock          mRegistryClientMockGetRegistry

	funcListRepositories          func(ctx context.Context, opts ...mm_registry.ListRepositoriesOption) (sa1 []string, err error)
	funcListRepositoriesOrigin    string
	inspectFuncListRepositories   func(ctx context.Context, opts ...mm_registry.ListRepositoriesOption)
	afterListRepositoriesCounter  uint64
	beforeListRepositoriesCounter uint64
	ListRepositoriesMock          mRegistryClientMockListRepositories

	funcListTags          func(ctx context.Context, opts ...mm_registry.ListTagsOption) (sa1 []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context, opts ...mm_registry.ListTagsOption)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mRegistryClientMockListTags

	funcPushImage          func(ctx context.Context, tag string, img v1.Image, opts ...mm_registry.ImagePushOption) (err error)
	funcPushImageOrigin    string
	inspectFuncPushImage   func(ctx context.Context, tag string, img v1.Image, opts ...mm_registry.ImagePushOption)
	afterPushImageCounter  uint64
	beforePushImageCounter uint64
	PushImageMock          mRegistryClientMockPushImage

	funcWithSegment          func(segments ...string) (c1 mm_registry.Client)
	funcWithSegmentOrigin    string
	inspectFuncWithSegment   func(segments ...string)
	afterWithSegmentCounter  uint64
	beforeWithSegmentCounter uint64
	WithSegmentMock          mRegistryClientMockWithSegment
}

// NewRegistryClientMock returns a mock for mm_registry.Client
func NewRegistryClientMock(t minimock.Tester) *RegistryClientMock {
	m := &RegistryClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckImageExistsMock = mRegistryClientMockCheckImageExists{mock: m}
	m.CheckImageExistsMock.callArgs = []*RegistryClientMockCheckImageExistsParams{}

	m.GetDigestMock = mRegistryClientMockGetDigest{mock: m}
	m.GetDigestMock.callArgs = []*RegistryClientMockGetDigestParams{}

	m.GetImageMock = mRegistryClientMockGetImage{mock: m}
	m.GetImageMock.callArgs = []*RegistryClientMockGetImageParams{}

	m.GetImageConfigMock = mRegistryClientMockGetImageConfig{mock: m}
	m.GetImageConfigMock.callArgs = []*RegistryClientMockGetImageConfigParams{}

	m.GetManifestMock = mRegistryClientMockGetManifest{mock: m}
	m.GetManifestMock.callArgs = []*RegistryClientMockGetManifestParams{}

	m.GetRegistryMock = mRegistryClientMockGetRegistry{mock: m}

	m.ListRepositoriesMock = mRegistryClientMockListRepositories{mock: m}
	m.ListRepositoriesMock.callArgs = []*RegistryClientMockListRepositoriesParams{}

	m.ListTagsMock = mRegistryClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*RegistryClientMockListTagsParams{}

	m.PushImageMock = mRegistryClientMockPushImage{mock: m}
	m.PushImageMock.callArgs = []*RegistryClientMockPushImageParams{}

	m.WithSegmentMock = mRegistryClientMockWithSegment{mock: m}
	m.WithSegmentMock.callArgs = []*RegistryClientMockWithSegmentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRegistryClientMockCheckImageExists struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockCheckImageExistsExpectation
	expectations       []*RegistryClientMockCheckImageExistsExpectation

	callArgs []*RegistryClientMockCheckImageExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockCheckImageExistsExpectation specifies expectation struct of the Client.CheckImageExists
type RegistryClientMockCheckImageExistsExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockCheckImageExistsParams
	paramPtrs          *RegistryClientMockCheckImageExistsParamPtrs
	expectationOrigins RegistryClientMockCheckImageExistsExpectationOrigins
	results            *RegistryClientMockCheckImageExistsResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockCheckImageExistsParams contains parameters of the Client.CheckImageExists
type RegistryClientMockCheckImageExistsParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockCheckImageExistsParamPtrs contains pointers to parameters of the Client.CheckImageExists
type RegistryClientMockCheckImageExistsParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockCheckImageExistsResults contains results of the Client.CheckImageExists
type RegistryClientMockCheckImageExistsResults struct {
	err error
}

// RegistryClientMockCheckImageExistsOrigins contains origins of expectations of the Client.CheckImageExists
type RegistryClientMockCheckImageExistsExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) Optional() *mRegistryClientMockCheckImageExists {
	mmCheckImageExists.optional = true
	return mmCheckImageExists
}

// Expect sets up expected params for Client.CheckImageExists
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) Expect(ctx context.Context, tag string) *mRegistryClientMockCheckImageExists {
	if mmCheckImageExists.mock.funcCheckImageExists != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by Set")
	}

	if mmCheckImageExists.defaultExpectation == nil {
		mmCheckImageExists.defaultExpectation = &RegistryClientMockCheckImageExistsExpectation{}
	}

	if mmCheckImageExists.defaultExpectation.paramPtrs != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by ExpectParams functions")
	}

	mmCheckImageExists.defaultExpectation.params = &RegistryClientMockCheckImageExistsParams{ctx, tag}
	mmCheckImageExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckImageExists.expectations {
		if minimock.Equal(e.params, mmCheckImageExists.defaultExpectation.params) {
			mmCheckImageExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckImageExists.defaultExpectation.params)
		}
	}

	return mmCheckImageExists
}

// ExpectCtxParam1 sets up expected param ctx for Client.CheckImageExists
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockCheckImageExists {
	if mmCheckImageExists.mock.funcCheckImageExists != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by Set")
	}

	if mmCheckImageExists.defaultExpectation == nil {
		mmCheckImageExists.defaultExpectation = &RegistryClientMockCheckImageExistsExpectation{}
	}

	if mmCheckImageExists.defaultExpectation.params != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by Expect")
	}

	if mmCheckImageExists.defaultExpectation.paramPtrs == nil {
		mmCheckImageExists.defaultExpectation.paramPtrs = &RegistryClientMockCheckImageExistsParamPtrs{}
	}
	mmCheckImageExists.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckImageExists.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckImageExists
}

// ExpectTagParam2 sets up expected param tag for Client.CheckImageExists
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) ExpectTagParam2(tag string) *mRegistryClientMockCheckImageExists {
	if mmCheckImageExists.mock.funcCheckImageExists != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by Set")
	}

	if mmCheckImageExists.defaultExpectation == nil {
		mmCheckImageExists.defaultExpectation = &RegistryClientMockCheckImageExistsExpectation{}
	}

	if mmCheckImageExists.defaultExpectation.params != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by Expect")
	}

	if mmCheckImageExists.defaultExpectation.paramPtrs == nil {
		mmCheckImageExists.defaultExpectation.paramPtrs = &RegistryClientMockCheckImageExistsParamPtrs{}
	}
	mmCheckImageExists.defaultExpectation.paramPtrs.tag = &tag
	mmCheckImageExists.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmCheckImageExists
}

// Inspect accepts an inspector function that has same arguments as the Client.CheckImageExists
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockCheckImageExists {
	if mmCheckImageExists.mock.inspectFuncCheckImageExists != nil {
		mmCheckImageExists.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.CheckImageExists")
	}

	mmCheckImageExists.mock.inspectFuncCheckImageExists = f

	return mmCheckImageExists
}

// Return sets up results that will be returned by Client.CheckImageExists
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) Return(err error) *RegistryClientMock {
	if mmCheckImageExists.mock.funcCheckImageExists != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by Set")
	}

	if mmCheckImageExists.defaultExpectation == nil {
		mmCheckImageExists.defaultExpectation = &RegistryClientMockCheckImageExistsExpectation{mock: mmCheckImageExists.mock}
	}
	mmCheckImageExists.defaultExpectation.results = &RegistryClientMockCheckImageExistsResults{err}
	mmCheckImageExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckImageExists.mock
}

// Set uses given function f to mock the Client.CheckImageExists method
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) Set(f func(ctx context.Context, tag string) (err error)) *RegistryClientMock {
	if mmCheckImageExists.defaultExpectation != nil {
		mmCheckImageExists.mock.t.Fatalf("Default expectation is already set for the Client.CheckImageExists method")
	}

	if len(mmCheckImageExists.expectations) > 0 {
		mmCheckImageExists.mock.t.Fatalf("Some expectations are already set for the Client.CheckImageExists method")
	}

	mmCheckImageExists.mock.funcCheckImageExists = f
	mmCheckImageExists.mock.funcCheckImageExistsOrigin = minimock.CallerInfo(1)
	return mmCheckImageExists.mock
}

// When sets expectation for the Client.CheckImageExists which will trigger the result defined by the following
// Then helper
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) When(ctx context.Context, tag string) *RegistryClientMockCheckImageExistsExpectation {
	if mmCheckImageExists.mock.funcCheckImageExists != nil {
		mmCheckImageExists.mock.t.Fatalf("RegistryClientMock.CheckImageExists mock is already set by Set")
	}

	expectation := &RegistryClientMockCheckImageExistsExpectation{
		mock:               mmCheckImageExists.mock,
		params:             &RegistryClientMockCheckImageExistsParams{ctx, tag},
		expectationOrigins: RegistryClientMockCheckImageExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckImageExists.expectations = append(mmCheckImageExists.expectations, expectation)
	return expectation
}

// Then sets up Client.CheckImageExists return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockCheckImageExistsExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockCheckImageExistsResults{err}
	return e.mock
}

// Times sets number of times Client.CheckImageExists should be invoked
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) Times(n uint64) *mRegistryClientMockCheckImageExists {
	if n == 0 {
		mmCheckImageExists.mock.t.Fatalf("Times of RegistryClientMock.CheckImageExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckImageExists.expectedInvocations, n)
	mmCheckImageExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckImageExists
}

func (mmCheckImageExists *mRegistryClientMockCheckImageExists) invocationsDone() bool {
	if len(mmCheckImageExists.expectations) == 0 && mmCheckImageExists.defaultExpectation == nil && mmCheckImageExists.mock.funcCheckImageExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckImageExists.mock.afterCheckImageExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckImageExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckImageExists implements mm_registry.Client
func (mmCheckImageExists *RegistryClientMock) CheckImageExists(ctx context.Context, tag string) (err error) {
	mm_atomic.AddUint64(&mmCheckImageExists.beforeCheckImageExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckImageExists.afterCheckImageExistsCounter, 1)

	mmCheckImageExists.t.Helper()

	if mmCheckImageExists.inspectFuncCheckImageExists != nil {
		mmCheckImageExists.inspectFuncCheckImageExists(ctx, tag)
	}

	mm_params := RegistryClientMockCheckImageExistsParams{ctx, tag}

	// Record call args
	mmCheckImageExists.CheckImageExistsMock.mutex.Lock()
	mmCheckImageExists.CheckImageExistsMock.callArgs = append(mmCheckImageExists.CheckImageExistsMock.callArgs, &mm_params)
	mmCheckImageExists.CheckImageExistsMock.mutex.Unlock()

	for _, e := range mmCheckImageExists.CheckImageExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckImageExists.CheckImageExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckImageExists.CheckImageExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckImageExists.CheckImageExistsMock.defaultExpectation.params
		mm_want_ptrs := mmCheckImageExists.CheckImageExistsMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockCheckImageExistsParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckImageExists.t.Errorf("RegistryClientMock.CheckImageExists got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckImageExists.CheckImageExistsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmCheckImageExists.t.Errorf("RegistryClientMock.CheckImageExists got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckImageExists.CheckImageExistsMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckImageExists.t.Errorf("RegistryClientMock.CheckImageExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckImageExists.CheckImageExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckImageExists.CheckImageExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckImageExists.t.Fatal("No results are set for the RegistryClientMock.CheckImageExists")
		}
		return (*mm_results).err
	}
	if mmCheckImageExists.funcCheckImageExists != nil {
		return mmCheckImageExists.funcCheckImageExists(ctx, tag)
	}
	mmCheckImageExists.t.Fatalf("Unexpected call to RegistryClientMock.CheckImageExists. %v %v", ctx, tag)
	return
}

// CheckImageExistsAfterCounter returns a count of finished RegistryClientMock.CheckImageExists invocations
func (mmCheckImageExists *RegistryClientMock) CheckImageExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckImageExists.afterCheckImageExistsCounter)
}

// CheckImageExistsBeforeCounter returns a count of RegistryClientMock.CheckImageExists invocations
func (mmCheckImageExists *RegistryClientMock) CheckImageExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckImageExists.beforeCheckImageExistsCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.CheckImageExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckImageExists *mRegistryClientMockCheckImageExists) Calls() []*RegistryClientMockCheckImageExistsParams {
	mmCheckImageExists.mutex.RLock()

	argCopy := make([]*RegistryClientMockCheckImageExistsParams, len(mmCheckImageExists.callArgs))
	copy(argCopy, mmCheckImageExists.callArgs)

	mmCheckImageExists.mutex.RUnlock()

	return argCopy
}

// MinimockCheckImageExistsDone returns true if the count of the CheckImageExists invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockCheckImageExistsDone() bool {
	if m.CheckImageExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckImageExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckImageExistsMock.invocationsDone()
}

// MinimockCheckImageExistsInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockCheckImageExistsInspect() {
	for _, e := range m.CheckImageExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.CheckImageExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckImageExistsCounter := mm_atomic.LoadUint64(&m.afterCheckImageExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckImageExistsMock.defaultExpectation != nil && afterCheckImageExistsCounter < 1 {
		if m.CheckImageExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.CheckImageExists at\n%s", m.CheckImageExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.CheckImageExists at\n%s with params: %#v", m.CheckImageExistsMock.defaultExpectation.expectationOrigins.origin, *m.CheckImageExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckImageExists != nil && afterCheckImageExistsCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.CheckImageExists at\n%s", m.funcCheckImageExistsOrigin)
	}

	if !m.CheckImageExistsMock.invocationsDone() && afterCheckImageExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.CheckImageExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckImageExistsMock.expectedInvocations), m.CheckImageExistsMock.expectedInvocationsOrigin, afterCheckImageExistsCounter)
	}
}

type mRegistryClientMockGetDigest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetDigestExpectation
	expectations       []*RegistryClientMockGetDigestExpectation

	callArgs []*RegistryClientMockGetDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetDigestExpectation specifies expectation struct of the Client.GetDigest
type RegistryClientMockGetDigestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetDigestParams
	paramPtrs          *RegistryClientMockGetDigestParamPtrs
	expectationOrigins RegistryClientMockGetDigestExpectationOrigins
	results            *RegistryClientMockGetDigestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetDigestParams contains parameters of the Client.GetDigest
type RegistryClientMockGetDigestParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetDigestParamPtrs contains pointers to parameters of the Client.GetDigest
type RegistryClientMockGetDigestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetDigestResults contains results of the Client.GetDigest
type RegistryClientMockGetDigestResults struct {
	hp1 *v1.Hash
	err error
}

// RegistryClientMockGetDigestOrigins contains origins of expectations of the Client.GetDigest
type RegistryClientMockGetDigestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDigest *mRegistryClientMockGetDigest) Optional() *mRegistryClientMockGetDigest {
	mmGetDigest.optional = true
	return mmGetDigest
}

// Expect sets up expected params for Client.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) Expect(ctx context.Context, tag string) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{}
	}

	if mmGetDigest.defaultExpectation.paramPtrs != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by ExpectParams functions")
	}

	mmGetDigest.defaultExpectation.params = &RegistryClientMockGetDigestParams{ctx, tag}
	mmGetDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDigest.expectations {
		if minimock.Equal(e.params, mmGetDigest.defaultExpectation.params) {
			mmGetDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDigest.defaultExpectation.params)
		}
	}

	return mmGetDigest
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{}
	}

	if mmGetDigest.defaultExpectation.params != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Expect")
	}

	if mmGetDigest.defaultExpectation.paramPtrs == nil {
		mmGetDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetDigestParamPtrs{}
	}
	mmGetDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDigest
}

// ExpectTagParam2 sets up expected param tag for Client.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) ExpectTagParam2(tag string) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{}
	}

	if mmGetDigest.defaultExpectation.params != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Expect")
	}

	if mmGetDigest.defaultExpectation.paramPtrs == nil {
		mmGetDigest.defaultExpectation.paramPtrs = &RegistryClientMockGetDigestParamPtrs{}
	}
	mmGetDigest.defaultExpectation.paramPtrs.tag = &tag
	mmGetDigest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetDigest
}

// Inspect accepts an inspector function that has same arguments as the Client.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetDigest {
	if mmGetDigest.mock.inspectFuncGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetDigest")
	}

	mmGetDigest.mock.inspectFuncGetDigest = f

	return mmGetDigest
}

// Return sets up results that will be returned by Client.GetDigest
func (mmGetDigest *mRegistryClientMockGetDigest) Return(hp1 *v1.Hash, err error) *RegistryClientMock {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	if mmGetDigest.defaultExpectation == nil {
		mmGetDigest.defaultExpectation = &RegistryClientMockGetDigestExpectation{mock: mmGetDigest.mock}
	}
	mmGetDigest.defaultExpectation.results = &RegistryClientMockGetDigestResults{hp1, err}
	mmGetDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDigest.mock
}

// Set uses given function f to mock the Client.GetDigest method
func (mmGetDigest *mRegistryClientMockGetDigest) Set(f func(ctx context.Context, tag string) (hp1 *v1.Hash, err error)) *RegistryClientMock {
	if mmGetDigest.defaultExpectation != nil {
		mmGetDigest.mock.t.Fatalf("Default expectation is already set for the Client.GetDigest method")
	}

	if len(mmGetDigest.expectations) > 0 {
		mmGetDigest.mock.t.Fatalf("Some expectations are already set for the Client.GetDigest method")
	}

	mmGetDigest.mock.funcGetDigest = f
	mmGetDigest.mock.funcGetDigestOrigin = minimock.CallerInfo(1)
	return mmGetDigest.mock
}

// When sets expectation for the Client.GetDigest which will trigger the result defined by the following
// Then helper
func (mmGetDigest *mRegistryClientMockGetDigest) When(ctx context.Context, tag string) *RegistryClientMockGetDigestExpectation {
	if mmGetDigest.mock.funcGetDigest != nil {
		mmGetDigest.mock.t.Fatalf("RegistryClientMock.GetDigest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetDigestExpectation{
		mock:               mmGetDigest.mock,
		params:             &RegistryClientMockGetDigestParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDigest.expectations = append(mmGetDigest.expectations, expectation)
	return expectation
}

// Then sets up Client.GetDigest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetDigestExpectation) Then(hp1 *v1.Hash, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetDigestResults{hp1, err}
	return e.mock
}

// Times sets number of times Client.GetDigest should be invoked
func (mmGetDigest *mRegistryClientMockGetDigest) Times(n uint64) *mRegistryClientMockGetDigest {
	if n == 0 {
		mmGetDigest.mock.t.Fatalf("Times of RegistryClientMock.GetDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDigest.expectedInvocations, n)
	mmGetDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDigest
}

func (mmGetDigest *mRegistryClientMockGetDigest) invocationsDone() bool {
	if len(mmGetDigest.expectations) == 0 && mmGetDigest.defaultExpectation == nil && mmGetDigest.mock.funcGetDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDigest.mock.afterGetDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDigest implements mm_registry.Client
func (mmGetDigest *RegistryClientMock) GetDigest(ctx context.Context, tag string) (hp1 *v1.Hash, err error) {
	mm_atomic.AddUint64(&mmGetDigest.beforeGetDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDigest.afterGetDigestCounter, 1)

	mmGetDigest.t.Helper()

	if mmGetDigest.inspectFuncGetDigest != nil {
		mmGetDigest.inspectFuncGetDigest(ctx, tag)
	}

	mm_params := RegistryClientMockGetDigestParams{ctx, tag}

	// Record call args
	mmGetDigest.GetDigestMock.mutex.Lock()
	mmGetDigest.GetDigestMock.callArgs = append(mmGetDigest.GetDigestMock.callArgs, &mm_params)
	mmGetDigest.GetDigestMock.mutex.Unlock()

	for _, e := range mmGetDigest.GetDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmGetDigest.GetDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDigest.GetDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDigest.GetDigestMock.defaultExpectation.params
		mm_want_ptrs := mmGetDigest.GetDigestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetDigestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDigest.t.Errorf("RegistryClientMock.GetDigest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDigest.GetDigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetDigest.t.Errorf("RegistryClientMock.GetDigest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDigest.GetDigestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDigest.t.Errorf("RegistryClientMock.GetDigest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDigest.GetDigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDigest.GetDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDigest.t.Fatal("No results are set for the RegistryClientMock.GetDigest")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmGetDigest.funcGetDigest != nil {
		return mmGetDigest.funcGetDigest(ctx, tag)
	}
	mmGetDigest.t.Fatalf("Unexpected call to RegistryClientMock.GetDigest. %v %v", ctx, tag)
	return
}

// GetDigestAfterCounter returns a count of finished RegistryClientMock.GetDigest invocations
func (mmGetDigest *RegistryClientMock) GetDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigest.afterGetDigestCounter)
}

// GetDigestBeforeCounter returns a count of RegistryClientMock.GetDigest invocations
func (mmGetDigest *RegistryClientMock) GetDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDigest.beforeGetDigestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDigest *mRegistryClientMockGetDigest) Calls() []*RegistryClientMockGetDigestParams {
	mmGetDigest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetDigestParams, len(mmGetDigest.callArgs))
	copy(argCopy, mmGetDigest.callArgs)

	mmGetDigest.mutex.RUnlock()

	return argCopy
}

// MinimockGetDigestDone returns true if the count of the GetDigest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetDigestDone() bool {
	if m.GetDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDigestMock.invocationsDone()
}

// MinimockGetDigestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetDigestInspect() {
	for _, e := range m.GetDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDigestCounter := mm_atomic.LoadUint64(&m.afterGetDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDigestMock.defaultExpectation != nil && afterGetDigestCounter < 1 {
		if m.GetDigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s", m.GetDigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s with params: %#v", m.GetDigestMock.defaultExpectation.expectationOrigins.origin, *m.GetDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDigest != nil && afterGetDigestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetDigest at\n%s", m.funcGetDigestOrigin)
	}

	if !m.GetDigestMock.invocationsDone() && afterGetDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetDigest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDigestMock.expectedInvocations), m.GetDigestMock.expectedInvocationsOrigin, afterGetDigestCounter)
	}
}

type mRegistryClientMockGetImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageExpectation
	expectations       []*RegistryClientMockGetImageExpectation

	callArgs []*RegistryClientMockGetImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageExpectation specifies expectation struct of the Client.GetImage
type RegistryClientMockGetImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageParams
	paramPtrs          *RegistryClientMockGetImageParamPtrs
	expectationOrigins RegistryClientMockGetImageExpectationOrigins
	results            *RegistryClientMockGetImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageParams contains parameters of the Client.GetImage
type RegistryClientMockGetImageParams struct {
	ctx  context.Context
	tag  string
	opts []mm_registry.ImageGetOption
}

// RegistryClientMockGetImageParamPtrs contains pointers to parameters of the Client.GetImage
type RegistryClientMockGetImageParamPtrs struct {
	ctx  *context.Context
	tag  *string
	opts *[]mm_registry.ImageGetOption
}

// RegistryClientMockGetImageResults contains results of the Client.GetImage
type RegistryClientMockGetImageResults struct {
	i1  mm_registry.Image
	err error
}

// RegistryClientMockGetImageOrigins contains origins of expectations of the Client.GetImage
type RegistryClientMockGetImageExpectationOrigins struct {
	origin     string
	originCtx  string
	originTag  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImage *mRegistryClientMockGetImage) Optional() *mRegistryClientMockGetImage {
	mmGetImage.optional = true
	return mmGetImage
}

// Expect sets up expected params for Client.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Expect(ctx context.Context, tag string, opts ...mm_registry.ImageGetOption) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.paramPtrs != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by ExpectParams functions")
	}

	mmGetImage.defaultExpectation.params = &RegistryClientMockGetImageParams{ctx, tag, opts}
	mmGetImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImage.expectations {
		if minimock.Equal(e.params, mmGetImage.defaultExpectation.params) {
			mmGetImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImage.defaultExpectation.params)
		}
	}

	return mmGetImage
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImage
}

// ExpectTagParam2 sets up expected param tag for Client.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectTagParam2(tag string) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.tag = &tag
	mmGetImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImage
}

// ExpectOptsParam3 sets up expected param opts for Client.GetImage
func (mmGetImage *mRegistryClientMockGetImage) ExpectOptsParam3(opts ...mm_registry.ImageGetOption) *mRegistryClientMockGetImage {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{}
	}

	if mmGetImage.defaultExpectation.params != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Expect")
	}

	if mmGetImage.defaultExpectation.paramPtrs == nil {
		mmGetImage.defaultExpectation.paramPtrs = &RegistryClientMockGetImageParamPtrs{}
	}
	mmGetImage.defaultExpectation.paramPtrs.opts = &opts
	mmGetImage.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetImage
}

// Inspect accepts an inspector function that has same arguments as the Client.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Inspect(f func(ctx context.Context, tag string, opts ...mm_registry.ImageGetOption)) *mRegistryClientMockGetImage {
	if mmGetImage.mock.inspectFuncGetImage != nil {
		mmGetImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImage")
	}

	mmGetImage.mock.inspectFuncGetImage = f

	return mmGetImage
}

// Return sets up results that will be returned by Client.GetImage
func (mmGetImage *mRegistryClientMockGetImage) Return(i1 mm_registry.Image, err error) *RegistryClientMock {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	if mmGetImage.defaultExpectation == nil {
		mmGetImage.defaultExpectation = &RegistryClientMockGetImageExpectation{mock: mmGetImage.mock}
	}
	mmGetImage.defaultExpectation.results = &RegistryClientMockGetImageResults{i1, err}
	mmGetImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// Set uses given function f to mock the Client.GetImage method
func (mmGetImage *mRegistryClientMockGetImage) Set(f func(ctx context.Context, tag string, opts ...mm_registry.ImageGetOption) (i1 mm_registry.Image, err error)) *RegistryClientMock {
	if mmGetImage.defaultExpectation != nil {
		mmGetImage.mock.t.Fatalf("Default expectation is already set for the Client.GetImage method")
	}

	if len(mmGetImage.expectations) > 0 {
		mmGetImage.mock.t.Fatalf("Some expectations are already set for the Client.GetImage method")
	}

	mmGetImage.mock.funcGetImage = f
	mmGetImage.mock.funcGetImageOrigin = minimock.CallerInfo(1)
	return mmGetImage.mock
}

// When sets expectation for the Client.GetImage which will trigger the result defined by the following
// Then helper
func (mmGetImage *mRegistryClientMockGetImage) When(ctx context.Context, tag string, opts ...mm_registry.ImageGetOption) *RegistryClientMockGetImageExpectation {
	if mmGetImage.mock.funcGetImage != nil {
		mmGetImage.mock.t.Fatalf("RegistryClientMock.GetImage mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageExpectation{
		mock:               mmGetImage.mock,
		params:             &RegistryClientMockGetImageParams{ctx, tag, opts},
		expectationOrigins: RegistryClientMockGetImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImage.expectations = append(mmGetImage.expectations, expectation)
	return expectation
}

// Then sets up Client.GetImage return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageExpectation) Then(i1 mm_registry.Image, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageResults{i1, err}
	return e.mock
}

// Times sets number of times Client.GetImage should be invoked
func (mmGetImage *mRegistryClientMockGetImage) Times(n uint64) *mRegistryClientMockGetImage {
	if n == 0 {
		mmGetImage.mock.t.Fatalf("Times of RegistryClientMock.GetImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImage.expectedInvocations, n)
	mmGetImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImage
}

func (mmGetImage *mRegistryClientMockGetImage) invocationsDone() bool {
	if len(mmGetImage.expectations) == 0 && mmGetImage.defaultExpectation == nil && mmGetImage.mock.funcGetImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImage.mock.afterGetImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImage implements mm_registry.Client
func (mmGetImage *RegistryClientMock) GetImage(ctx context.Context, tag string, opts ...mm_registry.ImageGetOption) (i1 mm_registry.Image, err error) {
	mm_atomic.AddUint64(&mmGetImage.beforeGetImageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImage.afterGetImageCounter, 1)

	mmGetImage.t.Helper()

	if mmGetImage.inspectFuncGetImage != nil {
		mmGetImage.inspectFuncGetImage(ctx, tag, opts...)
	}

	mm_params := RegistryClientMockGetImageParams{ctx, tag, opts}

	// Record call args
	mmGetImage.GetImageMock.mutex.Lock()
	mmGetImage.GetImageMock.callArgs = append(mmGetImage.GetImageMock.callArgs, &mm_params)
	mmGetImage.GetImageMock.mutex.Unlock()

	for _, e := range mmGetImage.GetImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetImage.GetImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImage.GetImageMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImage.GetImageMock.defaultExpectation.params
		mm_want_ptrs := mmGetImage.GetImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageParams{ctx, tag, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImage.t.Errorf("RegistryClientMock.GetImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImage.GetImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImage.GetImageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImage.t.Fatal("No results are set for the RegistryClientMock.GetImage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetImage.funcGetImage != nil {
		return mmGetImage.funcGetImage(ctx, tag, opts...)
	}
	mmGetImage.t.Fatalf("Unexpected call to RegistryClientMock.GetImage. %v %v %v", ctx, tag, opts)
	return
}

// GetImageAfterCounter returns a count of finished RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.afterGetImageCounter)
}

// GetImageBeforeCounter returns a count of RegistryClientMock.GetImage invocations
func (mmGetImage *RegistryClientMock) GetImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImage.beforeGetImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImage *mRegistryClientMockGetImage) Calls() []*RegistryClientMockGetImageParams {
	mmGetImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageParams, len(mmGetImage.callArgs))
	copy(argCopy, mmGetImage.callArgs)

	mmGetImage.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageDone returns true if the count of the GetImage invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageDone() bool {
	if m.GetImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageMock.invocationsDone()
}

// MinimockGetImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageInspect() {
	for _, e := range m.GetImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageCounter := mm_atomic.LoadUint64(&m.afterGetImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageMock.defaultExpectation != nil && afterGetImageCounter < 1 {
		if m.GetImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.GetImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s with params: %#v", m.GetImageMock.defaultExpectation.expectationOrigins.origin, *m.GetImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImage != nil && afterGetImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImage at\n%s", m.funcGetImageOrigin)
	}

	if !m.GetImageMock.invocationsDone() && afterGetImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageMock.expectedInvocations), m.GetImageMock.expectedInvocationsOrigin, afterGetImageCounter)
	}
}

type mRegistryClientMockGetImageConfig struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetImageConfigExpectation
	expectations       []*RegistryClientMockGetImageConfigExpectation

	callArgs []*RegistryClientMockGetImageConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetImageConfigExpectation specifies expectation struct of the Client.GetImageConfig
type RegistryClientMockGetImageConfigExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetImageConfigParams
	paramPtrs          *RegistryClientMockGetImageConfigParamPtrs
	expectationOrigins RegistryClientMockGetImageConfigExpectationOrigins
	results            *RegistryClientMockGetImageConfigResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetImageConfigParams contains parameters of the Client.GetImageConfig
type RegistryClientMockGetImageConfigParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetImageConfigParamPtrs contains pointers to parameters of the Client.GetImageConfig
type RegistryClientMockGetImageConfigParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetImageConfigResults contains results of the Client.GetImageConfig
type RegistryClientMockGetImageConfigResults struct {
	cp1 *v1.ConfigFile
	err error
}

// RegistryClientMockGetImageConfigOrigins contains origins of expectations of the Client.GetImageConfig
type RegistryClientMockGetImageConfigExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Optional() *mRegistryClientMockGetImageConfig {
	mmGetImageConfig.optional = true
	return mmGetImageConfig
}

// Expect sets up expected params for Client.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Expect(ctx context.Context, tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by ExpectParams functions")
	}

	mmGetImageConfig.defaultExpectation.params = &RegistryClientMockGetImageConfigParams{ctx, tag}
	mmGetImageConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetImageConfig.expectations {
		if minimock.Equal(e.params, mmGetImageConfig.defaultExpectation.params) {
			mmGetImageConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetImageConfig.defaultExpectation.params)
		}
	}

	return mmGetImageConfig
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetImageConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// ExpectTagParam2 sets up expected param tag for Client.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) ExpectTagParam2(tag string) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{}
	}

	if mmGetImageConfig.defaultExpectation.params != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Expect")
	}

	if mmGetImageConfig.defaultExpectation.paramPtrs == nil {
		mmGetImageConfig.defaultExpectation.paramPtrs = &RegistryClientMockGetImageConfigParamPtrs{}
	}
	mmGetImageConfig.defaultExpectation.paramPtrs.tag = &tag
	mmGetImageConfig.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetImageConfig
}

// Inspect accepts an inspector function that has same arguments as the Client.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetImageConfig {
	if mmGetImageConfig.mock.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetImageConfig")
	}

	mmGetImageConfig.mock.inspectFuncGetImageConfig = f

	return mmGetImageConfig
}

// Return sets up results that will be returned by Client.GetImageConfig
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Return(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	if mmGetImageConfig.defaultExpectation == nil {
		mmGetImageConfig.defaultExpectation = &RegistryClientMockGetImageConfigExpectation{mock: mmGetImageConfig.mock}
	}
	mmGetImageConfig.defaultExpectation.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	mmGetImageConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// Set uses given function f to mock the Client.GetImageConfig method
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Set(f func(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error)) *RegistryClientMock {
	if mmGetImageConfig.defaultExpectation != nil {
		mmGetImageConfig.mock.t.Fatalf("Default expectation is already set for the Client.GetImageConfig method")
	}

	if len(mmGetImageConfig.expectations) > 0 {
		mmGetImageConfig.mock.t.Fatalf("Some expectations are already set for the Client.GetImageConfig method")
	}

	mmGetImageConfig.mock.funcGetImageConfig = f
	mmGetImageConfig.mock.funcGetImageConfigOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig.mock
}

// When sets expectation for the Client.GetImageConfig which will trigger the result defined by the following
// Then helper
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) When(ctx context.Context, tag string) *RegistryClientMockGetImageConfigExpectation {
	if mmGetImageConfig.mock.funcGetImageConfig != nil {
		mmGetImageConfig.mock.t.Fatalf("RegistryClientMock.GetImageConfig mock is already set by Set")
	}

	expectation := &RegistryClientMockGetImageConfigExpectation{
		mock:               mmGetImageConfig.mock,
		params:             &RegistryClientMockGetImageConfigParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetImageConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetImageConfig.expectations = append(mmGetImageConfig.expectations, expectation)
	return expectation
}

// Then sets up Client.GetImageConfig return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetImageConfigExpectation) Then(cp1 *v1.ConfigFile, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetImageConfigResults{cp1, err}
	return e.mock
}

// Times sets number of times Client.GetImageConfig should be invoked
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Times(n uint64) *mRegistryClientMockGetImageConfig {
	if n == 0 {
		mmGetImageConfig.mock.t.Fatalf("Times of RegistryClientMock.GetImageConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetImageConfig.expectedInvocations, n)
	mmGetImageConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetImageConfig
}

func (mmGetImageConfig *mRegistryClientMockGetImageConfig) invocationsDone() bool {
	if len(mmGetImageConfig.expectations) == 0 && mmGetImageConfig.defaultExpectation == nil && mmGetImageConfig.mock.funcGetImageConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.mock.afterGetImageConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetImageConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetImageConfig implements mm_registry.Client
func (mmGetImageConfig *RegistryClientMock) GetImageConfig(ctx context.Context, tag string) (cp1 *v1.ConfigFile, err error) {
	mm_atomic.AddUint64(&mmGetImageConfig.beforeGetImageConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetImageConfig.afterGetImageConfigCounter, 1)

	mmGetImageConfig.t.Helper()

	if mmGetImageConfig.inspectFuncGetImageConfig != nil {
		mmGetImageConfig.inspectFuncGetImageConfig(ctx, tag)
	}

	mm_params := RegistryClientMockGetImageConfigParams{ctx, tag}

	// Record call args
	mmGetImageConfig.GetImageConfigMock.mutex.Lock()
	mmGetImageConfig.GetImageConfigMock.callArgs = append(mmGetImageConfig.GetImageConfigMock.callArgs, &mm_params)
	mmGetImageConfig.GetImageConfigMock.mutex.Unlock()

	for _, e := range mmGetImageConfig.GetImageConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetImageConfig.GetImageConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetImageConfig.GetImageConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetImageConfig.GetImageConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetImageConfig.GetImageConfigMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetImageConfigParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetImageConfig.t.Errorf("RegistryClientMock.GetImageConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetImageConfig.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetImageConfig.GetImageConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetImageConfig.t.Fatal("No results are set for the RegistryClientMock.GetImageConfig")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetImageConfig.funcGetImageConfig != nil {
		return mmGetImageConfig.funcGetImageConfig(ctx, tag)
	}
	mmGetImageConfig.t.Fatalf("Unexpected call to RegistryClientMock.GetImageConfig. %v %v", ctx, tag)
	return
}

// GetImageConfigAfterCounter returns a count of finished RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.afterGetImageConfigCounter)
}

// GetImageConfigBeforeCounter returns a count of RegistryClientMock.GetImageConfig invocations
func (mmGetImageConfig *RegistryClientMock) GetImageConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetImageConfig.beforeGetImageConfigCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetImageConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetImageConfig *mRegistryClientMockGetImageConfig) Calls() []*RegistryClientMockGetImageConfigParams {
	mmGetImageConfig.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetImageConfigParams, len(mmGetImageConfig.callArgs))
	copy(argCopy, mmGetImageConfig.callArgs)

	mmGetImageConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetImageConfigDone returns true if the count of the GetImageConfig invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetImageConfigDone() bool {
	if m.GetImageConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetImageConfigMock.invocationsDone()
}

// MinimockGetImageConfigInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetImageConfigInspect() {
	for _, e := range m.GetImageConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetImageConfigCounter := mm_atomic.LoadUint64(&m.afterGetImageConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetImageConfigMock.defaultExpectation != nil && afterGetImageConfigCounter < 1 {
		if m.GetImageConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.GetImageConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s with params: %#v", m.GetImageConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetImageConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetImageConfig != nil && afterGetImageConfigCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetImageConfig at\n%s", m.funcGetImageConfigOrigin)
	}

	if !m.GetImageConfigMock.invocationsDone() && afterGetImageConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetImageConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetImageConfigMock.expectedInvocations), m.GetImageConfigMock.expectedInvocationsOrigin, afterGetImageConfigCounter)
	}
}

type mRegistryClientMockGetManifest struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetManifestExpectation
	expectations       []*RegistryClientMockGetManifestExpectation

	callArgs []*RegistryClientMockGetManifestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetManifestExpectation specifies expectation struct of the Client.GetManifest
type RegistryClientMockGetManifestExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockGetManifestParams
	paramPtrs          *RegistryClientMockGetManifestParamPtrs
	expectationOrigins RegistryClientMockGetManifestExpectationOrigins
	results            *RegistryClientMockGetManifestResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockGetManifestParams contains parameters of the Client.GetManifest
type RegistryClientMockGetManifestParams struct {
	ctx context.Context
	tag string
}

// RegistryClientMockGetManifestParamPtrs contains pointers to parameters of the Client.GetManifest
type RegistryClientMockGetManifestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// RegistryClientMockGetManifestResults contains results of the Client.GetManifest
type RegistryClientMockGetManifestResults struct {
	m1  mm_registry.ManifestResult
	err error
}

// RegistryClientMockGetManifestOrigins contains origins of expectations of the Client.GetManifest
type RegistryClientMockGetManifestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetManifest *mRegistryClientMockGetManifest) Optional() *mRegistryClientMockGetManifest {
	mmGetManifest.optional = true
	return mmGetManifest
}

// Expect sets up expected params for Client.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Expect(ctx context.Context, tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.paramPtrs != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by ExpectParams functions")
	}

	mmGetManifest.defaultExpectation.params = &RegistryClientMockGetManifestParams{ctx, tag}
	mmGetManifest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetManifest.expectations {
		if minimock.Equal(e.params, mmGetManifest.defaultExpectation.params) {
			mmGetManifest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetManifest.defaultExpectation.params)
		}
	}

	return mmGetManifest
}

// ExpectCtxParam1 sets up expected param ctx for Client.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetManifest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetManifest
}

// ExpectTagParam2 sets up expected param tag for Client.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) ExpectTagParam2(tag string) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{}
	}

	if mmGetManifest.defaultExpectation.params != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Expect")
	}

	if mmGetManifest.defaultExpectation.paramPtrs == nil {
		mmGetManifest.defaultExpectation.paramPtrs = &RegistryClientMockGetManifestParamPtrs{}
	}
	mmGetManifest.defaultExpectation.paramPtrs.tag = &tag
	mmGetManifest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmGetManifest
}

// Inspect accepts an inspector function that has same arguments as the Client.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Inspect(f func(ctx context.Context, tag string)) *mRegistryClientMockGetManifest {
	if mmGetManifest.mock.inspectFuncGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetManifest")
	}

	mmGetManifest.mock.inspectFuncGetManifest = f

	return mmGetManifest
}

// Return sets up results that will be returned by Client.GetManifest
func (mmGetManifest *mRegistryClientMockGetManifest) Return(m1 mm_registry.ManifestResult, err error) *RegistryClientMock {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	if mmGetManifest.defaultExpectation == nil {
		mmGetManifest.defaultExpectation = &RegistryClientMockGetManifestExpectation{mock: mmGetManifest.mock}
	}
	mmGetManifest.defaultExpectation.results = &RegistryClientMockGetManifestResults{m1, err}
	mmGetManifest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// Set uses given function f to mock the Client.GetManifest method
func (mmGetManifest *mRegistryClientMockGetManifest) Set(f func(ctx context.Context, tag string) (m1 mm_registry.ManifestResult, err error)) *RegistryClientMock {
	if mmGetManifest.defaultExpectation != nil {
		mmGetManifest.mock.t.Fatalf("Default expectation is already set for the Client.GetManifest method")
	}

	if len(mmGetManifest.expectations) > 0 {
		mmGetManifest.mock.t.Fatalf("Some expectations are already set for the Client.GetManifest method")
	}

	mmGetManifest.mock.funcGetManifest = f
	mmGetManifest.mock.funcGetManifestOrigin = minimock.CallerInfo(1)
	return mmGetManifest.mock
}

// When sets expectation for the Client.GetManifest which will trigger the result defined by the following
// Then helper
func (mmGetManifest *mRegistryClientMockGetManifest) When(ctx context.Context, tag string) *RegistryClientMockGetManifestExpectation {
	if mmGetManifest.mock.funcGetManifest != nil {
		mmGetManifest.mock.t.Fatalf("RegistryClientMock.GetManifest mock is already set by Set")
	}

	expectation := &RegistryClientMockGetManifestExpectation{
		mock:               mmGetManifest.mock,
		params:             &RegistryClientMockGetManifestParams{ctx, tag},
		expectationOrigins: RegistryClientMockGetManifestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetManifest.expectations = append(mmGetManifest.expectations, expectation)
	return expectation
}

// Then sets up Client.GetManifest return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockGetManifestExpectation) Then(m1 mm_registry.ManifestResult, err error) *RegistryClientMock {
	e.results = &RegistryClientMockGetManifestResults{m1, err}
	return e.mock
}

// Times sets number of times Client.GetManifest should be invoked
func (mmGetManifest *mRegistryClientMockGetManifest) Times(n uint64) *mRegistryClientMockGetManifest {
	if n == 0 {
		mmGetManifest.mock.t.Fatalf("Times of RegistryClientMock.GetManifest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetManifest.expectedInvocations, n)
	mmGetManifest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetManifest
}

func (mmGetManifest *mRegistryClientMockGetManifest) invocationsDone() bool {
	if len(mmGetManifest.expectations) == 0 && mmGetManifest.defaultExpectation == nil && mmGetManifest.mock.funcGetManifest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetManifest.mock.afterGetManifestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetManifest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetManifest implements mm_registry.Client
func (mmGetManifest *RegistryClientMock) GetManifest(ctx context.Context, tag string) (m1 mm_registry.ManifestResult, err error) {
	mm_atomic.AddUint64(&mmGetManifest.beforeGetManifestCounter, 1)
	defer mm_atomic.AddUint64(&mmGetManifest.afterGetManifestCounter, 1)

	mmGetManifest.t.Helper()

	if mmGetManifest.inspectFuncGetManifest != nil {
		mmGetManifest.inspectFuncGetManifest(ctx, tag)
	}

	mm_params := RegistryClientMockGetManifestParams{ctx, tag}

	// Record call args
	mmGetManifest.GetManifestMock.mutex.Lock()
	mmGetManifest.GetManifestMock.callArgs = append(mmGetManifest.GetManifestMock.callArgs, &mm_params)
	mmGetManifest.GetManifestMock.mutex.Unlock()

	for _, e := range mmGetManifest.GetManifestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetManifest.GetManifestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetManifest.GetManifestMock.defaultExpectation.Counter, 1)
		mm_want := mmGetManifest.GetManifestMock.defaultExpectation.params
		mm_want_ptrs := mmGetManifest.GetManifestMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockGetManifestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetManifest.t.Errorf("RegistryClientMock.GetManifest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetManifest.GetManifestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetManifest.GetManifestMock.defaultExpectation.results
		if mm_results == nil {
			mmGetManifest.t.Fatal("No results are set for the RegistryClientMock.GetManifest")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetManifest.funcGetManifest != nil {
		return mmGetManifest.funcGetManifest(ctx, tag)
	}
	mmGetManifest.t.Fatalf("Unexpected call to RegistryClientMock.GetManifest. %v %v", ctx, tag)
	return
}

// GetManifestAfterCounter returns a count of finished RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.afterGetManifestCounter)
}

// GetManifestBeforeCounter returns a count of RegistryClientMock.GetManifest invocations
func (mmGetManifest *RegistryClientMock) GetManifestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetManifest.beforeGetManifestCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.GetManifest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetManifest *mRegistryClientMockGetManifest) Calls() []*RegistryClientMockGetManifestParams {
	mmGetManifest.mutex.RLock()

	argCopy := make([]*RegistryClientMockGetManifestParams, len(mmGetManifest.callArgs))
	copy(argCopy, mmGetManifest.callArgs)

	mmGetManifest.mutex.RUnlock()

	return argCopy
}

// MinimockGetManifestDone returns true if the count of the GetManifest invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetManifestDone() bool {
	if m.GetManifestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetManifestMock.invocationsDone()
}

// MinimockGetManifestInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetManifestInspect() {
	for _, e := range m.GetManifestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetManifestCounter := mm_atomic.LoadUint64(&m.afterGetManifestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetManifestMock.defaultExpectation != nil && afterGetManifestCounter < 1 {
		if m.GetManifestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.GetManifestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s with params: %#v", m.GetManifestMock.defaultExpectation.expectationOrigins.origin, *m.GetManifestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetManifest != nil && afterGetManifestCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetManifest at\n%s", m.funcGetManifestOrigin)
	}

	if !m.GetManifestMock.invocationsDone() && afterGetManifestCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetManifest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetManifestMock.expectedInvocations), m.GetManifestMock.expectedInvocationsOrigin, afterGetManifestCounter)
	}
}

type mRegistryClientMockGetRegistry struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockGetRegistryExpectation
	expectations       []*RegistryClientMockGetRegistryExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockGetRegistryExpectation specifies expectation struct of the Client.GetRegistry
type RegistryClientMockGetRegistryExpectation struct {
	mock *RegistryClientMock

	results      *RegistryClientMockGetRegistryResults
	returnOrigin string
	Counter      uint64
}

// RegistryClientMockGetRegistryResults contains results of the Client.GetRegistry
type RegistryClientMockGetRegistryResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRegistry *mRegistryClientMockGetRegistry) Optional() *mRegistryClientMockGetRegistry {
	mmGetRegistry.optional = true
	return mmGetRegistry
}

// Expect sets up expected params for Client.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Expect() *mRegistryClientMockGetRegistry {
	if mmGetRegistry.mock.funcGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("RegistryClientMock.GetRegistry mock is already set by Set")
	}

	if mmGetRegistry.defaultExpectation == nil {
		mmGetRegistry.defaultExpectation = &RegistryClientMockGetRegistryExpectation{}
	}

	return mmGetRegistry
}

// Inspect accepts an inspector function that has same arguments as the Client.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Inspect(f func()) *mRegistryClientMockGetRegistry {
	if mmGetRegistry.mock.inspectFuncGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.GetRegistry")
	}

	mmGetRegistry.mock.inspectFuncGetRegistry = f

	return mmGetRegistry
}

// Return sets up results that will be returned by Client.GetRegistry
func (mmGetRegistry *mRegistryClientMockGetRegistry) Return(s1 string) *RegistryClientMock {
	if mmGetRegistry.mock.funcGetRegistry != nil {
		mmGetRegistry.mock.t.Fatalf("RegistryClientMock.GetRegistry mock is already set by Set")
	}

	if mmGetRegistry.defaultExpectation == nil {
		mmGetRegistry.defaultExpectation = &RegistryClientMockGetRegistryExpectation{mock: mmGetRegistry.mock}
	}
	mmGetRegistry.defaultExpectation.results = &RegistryClientMockGetRegistryResults{s1}
	mmGetRegistry.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRegistry.mock
}

// Set uses given function f to mock the Client.GetRegistry method
func (mmGetRegistry *mRegistryClientMockGetRegistry) Set(f func() (s1 string)) *RegistryClientMock {
	if mmGetRegistry.defaultExpectation != nil {
		mmGetRegistry.mock.t.Fatalf("Default expectation is already set for the Client.GetRegistry method")
	}

	if len(mmGetRegistry.expectations) > 0 {
		mmGetRegistry.mock.t.Fatalf("Some expectations are already set for the Client.GetRegistry method")
	}

	mmGetRegistry.mock.funcGetRegistry = f
	mmGetRegistry.mock.funcGetRegistryOrigin = minimock.CallerInfo(1)
	return mmGetRegistry.mock
}

// Times sets number of times Client.GetRegistry should be invoked
func (mmGetRegistry *mRegistryClientMockGetRegistry) Times(n uint64) *mRegistryClientMockGetRegistry {
	if n == 0 {
		mmGetRegistry.mock.t.Fatalf("Times of RegistryClientMock.GetRegistry mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRegistry.expectedInvocations, n)
	mmGetRegistry.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRegistry
}

func (mmGetRegistry *mRegistryClientMockGetRegistry) invocationsDone() bool {
	if len(mmGetRegistry.expectations) == 0 && mmGetRegistry.defaultExpectation == nil && mmGetRegistry.mock.funcGetRegistry == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRegistry.mock.afterGetRegistryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRegistry.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRegistry implements mm_registry.Client
func (mmGetRegistry *RegistryClientMock) GetRegistry() (s1 string) {
	mm_atomic.AddUint64(&mmGetRegistry.beforeGetRegistryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRegistry.afterGetRegistryCounter, 1)

	mmGetRegistry.t.Helper()

	if mmGetRegistry.inspectFuncGetRegistry != nil {
		mmGetRegistry.inspectFuncGetRegistry()
	}

	if mmGetRegistry.GetRegistryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRegistry.GetRegistryMock.defaultExpectation.Counter, 1)

		mm_results := mmGetRegistry.GetRegistryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRegistry.t.Fatal("No results are set for the RegistryClientMock.GetRegistry")
		}
		return (*mm_results).s1
	}
	if mmGetRegistry.funcGetRegistry != nil {
		return mmGetRegistry.funcGetRegistry()
	}
	mmGetRegistry.t.Fatalf("Unexpected call to RegistryClientMock.GetRegistry.")
	return
}

// GetRegistryAfterCounter returns a count of finished RegistryClientMock.GetRegistry invocations
func (mmGetRegistry *RegistryClientMock) GetRegistryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistry.afterGetRegistryCounter)
}

// GetRegistryBeforeCounter returns a count of RegistryClientMock.GetRegistry invocations
func (mmGetRegistry *RegistryClientMock) GetRegistryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRegistry.beforeGetRegistryCounter)
}

// MinimockGetRegistryDone returns true if the count of the GetRegistry invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockGetRegistryDone() bool {
	if m.GetRegistryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRegistryMock.invocationsDone()
}

// MinimockGetRegistryInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockGetRegistryInspect() {
	for _, e := range m.GetRegistryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RegistryClientMock.GetRegistry")
		}
	}

	afterGetRegistryCounter := mm_atomic.LoadUint64(&m.afterGetRegistryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRegistryMock.defaultExpectation != nil && afterGetRegistryCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetRegistry at\n%s", m.GetRegistryMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRegistry != nil && afterGetRegistryCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.GetRegistry at\n%s", m.funcGetRegistryOrigin)
	}

	if !m.GetRegistryMock.invocationsDone() && afterGetRegistryCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.GetRegistry at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRegistryMock.expectedInvocations), m.GetRegistryMock.expectedInvocationsOrigin, afterGetRegistryCounter)
	}
}

type mRegistryClientMockListRepositories struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListRepositoriesExpectation
	expectations       []*RegistryClientMockListRepositoriesExpectation

	callArgs []*RegistryClientMockListRepositoriesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListRepositoriesExpectation specifies expectation struct of the Client.ListRepositories
type RegistryClientMockListRepositoriesExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListRepositoriesParams
	paramPtrs          *RegistryClientMockListRepositoriesParamPtrs
	expectationOrigins RegistryClientMockListRepositoriesExpectationOrigins
	results            *RegistryClientMockListRepositoriesResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListRepositoriesParams contains parameters of the Client.ListRepositories
type RegistryClientMockListRepositoriesParams struct {
	ctx  context.Context
	opts []mm_registry.ListRepositoriesOption
}

// RegistryClientMockListRepositoriesParamPtrs contains pointers to parameters of the Client.ListRepositories
type RegistryClientMockListRepositoriesParamPtrs struct {
	ctx  *context.Context
	opts *[]mm_registry.ListRepositoriesOption
}

// RegistryClientMockListRepositoriesResults contains results of the Client.ListRepositories
type RegistryClientMockListRepositoriesResults struct {
	sa1 []string
	err error
}

// RegistryClientMockListRepositoriesOrigins contains origins of expectations of the Client.ListRepositories
type RegistryClientMockListRepositoriesExpectationOrigins struct {
	origin     string
	originCtx  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListRepositories *mRegistryClientMockListRepositories) Optional() *mRegistryClientMockListRepositories {
	mmListRepositories.optional = true
	return mmListRepositories
}

// Expect sets up expected params for Client.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Expect(ctx context.Context, opts ...mm_registry.ListRepositoriesOption) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{}
	}

	if mmListRepositories.defaultExpectation.paramPtrs != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by ExpectParams functions")
	}

	mmListRepositories.defaultExpectation.params = &RegistryClientMockListRepositoriesParams{ctx, opts}
	mmListRepositories.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListRepositories.expectations {
		if minimock.Equal(e.params, mmListRepositories.defaultExpectation.params) {
			mmListRepositories.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListRepositories.defaultExpectation.params)
		}
	}

	return mmListRepositories
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{}
	}

	if mmListRepositories.defaultExpectation.params != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Expect")
	}

	if mmListRepositories.defaultExpectation.paramPtrs == nil {
		mmListRepositories.defaultExpectation.paramPtrs = &RegistryClientMockListRepositoriesParamPtrs{}
	}
	mmListRepositories.defaultExpectation.paramPtrs.ctx = &ctx
	mmListRepositories.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListRepositories
}

// ExpectOptsParam2 sets up expected param opts for Client.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) ExpectOptsParam2(opts ...mm_registry.ListRepositoriesOption) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{}
	}

	if mmListRepositories.defaultExpectation.params != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Expect")
	}

	if mmListRepositories.defaultExpectation.paramPtrs == nil {
		mmListRepositories.defaultExpectation.paramPtrs = &RegistryClientMockListRepositoriesParamPtrs{}
	}
	mmListRepositories.defaultExpectation.paramPtrs.opts = &opts
	mmListRepositories.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListRepositories
}

// Inspect accepts an inspector function that has same arguments as the Client.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Inspect(f func(ctx context.Context, opts ...mm_registry.ListRepositoriesOption)) *mRegistryClientMockListRepositories {
	if mmListRepositories.mock.inspectFuncListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListRepositories")
	}

	mmListRepositories.mock.inspectFuncListRepositories = f

	return mmListRepositories
}

// Return sets up results that will be returned by Client.ListRepositories
func (mmListRepositories *mRegistryClientMockListRepositories) Return(sa1 []string, err error) *RegistryClientMock {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	if mmListRepositories.defaultExpectation == nil {
		mmListRepositories.defaultExpectation = &RegistryClientMockListRepositoriesExpectation{mock: mmListRepositories.mock}
	}
	mmListRepositories.defaultExpectation.results = &RegistryClientMockListRepositoriesResults{sa1, err}
	mmListRepositories.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListRepositories.mock
}

// Set uses given function f to mock the Client.ListRepositories method
func (mmListRepositories *mRegistryClientMockListRepositories) Set(f func(ctx context.Context, opts ...mm_registry.ListRepositoriesOption) (sa1 []string, err error)) *RegistryClientMock {
	if mmListRepositories.defaultExpectation != nil {
		mmListRepositories.mock.t.Fatalf("Default expectation is already set for the Client.ListRepositories method")
	}

	if len(mmListRepositories.expectations) > 0 {
		mmListRepositories.mock.t.Fatalf("Some expectations are already set for the Client.ListRepositories method")
	}

	mmListRepositories.mock.funcListRepositories = f
	mmListRepositories.mock.funcListRepositoriesOrigin = minimock.CallerInfo(1)
	return mmListRepositories.mock
}

// When sets expectation for the Client.ListRepositories which will trigger the result defined by the following
// Then helper
func (mmListRepositories *mRegistryClientMockListRepositories) When(ctx context.Context, opts ...mm_registry.ListRepositoriesOption) *RegistryClientMockListRepositoriesExpectation {
	if mmListRepositories.mock.funcListRepositories != nil {
		mmListRepositories.mock.t.Fatalf("RegistryClientMock.ListRepositories mock is already set by Set")
	}

	expectation := &RegistryClientMockListRepositoriesExpectation{
		mock:               mmListRepositories.mock,
		params:             &RegistryClientMockListRepositoriesParams{ctx, opts},
		expectationOrigins: RegistryClientMockListRepositoriesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListRepositories.expectations = append(mmListRepositories.expectations, expectation)
	return expectation
}

// Then sets up Client.ListRepositories return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListRepositoriesExpectation) Then(sa1 []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListRepositoriesResults{sa1, err}
	return e.mock
}

// Times sets number of times Client.ListRepositories should be invoked
func (mmListRepositories *mRegistryClientMockListRepositories) Times(n uint64) *mRegistryClientMockListRepositories {
	if n == 0 {
		mmListRepositories.mock.t.Fatalf("Times of RegistryClientMock.ListRepositories mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListRepositories.expectedInvocations, n)
	mmListRepositories.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListRepositories
}

func (mmListRepositories *mRegistryClientMockListRepositories) invocationsDone() bool {
	if len(mmListRepositories.expectations) == 0 && mmListRepositories.defaultExpectation == nil && mmListRepositories.mock.funcListRepositories == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListRepositories.mock.afterListRepositoriesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListRepositories.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListRepositories implements mm_registry.Client
func (mmListRepositories *RegistryClientMock) ListRepositories(ctx context.Context, opts ...mm_registry.ListRepositoriesOption) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListRepositories.beforeListRepositoriesCounter, 1)
	defer mm_atomic.AddUint64(&mmListRepositories.afterListRepositoriesCounter, 1)

	mmListRepositories.t.Helper()

	if mmListRepositories.inspectFuncListRepositories != nil {
		mmListRepositories.inspectFuncListRepositories(ctx, opts...)
	}

	mm_params := RegistryClientMockListRepositoriesParams{ctx, opts}

	// Record call args
	mmListRepositories.ListRepositoriesMock.mutex.Lock()
	mmListRepositories.ListRepositoriesMock.callArgs = append(mmListRepositories.ListRepositoriesMock.callArgs, &mm_params)
	mmListRepositories.ListRepositoriesMock.mutex.Unlock()

	for _, e := range mmListRepositories.ListRepositoriesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListRepositories.ListRepositoriesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListRepositories.ListRepositoriesMock.defaultExpectation.Counter, 1)
		mm_want := mmListRepositories.ListRepositoriesMock.defaultExpectation.params
		mm_want_ptrs := mmListRepositories.ListRepositoriesMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListRepositoriesParams{ctx, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListRepositories.t.Errorf("RegistryClientMock.ListRepositories got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositories.ListRepositoriesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListRepositories.t.Errorf("RegistryClientMock.ListRepositories got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListRepositories.ListRepositoriesMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListRepositories.t.Errorf("RegistryClientMock.ListRepositories got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListRepositories.ListRepositoriesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListRepositories.ListRepositoriesMock.defaultExpectation.results
		if mm_results == nil {
			mmListRepositories.t.Fatal("No results are set for the RegistryClientMock.ListRepositories")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListRepositories.funcListRepositories != nil {
		return mmListRepositories.funcListRepositories(ctx, opts...)
	}
	mmListRepositories.t.Fatalf("Unexpected call to RegistryClientMock.ListRepositories. %v %v", ctx, opts)
	return
}

// ListRepositoriesAfterCounter returns a count of finished RegistryClientMock.ListRepositories invocations
func (mmListRepositories *RegistryClientMock) ListRepositoriesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositories.afterListRepositoriesCounter)
}

// ListRepositoriesBeforeCounter returns a count of RegistryClientMock.ListRepositories invocations
func (mmListRepositories *RegistryClientMock) ListRepositoriesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListRepositories.beforeListRepositoriesCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListRepositories.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListRepositories *mRegistryClientMockListRepositories) Calls() []*RegistryClientMockListRepositoriesParams {
	mmListRepositories.mutex.RLock()

	argCopy := make([]*RegistryClientMockListRepositoriesParams, len(mmListRepositories.callArgs))
	copy(argCopy, mmListRepositories.callArgs)

	mmListRepositories.mutex.RUnlock()

	return argCopy
}

// MinimockListRepositoriesDone returns true if the count of the ListRepositories invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListRepositoriesDone() bool {
	if m.ListRepositoriesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListRepositoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListRepositoriesMock.invocationsDone()
}

// MinimockListRepositoriesInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListRepositoriesInspect() {
	for _, e := range m.ListRepositoriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListRepositoriesCounter := mm_atomic.LoadUint64(&m.afterListRepositoriesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListRepositoriesMock.defaultExpectation != nil && afterListRepositoriesCounter < 1 {
		if m.ListRepositoriesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s", m.ListRepositoriesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s with params: %#v", m.ListRepositoriesMock.defaultExpectation.expectationOrigins.origin, *m.ListRepositoriesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListRepositories != nil && afterListRepositoriesCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListRepositories at\n%s", m.funcListRepositoriesOrigin)
	}

	if !m.ListRepositoriesMock.invocationsDone() && afterListRepositoriesCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListRepositories at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListRepositoriesMock.expectedInvocations), m.ListRepositoriesMock.expectedInvocationsOrigin, afterListRepositoriesCounter)
	}
}

type mRegistryClientMockListTags struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockListTagsExpectation
	expectations       []*RegistryClientMockListTagsExpectation

	callArgs []*RegistryClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockListTagsExpectation specifies expectation struct of the Client.ListTags
type RegistryClientMockListTagsExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockListTagsParams
	paramPtrs          *RegistryClientMockListTagsParamPtrs
	expectationOrigins RegistryClientMockListTagsExpectationOrigins
	results            *RegistryClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockListTagsParams contains parameters of the Client.ListTags
type RegistryClientMockListTagsParams struct {
	ctx  context.Context
	opts []mm_registry.ListTagsOption
}

// RegistryClientMockListTagsParamPtrs contains pointers to parameters of the Client.ListTags
type RegistryClientMockListTagsParamPtrs struct {
	ctx  *context.Context
	opts *[]mm_registry.ListTagsOption
}

// RegistryClientMockListTagsResults contains results of the Client.ListTags
type RegistryClientMockListTagsResults struct {
	sa1 []string
	err error
}

// RegistryClientMockListTagsOrigins contains origins of expectations of the Client.ListTags
type RegistryClientMockListTagsExpectationOrigins struct {
	origin     string
	originCtx  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mRegistryClientMockListTags) Optional() *mRegistryClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for Client.ListTags
func (mmListTags *mRegistryClientMockListTags) Expect(ctx context.Context, opts ...mm_registry.ListTagsOption) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &RegistryClientMockListTagsParams{ctx, opts}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// ExpectOptsParam2 sets up expected param opts for Client.ListTags
func (mmListTags *mRegistryClientMockListTags) ExpectOptsParam2(opts ...mm_registry.ListTagsOption) *mRegistryClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &RegistryClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.opts = &opts
	mmListTags.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the Client.ListTags
func (mmListTags *mRegistryClientMockListTags) Inspect(f func(ctx context.Context, opts ...mm_registry.ListTagsOption)) *mRegistryClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by Client.ListTags
func (mmListTags *mRegistryClientMockListTags) Return(sa1 []string, err error) *RegistryClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &RegistryClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &RegistryClientMockListTagsResults{sa1, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the Client.ListTags method
func (mmListTags *mRegistryClientMockListTags) Set(f func(ctx context.Context, opts ...mm_registry.ListTagsOption) (sa1 []string, err error)) *RegistryClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the Client.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the Client.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the Client.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mRegistryClientMockListTags) When(ctx context.Context, opts ...mm_registry.ListTagsOption) *RegistryClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("RegistryClientMock.ListTags mock is already set by Set")
	}

	expectation := &RegistryClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &RegistryClientMockListTagsParams{ctx, opts},
		expectationOrigins: RegistryClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up Client.ListTags return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockListTagsExpectation) Then(sa1 []string, err error) *RegistryClientMock {
	e.results = &RegistryClientMockListTagsResults{sa1, err}
	return e.mock
}

// Times sets number of times Client.ListTags should be invoked
func (mmListTags *mRegistryClientMockListTags) Times(n uint64) *mRegistryClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of RegistryClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mRegistryClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements mm_registry.Client
func (mmListTags *RegistryClientMock) ListTags(ctx context.Context, opts ...mm_registry.ListTagsOption) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx, opts...)
	}

	mm_params := RegistryClientMockListTagsParams{ctx, opts}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockListTagsParams{ctx, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("RegistryClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the RegistryClientMock.ListTags")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx, opts...)
	}
	mmListTags.t.Fatalf("Unexpected call to RegistryClientMock.ListTags. %v %v", ctx, opts)
	return
}

// ListTagsAfterCounter returns a count of finished RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of RegistryClientMock.ListTags invocations
func (mmListTags *RegistryClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mRegistryClientMockListTags) Calls() []*RegistryClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*RegistryClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

type mRegistryClientMockPushImage struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockPushImageExpectation
	expectations       []*RegistryClientMockPushImageExpectation

	callArgs []*RegistryClientMockPushImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockPushImageExpectation specifies expectation struct of the Client.PushImage
type RegistryClientMockPushImageExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockPushImageParams
	paramPtrs          *RegistryClientMockPushImageParamPtrs
	expectationOrigins RegistryClientMockPushImageExpectationOrigins
	results            *RegistryClientMockPushImageResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockPushImageParams contains parameters of the Client.PushImage
type RegistryClientMockPushImageParams struct {
	ctx  context.Context
	tag  string
	img  v1.Image
	opts []mm_registry.ImagePushOption
}

// RegistryClientMockPushImageParamPtrs contains pointers to parameters of the Client.PushImage
type RegistryClientMockPushImageParamPtrs struct {
	ctx  *context.Context
	tag  *string
	img  *v1.Image
	opts *[]mm_registry.ImagePushOption
}

// RegistryClientMockPushImageResults contains results of the Client.PushImage
type RegistryClientMockPushImageResults struct {
	err error
}

// RegistryClientMockPushImageOrigins contains origins of expectations of the Client.PushImage
type RegistryClientMockPushImageExpectationOrigins struct {
	origin     string
	originCtx  string
	originTag  string
	originImg  string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPushImage *mRegistryClientMockPushImage) Optional() *mRegistryClientMockPushImage {
	mmPushImage.optional = true
	return mmPushImage
}

// Expect sets up expected params for Client.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Expect(ctx context.Context, tag string, img v1.Image, opts ...mm_registry.ImagePushOption) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.paramPtrs != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by ExpectParams functions")
	}

	mmPushImage.defaultExpectation.params = &RegistryClientMockPushImageParams{ctx, tag, img, opts}
	mmPushImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPushImage.expectations {
		if minimock.Equal(e.params, mmPushImage.defaultExpectation.params) {
			mmPushImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPushImage.defaultExpectation.params)
		}
	}

	return mmPushImage
}

// ExpectCtxParam1 sets up expected param ctx for Client.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectCtxParam1(ctx context.Context) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmPushImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPushImage
}

// ExpectTagParam2 sets up expected param tag for Client.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectTagParam2(tag string) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.tag = &tag
	mmPushImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmPushImage
}

// ExpectImgParam3 sets up expected param img for Client.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectImgParam3(img v1.Image) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.img = &img
	mmPushImage.defaultExpectation.expectationOrigins.originImg = minimock.CallerInfo(1)

	return mmPushImage
}

// ExpectOptsParam4 sets up expected param opts for Client.PushImage
func (mmPushImage *mRegistryClientMockPushImage) ExpectOptsParam4(opts ...mm_registry.ImagePushOption) *mRegistryClientMockPushImage {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{}
	}

	if mmPushImage.defaultExpectation.params != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Expect")
	}

	if mmPushImage.defaultExpectation.paramPtrs == nil {
		mmPushImage.defaultExpectation.paramPtrs = &RegistryClientMockPushImageParamPtrs{}
	}
	mmPushImage.defaultExpectation.paramPtrs.opts = &opts
	mmPushImage.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmPushImage
}

// Inspect accepts an inspector function that has same arguments as the Client.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Inspect(f func(ctx context.Context, tag string, img v1.Image, opts ...mm_registry.ImagePushOption)) *mRegistryClientMockPushImage {
	if mmPushImage.mock.inspectFuncPushImage != nil {
		mmPushImage.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.PushImage")
	}

	mmPushImage.mock.inspectFuncPushImage = f

	return mmPushImage
}

// Return sets up results that will be returned by Client.PushImage
func (mmPushImage *mRegistryClientMockPushImage) Return(err error) *RegistryClientMock {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	if mmPushImage.defaultExpectation == nil {
		mmPushImage.defaultExpectation = &RegistryClientMockPushImageExpectation{mock: mmPushImage.mock}
	}
	mmPushImage.defaultExpectation.results = &RegistryClientMockPushImageResults{err}
	mmPushImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPushImage.mock
}

// Set uses given function f to mock the Client.PushImage method
func (mmPushImage *mRegistryClientMockPushImage) Set(f func(ctx context.Context, tag string, img v1.Image, opts ...mm_registry.ImagePushOption) (err error)) *RegistryClientMock {
	if mmPushImage.defaultExpectation != nil {
		mmPushImage.mock.t.Fatalf("Default expectation is already set for the Client.PushImage method")
	}

	if len(mmPushImage.expectations) > 0 {
		mmPushImage.mock.t.Fatalf("Some expectations are already set for the Client.PushImage method")
	}

	mmPushImage.mock.funcPushImage = f
	mmPushImage.mock.funcPushImageOrigin = minimock.CallerInfo(1)
	return mmPushImage.mock
}

// When sets expectation for the Client.PushImage which will trigger the result defined by the following
// Then helper
func (mmPushImage *mRegistryClientMockPushImage) When(ctx context.Context, tag string, img v1.Image, opts ...mm_registry.ImagePushOption) *RegistryClientMockPushImageExpectation {
	if mmPushImage.mock.funcPushImage != nil {
		mmPushImage.mock.t.Fatalf("RegistryClientMock.PushImage mock is already set by Set")
	}

	expectation := &RegistryClientMockPushImageExpectation{
		mock:               mmPushImage.mock,
		params:             &RegistryClientMockPushImageParams{ctx, tag, img, opts},
		expectationOrigins: RegistryClientMockPushImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPushImage.expectations = append(mmPushImage.expectations, expectation)
	return expectation
}

// Then sets up Client.PushImage return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockPushImageExpectation) Then(err error) *RegistryClientMock {
	e.results = &RegistryClientMockPushImageResults{err}
	return e.mock
}

// Times sets number of times Client.PushImage should be invoked
func (mmPushImage *mRegistryClientMockPushImage) Times(n uint64) *mRegistryClientMockPushImage {
	if n == 0 {
		mmPushImage.mock.t.Fatalf("Times of RegistryClientMock.PushImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPushImage.expectedInvocations, n)
	mmPushImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPushImage
}

func (mmPushImage *mRegistryClientMockPushImage) invocationsDone() bool {
	if len(mmPushImage.expectations) == 0 && mmPushImage.defaultExpectation == nil && mmPushImage.mock.funcPushImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPushImage.mock.afterPushImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPushImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PushImage implements mm_registry.Client
func (mmPushImage *RegistryClientMock) PushImage(ctx context.Context, tag string, img v1.Image, opts ...mm_registry.ImagePushOption) (err error) {
	mm_atomic.AddUint64(&mmPushImage.beforePushImageCounter, 1)
	defer mm_atomic.AddUint64(&mmPushImage.afterPushImageCounter, 1)

	mmPushImage.t.Helper()

	if mmPushImage.inspectFuncPushImage != nil {
		mmPushImage.inspectFuncPushImage(ctx, tag, img, opts...)
	}

	mm_params := RegistryClientMockPushImageParams{ctx, tag, img, opts}

	// Record call args
	mmPushImage.PushImageMock.mutex.Lock()
	mmPushImage.PushImageMock.callArgs = append(mmPushImage.PushImageMock.callArgs, &mm_params)
	mmPushImage.PushImageMock.mutex.Unlock()

	for _, e := range mmPushImage.PushImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPushImage.PushImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPushImage.PushImageMock.defaultExpectation.Counter, 1)
		mm_want := mmPushImage.PushImageMock.defaultExpectation.params
		mm_want_ptrs := mmPushImage.PushImageMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockPushImageParams{ctx, tag, img, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

			if mm_want_ptrs.img != nil && !minimock.Equal(*mm_want_ptrs.img, mm_got.img) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter img, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originImg, *mm_want_ptrs.img, mm_got.img, minimock.Diff(*mm_want_ptrs.img, mm_got.img))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPushImage.t.Errorf("RegistryClientMock.PushImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPushImage.PushImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPushImage.PushImageMock.defaultExpectation.results
		if mm_results == nil {
			mmPushImage.t.Fatal("No results are set for the RegistryClientMock.PushImage")
		}
		return (*mm_results).err
	}
	if mmPushImage.funcPushImage != nil {
		return mmPushImage.funcPushImage(ctx, tag, img, opts...)
	}
	mmPushImage.t.Fatalf("Unexpected call to RegistryClientMock.PushImage. %v %v %v %v", ctx, tag, img, opts)
	return
}

// PushImageAfterCounter returns a count of finished RegistryClientMock.PushImage invocations
func (mmPushImage *RegistryClientMock) PushImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushImage.afterPushImageCounter)
}

// PushImageBeforeCounter returns a count of RegistryClientMock.PushImage invocations
func (mmPushImage *RegistryClientMock) PushImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushImage.beforePushImageCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.PushImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPushImage *mRegistryClientMockPushImage) Calls() []*RegistryClientMockPushImageParams {
	mmPushImage.mutex.RLock()

	argCopy := make([]*RegistryClientMockPushImageParams, len(mmPushImage.callArgs))
	copy(argCopy, mmPushImage.callArgs)

	mmPushImage.mutex.RUnlock()

	return argCopy
}

// MinimockPushImageDone returns true if the count of the PushImage invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockPushImageDone() bool {
	if m.PushImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PushImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PushImageMock.invocationsDone()
}

// MinimockPushImageInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockPushImageInspect() {
	for _, e := range m.PushImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPushImageCounter := mm_atomic.LoadUint64(&m.afterPushImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PushImageMock.defaultExpectation != nil && afterPushImageCounter < 1 {
		if m.PushImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s", m.PushImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s with params: %#v", m.PushImageMock.defaultExpectation.expectationOrigins.origin, *m.PushImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPushImage != nil && afterPushImageCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.PushImage at\n%s", m.funcPushImageOrigin)
	}

	if !m.PushImageMock.invocationsDone() && afterPushImageCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.PushImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PushImageMock.expectedInvocations), m.PushImageMock.expectedInvocationsOrigin, afterPushImageCounter)
	}
}

type mRegistryClientMockWithSegment struct {
	optional           bool
	mock               *RegistryClientMock
	defaultExpectation *RegistryClientMockWithSegmentExpectation
	expectations       []*RegistryClientMockWithSegmentExpectation

	callArgs []*RegistryClientMockWithSegmentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RegistryClientMockWithSegmentExpectation specifies expectation struct of the Client.WithSegment
type RegistryClientMockWithSegmentExpectation struct {
	mock               *RegistryClientMock
	params             *RegistryClientMockWithSegmentParams
	paramPtrs          *RegistryClientMockWithSegmentParamPtrs
	expectationOrigins RegistryClientMockWithSegmentExpectationOrigins
	results            *RegistryClientMockWithSegmentResults
	returnOrigin       string
	Counter            uint64
}

// RegistryClientMockWithSegmentParams contains parameters of the Client.WithSegment
type RegistryClientMockWithSegmentParams struct {
	segments []string
}

// RegistryClientMockWithSegmentParamPtrs contains pointers to parameters of the Client.WithSegment
type RegistryClientMockWithSegmentParamPtrs struct {
	segments *[]string
}

// RegistryClientMockWithSegmentResults contains results of the Client.WithSegment
type RegistryClientMockWithSegmentResults struct {
	c1 mm_registry.Client
}

// RegistryClientMockWithSegmentOrigins contains origins of expectations of the Client.WithSegment
type RegistryClientMockWithSegmentExpectationOrigins struct {
	origin         string
	originSegments string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWithSegment *mRegistryClientMockWithSegment) Optional() *mRegistryClientMockWithSegment {
	mmWithSegment.optional = true
	return mmWithSegment
}

// Expect sets up expected params for Client.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) Expect(segments ...string) *mRegistryClientMockWithSegment {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	if mmWithSegment.defaultExpectation == nil {
		mmWithSegment.defaultExpectation = &RegistryClientMockWithSegmentExpectation{}
	}

	if mmWithSegment.defaultExpectation.paramPtrs != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by ExpectParams functions")
	}

	mmWithSegment.defaultExpectation.params = &RegistryClientMockWithSegmentParams{segments}
	mmWithSegment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWithSegment.expectations {
		if minimock.Equal(e.params, mmWithSegment.defaultExpectation.params) {
			mmWithSegment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithSegment.defaultExpectation.params)
		}
	}

	return mmWithSegment
}

// ExpectSegmentsParam1 sets up expected param segments for Client.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) ExpectSegmentsParam1(segments ...string) *mRegistryClientMockWithSegment {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	if mmWithSegment.defaultExpectation == nil {
		mmWithSegment.defaultExpectation = &RegistryClientMockWithSegmentExpectation{}
	}

	if mmWithSegment.defaultExpectation.params != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Expect")
	}

	if mmWithSegment.defaultExpectation.paramPtrs == nil {
		mmWithSegment.defaultExpectation.paramPtrs = &RegistryClientMockWithSegmentParamPtrs{}
	}
	mmWithSegment.defaultExpectation.paramPtrs.segments = &segments
	mmWithSegment.defaultExpectation.expectationOrigins.originSegments = minimock.CallerInfo(1)

	return mmWithSegment
}

// Inspect accepts an inspector function that has same arguments as the Client.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) Inspect(f func(segments ...string)) *mRegistryClientMockWithSegment {
	if mmWithSegment.mock.inspectFuncWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("Inspect function is already set for RegistryClientMock.WithSegment")
	}

	mmWithSegment.mock.inspectFuncWithSegment = f

	return mmWithSegment
}

// Return sets up results that will be returned by Client.WithSegment
func (mmWithSegment *mRegistryClientMockWithSegment) Return(c1 mm_registry.Client) *RegistryClientMock {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	if mmWithSegment.defaultExpectation == nil {
		mmWithSegment.defaultExpectation = &RegistryClientMockWithSegmentExpectation{mock: mmWithSegment.mock}
	}
	mmWithSegment.defaultExpectation.results = &RegistryClientMockWithSegmentResults{c1}
	mmWithSegment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWithSegment.mock
}

// Set uses given function f to mock the Client.WithSegment method
func (mmWithSegment *mRegistryClientMockWithSegment) Set(f func(segments ...string) (c1 mm_registry.Client)) *RegistryClientMock {
	if mmWithSegment.defaultExpectation != nil {
		mmWithSegment.mock.t.Fatalf("Default expectation is already set for the Client.WithSegment method")
	}

	if len(mmWithSegment.expectations) > 0 {
		mmWithSegment.mock.t.Fatalf("Some expectations are already set for the Client.WithSegment method")
	}

	mmWithSegment.mock.funcWithSegment = f
	mmWithSegment.mock.funcWithSegmentOrigin = minimock.CallerInfo(1)
	return mmWithSegment.mock
}

// When sets expectation for the Client.WithSegment which will trigger the result defined by the following
// Then helper
func (mmWithSegment *mRegistryClientMockWithSegment) When(segments ...string) *RegistryClientMockWithSegmentExpectation {
	if mmWithSegment.mock.funcWithSegment != nil {
		mmWithSegment.mock.t.Fatalf("RegistryClientMock.WithSegment mock is already set by Set")
	}

	expectation := &RegistryClientMockWithSegmentExpectation{
		mock:               mmWithSegment.mock,
		params:             &RegistryClientMockWithSegmentParams{segments},
		expectationOrigins: RegistryClientMockWithSegmentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWithSegment.expectations = append(mmWithSegment.expectations, expectation)
	return expectation
}

// Then sets up Client.WithSegment return parameters for the expectation previously defined by the When method
func (e *RegistryClientMockWithSegmentExpectation) Then(c1 mm_registry.Client) *RegistryClientMock {
	e.results = &RegistryClientMockWithSegmentResults{c1}
	return e.mock
}

// Times sets number of times Client.WithSegment should be invoked
func (mmWithSegment *mRegistryClientMockWithSegment) Times(n uint64) *mRegistryClientMockWithSegment {
	if n == 0 {
		mmWithSegment.mock.t.Fatalf("Times of RegistryClientMock.WithSegment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWithSegment.expectedInvocations, n)
	mmWithSegment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWithSegment
}

func (mmWithSegment *mRegistryClientMockWithSegment) invocationsDone() bool {
	if len(mmWithSegment.expectations) == 0 && mmWithSegment.defaultExpectation == nil && mmWithSegment.mock.funcWithSegment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWithSegment.mock.afterWithSegmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWithSegment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WithSegment implements mm_registry.Client
func (mmWithSegment *RegistryClientMock) WithSegment(segments ...string) (c1 mm_registry.Client) {
	mm_atomic.AddUint64(&mmWithSegment.beforeWithSegmentCounter, 1)
	defer mm_atomic.AddUint64(&mmWithSegment.afterWithSegmentCounter, 1)

	mmWithSegment.t.Helper()

	if mmWithSegment.inspectFuncWithSegment != nil {
		mmWithSegment.inspectFuncWithSegment(segments...)
	}

	mm_params := RegistryClientMockWithSegmentParams{segments}

	// Record call args
	mmWithSegment.WithSegmentMock.mutex.Lock()
	mmWithSegment.WithSegmentMock.callArgs = append(mmWithSegment.WithSegmentMock.callArgs, &mm_params)
	mmWithSegment.WithSegmentMock.mutex.Unlock()

	for _, e := range mmWithSegment.WithSegmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1
		}
	}

	if mmWithSegment.WithSegmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithSegment.WithSegmentMock.defaultExpectation.Counter, 1)
		mm_want := mmWithSegment.WithSegmentMock.defaultExpectation.params
		mm_want_ptrs := mmWithSegment.WithSegmentMock.defaultExpectation.paramPtrs

		mm_got := RegistryClientMockWithSegmentParams{segments}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.segments != nil && !minimock.Equal(*mm_want_ptrs.segments, mm_got.segments) {
				mmWithSegment.t.Errorf("RegistryClientMock.WithSegment got unexpected parameter segments, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWithSegment.WithSegmentMock.defaultExpectation.expectationOrigins.originSegments, *mm_want_ptrs.segments, mm_got.segments, minimock.Diff(*mm_want_ptrs.segments, mm_got.segments))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithSegment.t.Errorf("RegistryClientMock.WithSegment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWithSegment.WithSegmentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithSegment.WithSegmentMock.defaultExpectation.results
		if mm_results == nil {
			mmWithSegment.t.Fatal("No results are set for the RegistryClientMock.WithSegment")
		}
		return (*mm_results).c1
	}
	if mmWithSegment.funcWithSegment != nil {
		return mmWithSegment.funcWithSegment(segments...)
	}
	mmWithSegment.t.Fatalf("Unexpected call to RegistryClientMock.WithSegment. %v", segments)
	return
}

// WithSegmentAfterCounter returns a count of finished RegistryClientMock.WithSegment invocations
func (mmWithSegment *RegistryClientMock) WithSegmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithSegment.afterWithSegmentCounter)
}

// WithSegmentBeforeCounter returns a count of RegistryClientMock.WithSegment invocations
func (mmWithSegment *RegistryClientMock) WithSegmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithSegment.beforeWithSegmentCounter)
}

// Calls returns a list of arguments used in each call to RegistryClientMock.WithSegment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithSegment *mRegistryClientMockWithSegment) Calls() []*RegistryClientMockWithSegmentParams {
	mmWithSegment.mutex.RLock()

	argCopy := make([]*RegistryClientMockWithSegmentParams, len(mmWithSegment.callArgs))
	copy(argCopy, mmWithSegment.callArgs)

	mmWithSegment.mutex.RUnlock()

	return argCopy
}

// MinimockWithSegmentDone returns true if the count of the WithSegment invocations corresponds
// the number of defined expectations
func (m *RegistryClientMock) MinimockWithSegmentDone() bool {
	if m.WithSegmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WithSegmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WithSegmentMock.invocationsDone()
}

// MinimockWithSegmentInspect logs each unmet expectation
func (m *RegistryClientMock) MinimockWithSegmentInspect() {
	for _, e := range m.WithSegmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWithSegmentCounter := mm_atomic.LoadUint64(&m.afterWithSegmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WithSegmentMock.defaultExpectation != nil && afterWithSegmentCounter < 1 {
		if m.WithSegmentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s", m.WithSegmentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s with params: %#v", m.WithSegmentMock.defaultExpectation.expectationOrigins.origin, *m.WithSegmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithSegment != nil && afterWithSegmentCounter < 1 {
		m.t.Errorf("Expected call to RegistryClientMock.WithSegment at\n%s", m.funcWithSegmentOrigin)
	}

	if !m.WithSegmentMock.invocationsDone() && afterWithSegmentCounter > 0 {
		m.t.Errorf("Expected %d calls to RegistryClientMock.WithSegment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WithSegmentMock.expectedInvocations), m.WithSegmentMock.expectedInvocationsOrigin, afterWithSegmentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistryClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckImageExistsInspect()

			m.MinimockGetDigestInspect()

			m.MinimockGetImageInspect()

			m.MinimockGetImageConfigInspect()

			m.MinimockGetManifestInspect()

			m.MinimockGetRegistryInspect()

			m.MinimockListRepositoriesInspect()

			m.MinimockListTagsInspect()

			m.MinimockPushImageInspect()

			m.MinimockWithSegmentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistryClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistryClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckImageExistsDone() &&
		m.MinimockGetDigestDone() &&
		m.MinimockGetImageDone() &&
		m.MinimockGetImageConfigDone() &&
		m.MinimockGetManifestDone() &&
		m.MinimockGetRegistryDone() &&
		m.MinimockListRepositoriesDone() &&
		m.MinimockListTagsDone() &&
		m.MinimockPushImageDone() &&
		m.MinimockWithSegmentDone()
}
